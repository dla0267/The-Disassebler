00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 12/8/2018 9:08:21 PM

00000000                             1  *------------------------------------------------------------------
00000000                             2  * Title      :  Team A Disassembler- CSS 422
00000000                             3  * Written by :  Orpal Nagra, Kris (Giwhan) Kwon, Yuunbum Lim
00000000                             4  * Date       :  12/8/2018
00000000                             5  * Description:  Please see attached docs for detailed description 
00000000                             6  *------------------------------------------------------------------
00000000                             7  
00000000  =00007000                  8  STACK  EQU $7000                    ; 
00000000  =00007000                  9  range_start EQU $7000               ;
00000000  =00009FFF                 10  range_end   EQU $9FFF               ;       
00000000  =00000010                 11  list_hex_size   EQU     16          ; 
00000000  =00000000                 12  clear           EQU     $00000000   ;
00000000  =00000014                 13  display_size    EQU 20              ;    
00000000  =00000000                 14  init    EQU 0                       ; 
00000000  =00000001                 15  increment   EQU 1                   ;
00000000  =00000008                 16  long EQU    8                       ;  
00000000  =00000004                 17  word    EQU 4                       ; 
00000000  =00000002                 18  byte    EQU 2                       ; 
00000000                            19  
00000000                            20  * Special characters                ; 
00000000  =0000000D                 21  CR  EQU $0D                         ; 
00000000  =0000000A                 22  LF  EQU $0A                         ; 
00000000  =00000000                 23  NULL    EQU $00                     ; 
00000000  =00000009                 24  TAB EQU $09                         ; 
00000000  =00000024                 25  DOLLAR EQU  $24                     ; #36 in dec 
00000000  =0000002C                 26  COMMA   EQU $2C                     ; 
00000000  =0000002E                 27  PERIOD  EQU $2E                     ; 
00000000  =0000002B                 28  PLUS    EQU $2B                     ; 
00000000  =0000002D                 29  MINUS   EQU  $2D                    ; 
00000000  =00000028                 30  Open_paren  EQU $28                 ; 
00000000  =00000029                 31  Close_paren EQU $29                 ;
00000000  =00000020                 32  SPACE   EQU $20                     ;     
00000000  =00000023                 33  SHARP   EQU $23                     ;    
00000000  =0000002F                 34  SLASH   EQU $2F                     ; 
00000000  =0000002D                 35  DASH    EQU $2D                     ;
00000000  =0000003A                 36  COLON   EQU $3A                     ;
00000000                            37  
00000000                            38  * Alphabet  
00000000  =00000041                 39  A_  EQU $41 ; 
00000000  =00000042                 40  B_  EQU $42 ; 
00000000  =00000043                 41  C_  EQU $43 ; 
00000000  =00000044                 42  D_  EQU $44 ; 
00000000  =00000045                 43  E_  EQU $45 ; 
00000000  =00000046                 44  F_  EQU $46 ; 
00000000  =00000047                 45  G_  EQU $47 ;
00000000  =00000048                 46  H_  EQU $48 ;
00000000  =00000049                 47  I_  EQU $49 ;
00000000  =0000004A                 48  J_  EQU $4A ; 
00000000  =0000004B                 49  K_  EQU $4B ; 
00000000  =0000004C                 50  L_  EQU $4C ;
00000000  =0000004D                 51  M_  EQU $4D ; 
00000000  =0000004E                 52  N_  EQU $4E ;
00000000  =0000004F                 53  O_  EQU $4F ; 
00000000  =00000050                 54  P_  EQU $50 ; 
00000000  =00000051                 55  Q_  EQU $51 ; 
00000000  =00000052                 56  R_  EQU $52 ; 
00000000  =00000053                 57  S_  EQU $53 ; 
00000000  =00000054                 58  T_  EQU $54 ; 
00000000  =00000055                 59  U_  EQU $55 ; 
00000000  =00000056                 60  V_  EQU $56 ; 
00000000  =00000057                 61  W_  EQU $57 ; 
00000000  =00000058                 62  X_  EQU $58 ; 
00000000  =00000059                 63  Y_  EQU $59 ; 
00000000  =0000005A                 64  Z_  EQU $5A ; 
00000000                            65  
00000000                            66  * Numbers   
00000000  =00000030                 67  ZERO_   EQU $30 ;   
00000000  =00000031                 68  ONE_    EQU $31 ;   
00000000  =00000032                 69  TWO_    EQU $32 ;   
00000000  =00000033                 70  THREE_  EQU $33 ;
00000000  =00000034                 71  FOUR_   EQU $34 ;   
00000000  =00000035                 72  FIVE_   EQU $35 ;   
00000000  =00000036                 73  SIX_    EQU $36 ;   
00000000  =00000037                 74  SEVEN_  EQU $37 ;   
00000000  =00000038                 75  EIGHT_  EQU $38 ;   
00000000  =00000039                 76  NINE_   EQU $39 ;   
00000000                            77  
00001000                            78      ORG $1000   
00001000                            79  START:                                      ; first instruction of program
00001000                            80  * Put program code here
00001000                            81  
00001000                            82  * get starting address
00001000                            83  StartPrompt    
00001000                            84      * prompt user to ask starting address   
00001000  6100 0042                 85      BSR PROMPT_START            ;
00001004                            86  
00001004                            87      * take starting address from the user     
00001004  6100 0058                 88      BSR TAKE_INPUT        ;   
00001008                            89      
00001008                            90      * convert input string to hex value 
00001008  6100 0068                 91      BSR STR_TO_HEX  ; result hex in D1  
0000100C                            92      
0000100C                            93      * check if starting address is in the range 
0000100C  6100 009C                 94      BSR CHECK_STARTING_BOUND    ;
00001010                            95      
00001010  6C00 0004                 96      BGE startingIsGreater       ;
00001014  60EA                      97      BRA StartPrompt    ;      
00001016                            98      
00001016                            99  startingIsGreater   
00001016  23C1 00003F6A            100      MOVE.L  D1, START_HEX   ;  
0000101C                           101  
0000101C                           102  * get ending address
0000101C                           103  EndPrompt      
0000101C                           104      * prompt to ask ending address  
0000101C  6100 0094                105      BSR PROMPT_END
00001020                           106      
00001020                           107      * take ending address from the user 
00001020  6100 003C                108      BSR TAKE_INPUT
00001024                           109      
00001024                           110      * convert input string to hex value 
00001024  6100 004C                111      BSR STR_TO_HEX
00001028                           112      
00001028                           113      * check if starting address is in the range
00001028  6100 00A2                114      BSR CHECK_ENDING_BOUND
0000102C                           115      
0000102C  6E00 0004                116      BGT endingIsGreaterThanStart    ; 
00001030                           117      
00001030                           118      
00001030  60EA                     119      BRA EndPrompt   
00001032                           120      
00001032                           121  endingIsGreaterThanStart    ; 
00001032  B2BC 00009FFF            122      CMP.L   #range_end, D1   ; 
00001038  6EE2                     123      BGT EndPrompt   ;    
0000103A                           124      
0000103A  23C1 00003F6E            125      MOVE.L  D1, END_HEX ;    
00001040                           126      
00001040  6000 0092                127      BRA MAIN
00001044                           128  
00001044                           129  
00001044                           130         
00001044                           131  
00001044                           132  PROMPT_START            ; Asking starting address    
00001044  43F9 00003EE2            133      LEA PROMPT_1, A1    ;   
0000104A  103C 000D                134      MOVE.B  #13, D0     ;   
0000104E  4E4F                     135      TRAP    #15         ;   
00001050                           136      
00001050  43F9 00003F3D            137      LEA PROMPT_3, A1    ;   
00001056  103C 000E                138      MOVE.B  #14, D0     ;   
0000105A  4E4F                     139      TRAP    #15         ;    
0000105C                           140      
0000105C  4E75                     141      RTS 
0000105E                           142      
0000105E                           143  TAKE_INPUT
0000105E  43F9 00003F72            144      LEA INPUT, A1       ;  
00001064                           145      
00001064                           146      * take input    
00001064  103C 0002                147      MOVE.B  #2, D0      ;   
00001068  4E4F                     148      TRAP    #15         ;   
0000106A                           149      
0000106A                           150      * move input to INPUT_LENGTH   
0000106A  33C1 00003F7A            151      MOVE.W  D1, INPUT_LENGTH
00001070  4E75                     152      RTS     
00001072                           153         
00001072                           154                  
00001072                           155  * convert input string to hex       
00001072                           156  STR_TO_HEX    
00001072  143C 0000                157      MOVE.B  #0, D2              ; starting index of the string  
00001076  3601                     158      MOVE.W  D1, D3              ; size of input string in D3    
00001078  7200                     159      MOVE.L  #clear, D1          ; clear D1
0000107A                           160      
0000107A                           161  str_loop    
0000107A  B682                     162      CMP.L   D2, D3              ; compare currentIndex of the string and the size   
0000107C  6700 002A                163      BEQ str_loop_end            ; 
00001080                           164      
00001080  1C19                     165      MOVE.B  (A1)+, D6           ; read one character from the input string store in D6  
00001082                           166      
00001082  183C 0000                167      MOVE.B  #0, D4              ; store starting index of list hex in D4 
00001086  1A38 0010                168      MOVE.B  list_hex_size, D5   ; store list hex size in D5 
0000108A                           169      
0000108A                           170  hex_loop    
0000108A  BA04                     171      CMP.B   D4, D5      ;   
0000108C  67EC                     172      BEQ str_loop    
0000108E                           173      
0000108E  45F9 00003F5A            174      LEA LIST_HEX, A2    ; address hex list in A2    
00001094  D5C4                     175      ADDA.L  D4, A2      ; current index in the list 
00001096                           176      
00001096  BC12                     177      CMP.B   (A2), D6    ; compare with current character and the list character 
00001098  6700 0006                178      BEQ hex_found       ; 
0000109C                           179      
0000109C  5204                     180      ADD.B   #1, D4      ; increment D4 by 1 
0000109E  60EA                     181      BRA hex_loop        ; go back to hex loop   
000010A0                           182      
000010A0                           183  hex_found   
000010A0  E941                     184      ASL #4, D1          ; shift D1 by 4bits 
000010A2  D204                     185      ADD.B   D4, D1      ; add current index into D1 
000010A4  5202                     186      ADD.B   #1, D2      ; increment currentIndex pointing at input hex string   
000010A6  60D2                     187      BRA str_loop        ; go back to str_loop   
000010A8                           188  
000010A8                           189  str_loop_end    
000010A8  4E75                     190      RTS 
000010AA                           191  
000010AA                           192  * check if the input is valid   
000010AA                           193  CHECK_STARTING_BOUND    
000010AA  B2BC 00007000            194      CMP.L   #range_start, D1    ;   input is greater than the starting range
000010B0  4E75                     195      RTS                         ;   
000010B2                           196  
000010B2                           197  PROMPT_END              ; Asking ending address  
000010B2  43F9 00003F10            198      LEA PROMPT_2, A1    ;    
000010B8  103C 000D                199      MOVE.B  #13, D0     ; 
000010BC  4E4F                     200      TRAP    #15         ;
000010BE                           201      
000010BE  43F9 00003F3D            202      LEA PROMPT_3, A1    ;   
000010C4  103C 000E                203      MOVE.B  #14, D0     ;   
000010C8  4E4F                     204      TRAP    #15         ;   
000010CA                           205      
000010CA  4E75                     206      RTS                 ;   
000010CC                           207      
000010CC                           208  CHECK_ENDING_BOUND 
000010CC  B2B9 00003F6A            209      CMP.L   (START_HEX), D1 ; ending address bigger than starting address
000010D2  4E75                     210      RTS 
000010D4                           211      
000010D4                           212  * Global variables (START_HEX & END_HEX) is set, use any registers.     
000010D4                           213  MAIN
000010D4                           214      * Output display 20 lines per enter
000010D4  2E7C 00007000            215      MOVEA.L  #STACK, A7   ;    
000010DA                           216      * Print the humanReadable codes until reaches the end_hex   
000010DA  2679 00003F6E            217      MOVEA.L  (END_HEX), A3       ; move endHex address to A3
000010E0  2479 00003F6A            218      MOVEA.L (START_HEX), A2     ; move start address to A2 
000010E6  49F9 00003F7C            219      LEA RESULT_MSG, A4       ; move result message starting address   
000010EC                           220          
000010EC                           221  decode_loop 
000010EC  B7CA                     222      CMPA.L   A2, A3             ;  
000010EE  6700 021E                223      BEQ finishProgram           ;   reached the end, finish Program
000010F2                           224      
000010F2                           225      * otherwise initialize counter and ask user for 'ENTER' to continue
000010F2  183C 0014                226      MOVE.B  #display_size, D4   ; move display size to D4   
000010F6  163C 0000                227      MOVE.B  #init, D3           ; move 0 to D3  ;
000010FA  2A4C                     228      MOVEA.L A4, A5              ; initialize current message index by copying starting addr
000010FC  6100 021C                229      BSR printContinueMessage    ; 
00001100  6100 0226                230      BSR takeContinueInput       ; 
00001104                           231          
00001104                           232   
00001104                           233  continue_decoding     
00001104                           234      * if not reached the end Index, 
00001104                           235      * read 20 instructions or currentHex to endHex (if fewer than 20 left)
00001104  B803                     236      CMP.B   D3, D4          ; reached 20 lines, 
00001106  6700 01EC                237      BEQ finish_page         ; go back to decode_loop
0000110A                           238          
0000110A                           239  decode
0000110A  2C4A                     240      MOVEA.L A2, A6          ;   
0000110C  3A1A                     241      MOVE.W  (A2)+, D5       ; move current opcode into D5
0000110E                           242      
0000110E                           243      * move D3 (= i), D4( = 20), A3(endHex), A4(result_message) into stack
0000110E  48E7 1818                244      MOVEM.L D3/D4/A3/A4, -(A7)  ;       
00001112                           245      * D5 contains current opcode and A2 contains startHex      
00001112                           246  decode_start    
00001112                           247      * decode starts here****************************************************************************    
00001112                           248      
00001112  48E7 0400                249      MOVEM.L D5, -(A7)   ; store opcode in the stack     
00001116                           250      * print address of current instruction  
00001116  123C 0004                251      MOVE.B  #word, D1      ;   size is word 
0000111A  6100 0158                252      BSR hex_to_string   ; put current opcode address into A6 and size into D1,  
0000111E  1AFC 0009                253      MOVE.B  #TAB, (A5)+ ; then current opcode address will be added in the result msg
00001122                           254      
00001122  4CDF 0020                255      MOVEM.L (A7)+, D5   ; get opcode back from stack  
00001126                           256  
00001126  4DF8 6000                257      LEA $6000, A6   ;   A6 as $6000 where temporary result is going to be saved   
0000112A                           258      
0000112A                           259      *   if RTS      
0000112A  0C45 4E75                260      CMPI.W  #$4E75, D5  ;
0000112E  6700 0240                261      BEQ RTS_function    ;    
00001132                           262      
00001132  0C45 4E71                263      CMPI.W  #$4E71, D5  ;   check if nop function
00001136  6700 0248                264      BEQ NOP_function    ;  
0000113A                           265  
0000113A  6100 019E                266      BSR get_firstFourBits   ; return first four bits in D0
0000113E  6100 01A4                267      BSR get_secondFourBits  ; return second four bits in D1 
00001142                           268      
00001142                           269      *  if first four bits are 0  
00001142  0C00 0000                270      CMPI.B  #0, D0  ;
00001146  6700 0078                271      BEQ zero_start  ;    
0000114A                           272      
0000114A  0C00 0001                273      CMPI.B  #1, D0  ;
0000114E  6700 008C                274      BEQ one_start   ;
00001152                           275  
00001152  0C00 0002                276      CMPI.B  #2, D0  ;   
00001156  6700 0088                277      BEQ two_start   ;   
0000115A                           278  
0000115A  0C00 0003                279      CMPI.B  #3, D0  ;   
0000115E  6700 0084                280      BEQ three_start ;   
00001162                           281      
00001162  0C00 0004                282      CMPI.B  #4, D0  ;   
00001166  6700 0080                283      BEQ four_start  ;   
0000116A                           284      
0000116A  0C00 0005                285      CMPI.B  #5, D0  ;   
0000116E  6700 009C                286      BEQ five_start  ;   
00001172                           287      
00001172  0C00 0006                288      CMPI.B  #6, D0  ;   
00001176  6700 0098                289      BEQ six_start   ;   
0000117A                           290      
0000117A  0C00 0008                291      CMPI.B  #8, D0  ;   
0000117E  6700 00C4                292      BEQ eight_start ;
00001182                           293  
00001182  0C00 0009                294      CMPI.B  #9, D0  ;   
00001186  6700 00C0                295      BEQ nine_start  ;   
0000118A                           296  
0000118A  0C00 000B                297      CMPI.B  #$B, D0 ;   
0000118E  6700 00BC                298      BEQ B_start     ;   
00001192                           299      
00001192  0C00 000C                300      CMPI.B  #$C, D0 ;   
00001196  6700 00B8                301      BEQ C_start     ;   
0000119A                           302      
0000119A  0C00 000D                303      CMPI.B  #$D, D0 ;   
0000119E  6700 00B4                304      BEQ D_start     ;
000011A2                           305  
000011A2  0C00 000E                306      CMPI.B  #$E, D0 ;   
000011A6  6700 00B0                307      BEQ E_start     ;     
000011AA                           308      
000011AA                           309      * no matcing operation 
000011AA  6000 0002                310      BRA invalid_code    ;   
000011AE                           311      
000011AE                           312  * check second four bits and send to decode functions
000011AE                           313  
000011AE                           314  invalid_code    
000011AE  4DF9 00003ED6            315      LEA INVALID_MSG, A6 ;   move message in A6  
000011B4  1C3C 000C                316      MOVE.B  #12, D6  ;   size is 10 for DATA    $WXYZ   
000011B8  6100 01A4                317      BSR copy_string ;   
000011BC  6000 009E                318      BRA decode_end  ;   
000011C0                           319       
000011C0                           320  zero_start  
000011C0                           321      * if second four bits are 0, ORI function   
000011C0  0C01 0000                322      CMPI.B   #0, D1  ;
000011C4  6700 01CA                323      BEQ ORI_function    ;   
000011C8                           324  
000011C8                           325      * if second foubits are 8, BCLR #, EA function  
000011C8  0C01 0008                326      CMPI.B   #8, D1  ;   
000011CC  6700 0388                327      BEQ BCLR_immediate_EA_function  ; 
000011D0                           328  
000011D0                           329      * if second four bits are C, CMPI function  
000011D0  0C01 000C                330      CMPI.B   #$C, D1 ;   
000011D4  6700 043E                331      BEQ CMPI_function   ;   
000011D8                           332      
000011D8                           333      * otherwise, go to BCLR Dn, EA function
000011D8  6000 0484                334      BRA BCLR_Dn_EA  ; 
000011DC                           335      
000011DC                           336  one_start
000011DC                           337      * branch to move.B function 
000011DC  6000 04D4                338      BRA MOVE_B  ;   
000011E0                           339      
000011E0                           340  two_start
000011E0                           341      * branch to move.L or movea.L function  
000011E0  6000 070E                342      BRA MOVE_MOVEA_L    ;   
000011E4                           343      
000011E4                           344  three_start 
000011E4                           345      * branch to move.w or movea.w funciton 
000011E4  6000 0AB8                346      BRA MOVE_MOVEA_W    ;   
000011E8                           347      
000011E8                           348  four_start  
000011E8                           349      * if second four bits are 4, branch to NEG function 
000011E8  0C01 0004                350      CMPI.B   #4, D1     ; 
000011EC  6700 0E5E                351      BEQ NEG_function    ;   
000011F0                           352      
000011F0                           353      * if second four bits are 8, branch to MOVEM.W, or MOVEM.L (Register to memory) function    
000011F0  0C01 0008                354      CMPI.B   #8, D1    ;   
000011F4  6700 0F9E                355      BEQ MOVEM_W_L_RtoM ;
000011F8                           356      
000011F8                           357      * if second fourbits are C, branch to MULS.L, DIVS.L, MOVEM.W, MOVEM.L (Memory to Register) function    
000011F8  0C01 000C                358      CMPI.B   #$C, D1 ;   
000011FC  6700 114E                359      BEQ MULS_DIVS_L_MOVEM_W_L_MtoR ;   
00001200                           360      
00001200                           361      * if second four bits are E, branch to JSR_function 
00001200  0C01 000E                362      CMPI.B   #$E, D1 ;   
00001204  6700 15AA                363      BEQ JSR_function    ;   
00001208                           364      
00001208                           365      * otherwise, branch to LEA function 
00001208  6000 15F4                366      BRA LEA_function    ; 
0000120C                           367      
0000120C                           368  five_start  
0000120C                           369      * branch to SUBQ function   
0000120C  6000 16BC                370      BRA SUBQ_function   ;
00001210                           371      
00001210                           372  six_start   
00001210                           373      * if second four bits are 0, branch to BRA function 
00001210  0C01 0000                374      CMPI.B   #0, D1  ; 
00001214  6700 17B6                375      BEQ BRA_function    ;
00001218                           376      
00001218                           377      * if second four bits are 4, branch to BCC function 
00001218  0C01 0004                378      CMPI.B   #4, D1  ;
0000121C  6700 181A                379      BEQ BCC_function    ;   
00001220                           380      
00001220                           381      * if second four bits are 5, branch to BCS function 
00001220  0C01 0005                382      CMPI.B   #5, D1  ;
00001224  6700 183A                383      BEQ BCS_function    ;
00001228                           384      
00001228                           385      * if second four bits are 8, branch to BVC function     
00001228  0C01 0008                386      CMPI.B   #8, D1  ;
0000122C  6700 185C                387      BEQ BVC_function    ;
00001230                           388      
00001230                           389      * if second four bits are C, branch to BGE function  
00001230  0C01 000C                390      CMPI.B   #$C, D1 ; 
00001234  6700 187E                391      BEQ BGE_function    ;
00001238                           392      
00001238                           393      * if second four bts are D, branch to BLT function 
00001238  0C01 000D                394      CMPI.B   #$D, D1    ; 
0000123C  6700 18A0                395      BEQ BLT_function    ; 
00001240                           396      
00001240                           397      * otherwise, branch to invalid code function 
00001240  6000 FF6C                398      BRA invalid_code    ;
00001244                           399      
00001244                           400  eight_start
00001244                           401      * branch to OR or DIVS.W function   
00001244  6000 18C2                402      BRA OR_DIVS_W   ; 
00001248                           403      
00001248                           404  nine_start
00001248                           405      * branch to SUB function 
00001248  6000 19B4                406      BRA SUB_function    ; 
0000124C                           407      
0000124C                           408  B_start
0000124C                           409      * barnch to EOR or CMP function 
0000124C  6000 1A38                410      BRA EOR_CMP ;  
00001250                           411  
00001250                           412  C_start
00001250                           413      * branch to ASLR, LSLR, ROLR, MULS.W function   
00001250  6000 1EF6                414      BRA MULS_W  ;    
00001254                           415  
00001254                           416  D_start
00001254                           417      * branch to Add or ADDA function 
00001254  6000 210C                418      BRA ADD_ADDA    ;     
00001258                           419      
00001258                           420  E_start 
00001258                           421      * banch to ASLR_LSLR_ROLR   
00001258  6000 27D0                422      BRA ASLR_LSLR_ROLR  ;   
0000125C                           423  
0000125C                           424      
0000125C                           425      
0000125C                           426      
0000125C                           427  
0000125C                           428         
0000125C                           429      
0000125C                           430      
0000125C                           431  
0000125C                           432  
0000125C                           433           
0000125C                           434      
0000125C                           435          
0000125C                           436      * decode ends here*******************************************************************************      
0000125C                           437  decode_end
0000125C                           438      * add decoded instruction to the result
0000125C                           439      * this should have done in decode functions   
0000125C                           440      
0000125C                           441      
0000125C                           442      * add CR, LF at the end of line 
0000125C  1AFC 000D                443      MOVE.B  #CR, (A5)+      ; 
00001260  1AFC 000A                444      MOVE.B  #LF, (A5)+      ;
00001264                           445      
00001264  4CDF 0818                446      MOVEM.L (A7)+, D3-D4/A3 ; move parameters back from stack  
00001268  5203                     447      ADDI.B  #increment, D3  ; increment D3 by 1 
0000126A  B7CA                     448      CMPA.L  A2, A3          ; if input hex reached the end before reaching 20 lines, 
0000126C  6700 0086                449      BEQ finish_page         ; go back to decode_loop to finish the program 
00001270  6000 FE92                450      BRA continue_decoding   ; otherwise, continue decoding  
00001274                           451  
00001274                           452  * hex in A6, size in D1 convert to string and put it in the A5,    
00001274                           453  * Long 4byte, Word = 2byte, Byte = 1byte, therefore D1 = 4, 2, or 1; 
00001274                           454  hex_to_string   ; since address is in word size 
00001274  41F9 00003F5A            455      LEA LIST_HEX, A0        ; load list hex into A0 
0000127A  240E                     456      MOVE.L  A6, D2          ; move A6(address value) into D2   
0000127C  103C 0000                457      MOVE.B  #init, D0       ; initilize count 0 in D0   
00001280                           458          
00001280  0C01 0008                459      CMPI.B  #long, D1       ; if size is long 
00001284  6700 0012                460      BEQ initLong            ; 
00001288                           461      
00001288  0C01 0004                462      CMPI.B  #word, D1       ; if size is word   
0000128C  6700 0014                463      BEQ initWord            ; 
00001290                           464      
00001290  0C01 0002                465      CMPI.B  #byte, D1       ; if size is byte   
00001294  6700 0016                466      BEQ initByte            ; 
00001298                           467      
00001298                           468  initLong
00001298  263C F0000000            469      MOVE.L  #$F0000000, D3  ;
0000129E  6000 0016                470      BRA htsLoop             ;  
000012A2                           471  
000012A2                           472  initWord
000012A2  263C 0000F000            473      MOVE.L  #$0000F000, D3  ; 
000012A8  6000 000C                474      BRA htsLoop             ; 
000012AC                           475  
000012AC                           476  initByte    
000012AC  263C 000000F0            477      MOVE.L  #$000000F0, D3  ; 
000012B2  6000 0002                478      BRA htsLoop             ; 
000012B6                           479      
000012B6                           480  htsLoop 
000012B6  B200                     481      CMP.B   D0, D1          ; 
000012B8  6700 001E                482      BEQ htsDone             ;
000012BC                           483      
000012BC                           484      * A0 has list_hex, D2 has address val, D3 has mask (D0, D1 reserved) 
000012BC  2802                     485      MOVE.L  D2, D4  ; copy addr value into D4   
000012BE  C883                     486      AND.L   D3, D4  ; masking and store in D4   
000012C0                           487      
000012C0                           488      * shift amount(D5) = (size(D1) * 2) - 1 - current(D0)
000012C0  2A01                     489      MOVE.L  D1, D5      ; 
000012C2  5385                     490      SUBI.L  #1, D5      ;   ((size) - 1 -> D5); 
000012C4  9A80                     491      SUB.L  D0, D5       ;   ((size) - 1 - current ->D5)
000012C6  7C04                     492      MOVE.L  #4, D6      ; 
000012C8  CAC6                     493      MULU.W  D6, D5      ;  ((size) - 1 - current ->D5) * 4
000012CA                           494      
000012CA  EAAC                     495      LSR.L   D5, D4      ; shift masked value right by shift amount
000012CC  ECAB                     496      LSR.L   D6, D3      ; shift mask to the right   
000012CE                           497      
000012CE                           498      * now D4 contains 4bits, find character in the hex list and add into result message 
000012CE  2648                     499      MOVEA.L A0, A3      ; copy hex list starting address to A3     
000012D0  D7C4                     500      ADD.L   D4, A3      ; index of character    
000012D2  1AD3                     501      MOVE.B  (A3), (A5)+ ; move the character into result message    
000012D4                           502      
000012D4  5200                     503      ADDI.B  #increment, D0  ; 
000012D6  60DE                     504      BRA htsLoop ;  
000012D8                           505      
000012D8                           506  htsDone    
000012D8  4E75                     507      RTS 
000012DA                           508      
000012DA                           509      
000012DA                           510  
000012DA                           511  * logical shift because sign is not necessary 
000012DA                           512  get_firstFourBits       ; from word input in D5,    return in D0    
000012DA  3005                     513      MOVE.W  D5, D0      ;
000012DC  123C 000C                514      MOVE.B  #12, D1     ;  
000012E0  E268                     515      LSR.W   D1, D0      ; 
000012E2  4E75                     516      RTS 
000012E4                           517      
000012E4                           518  *  logical shift because sign is not necessary 
000012E4                           519  get_secondFourBits      ; from word input in D5, return in D1 
000012E4  3205                     520      MOVE.W  D5, D1      ;
000012E6  143C 0004                521      MOVE.B  #4, D2      ; 
000012EA  E569                     522      LSL.W   D2, D1      ;
000012EC  143C 000C                523      MOVE.B  #12, D2     ;  
000012F0  E469                     524      LSR.W   D2, D1  ;  
000012F2  4E75                     525      RTS 
000012F4                           526  
000012F4                           527  
000012F4                           528  * clear console page    
000012F4                           529  * print a page and go back to decode_loop to continue   
000012F4                           530  finish_page 
000012F4  6100 005C                531      BSR clearScreen 
000012F8  6100 0006                532      BSR print_page  
000012FC  6000 FDEE                533      BRA decode_loop
00001300                           534  
00001300                           535  * print a page that contains "human readable" code    
00001300                           536  print_page  
00001300  1AFC 0000                537      MOVE.B  #NULL, (A5)+ 
00001304  224C                     538      MOVEA.L A4, A1          ; 
00001306  103C 000D                539      MOVE.B  #13, D0         ; 
0000130A  4E4F                     540      TRAP    #15             ; 
0000130C  4E75                     541      RTS 
0000130E                           542          
0000130E                           543          
0000130E                           544          
0000130E                           545  finishProgram   
0000130E  6100 0026                546      BSR printFinalMessage   ; 
00001312  6100 0030                547      BSR finishingInput      ; 
00001316                           548      
00001316  FFFF FFFF                549      SIMHALT                 ; halt simulator
0000131A                           550  
0000131A                           551      
0000131A                           552  printContinueMessage
0000131A  43F9 00003E92            553      LEA CONTINUE_MSG, A1    ;   
00001320  103C 000E                554      MOVE.B  #14, D0         ;   
00001324  4E4F                     555      TRAP    #15             ;   
00001326                           556  
00001326  4E75                     557      RTS 
00001328                           558  
00001328                           559  takeContinueInput
00001328  43F9 00003F72            560      LEA INPUT, A1           ; dummy input holder      
0000132E                           561      
0000132E                           562      * take input    
0000132E  103C 0002                563      MOVE.B  #2, D0          ;   
00001332  4E4F                     564      TRAP    #15             ;
00001334                           565     
00001334  4E75                     566      RTS     
00001336                           567      
00001336                           568      
00001336                           569  * print final message before exit   
00001336                           570  printFinalMessage           ;     
00001336  43F9 00003EAD            571      LEA FINAL_MSG, A1       ;   
0000133C  103C 000E                572      MOVE.B  #14, D0         ;   
00001340  4E4F                     573      TRAP    #15             ;   
00001342                           574  
00001342  4E75                     575      RTS 
00001344                           576  
00001344                           577  * take final input to exit program  
00001344                           578  finishingInput              ; 
00001344  43F9 00003F72            579      LEA INPUT, A1           ;  
0000134A                           580      
0000134A                           581      * take input    
0000134A  103C 0002                582      MOVE.B  #2, D0          ;   
0000134E  4E4F                     583      TRAP    #15             ;   
00001350  4E75                     584      RTS     
00001352                           585      
00001352                           586  clearScreen     
00001352  103C 000B                587      MOVE.B  #11, D0         ;    
00001356  323C FF00                588      MOVE.W  #$FF00, D1      ;    
0000135A  4E4F                     589      TRAP    #15             ;
0000135C  4E75                     590      RTS    
0000135E                           591  
0000135E                           592  
0000135E                           593  
0000135E                           594  *OP_ADD_MSG 
0000135E                           595  *    LEA ADD_MSG, A6 ; 
0000135E                           596  *    MOVE.B  #3, D6  ; we know that 'add' size is 3  
0000135E                           597  *    BSR copyLoop    ; 
0000135E                           598  
0000135E                           599  
0000135E                           600  * D6 contains the size of the string and A6  has string 
0000135E                           601  copy_string 
0000135E  1A3C 0000                602      MOVE.B  #0, D5          ;
00001362                           603  copyLoop          
00001362  BC05                     604      CMP.B   D5, D6          ;    
00001364  6700 0008                605      BEQ copyLoopDone        ;   
00001368  1ADE                     606      MOVE.B  (A6)+, (A5)+    ; A6 = string, A5 = result message
0000136A  5205                     607      ADDI.B  #1, D5          ;   
0000136C  60F4                     608      BRA copyLoop           ;
0000136E                           609  copyLoopDone
0000136E  4E75                     610      RTS                     ;     
00001370                           611  
00001370                           612  * D5 contains opcode, A2 contains next opcode to read from memory   
00001370                           613  * A5 contains result output pointer (string) 
00001370                           614  * Decode functions************************************************************************************ 
00001370                           615  RTS_function    
00001370  4DF9 00003E8C            616      LEA RTS_, A6    ; move memory address for RTS characters    
00001376  1C3C 0003                617      MOVE.B  #3, D6      ; RTS is 3 characters, size of string into D6   
0000137A  61E2                     618      BSR copy_string       ;   
0000137C  6000 FEDE                619      BRA decode_end  
00001380                           620  
00001380                           621  NOP_function
00001380  4DF9 00003E8F            622      LEA NOP_, A6        ; move memory address for NOP characters    
00001386  1C3C 0003                623      MOVE.B  #3, D6      ; NOP is 3 characters, size of string into D6   
0000138A  61D2                     624      BSR copy_string     ;   
0000138C  6000 FECE                625      BRA decode_end  
00001390                           626   
00001390                           627  * zero_start********************
00001390                           628  ORI_function
00001390  48E7 0004                629      MOVEM.L A5, -(A7)   ;   save A5 in the stack (pointer to result message)  
00001394  204E                     630      MOVEA.L A6, A0      ;   starting address of temp      
00001396  2A4E                     631      MOVEA.L A6, A5      ;   move starting address of curent temp Message into A0        
00001398                           632      * add function name in temporary memory 
00001398  1AFC 004F                633      MOVE.B  #O_, (A5)+   ;   
0000139C  1AFC 0052                634      MOVE.B  #R_, (A5)+   ;   
000013A0  1AFC 0049                635      MOVE.B  #I_, (A5)+   ; 
000013A4  1AFC 002E                636      MOVE.B  #PERIOD, (A5)+    
000013A8                           637      
000013A8                           638      * check size  00 - byte, 01 - word, 10 - long     
000013A8  3005                     639      MOVE.W  D5, D0          ;   copy opcode into D0 only byte size because starts with $00    
000013AA  3C3C 00C0                640      MOVE.W  #$00C0, D6      ;   bit mask in D6  
000013AE  1E3C 0006                641      MOVE.B  #6, D7          ;   shift value after masking   
000013B2  6100 2A16                642      BSR get_bit             ;   return size in D0   
000013B6                           643      
000013B6  0C00 0000                644      CMPI.B  #$00, D0        ;   if size == 0
000013BA  6700 001A                645          BEQ add_B           ;         
000013BE  0C00 0001                646      CMPI.B  #$01, D0        ;   if size == 1 
000013C2  6700 0038                647          BEQ add_W      
000013C6  0C00 0002                648      CMPI.B  #$02, D0        ;   if size == 2    
000013CA  6700 0056                649          BEQ add_L           ; 
000013CE                           650      
000013CE  4CDF 2000                651      MOVEM.L (A7)+, A5       ;   
000013D2  6000 FDDA                652      BRA invalid_code        ;  
000013D6                           653  
000013D6                           654  add_B
000013D6  1AFC 0042                655      MOVE.B  #B_, (A5)+      ;
000013DA  1AFC 0009                656      MOVE.B  #TAB, (A5)+     ;
000013DE  1AFC 0023                657      MOVE.B  #SHARP, (A5)+   ; 
000013E2  1AFC 0024                658      MOVE.B  #DOLLAR, (A5)+  ;    
000013E6  3C5A                     659      MOVE.W  (A2)+, A6       ;   A6 now contains word size next opcode   
000013E8                           660        
000013E8                           661  valid   
000013E8  123C 0002                662      MOVE.B  #byte, D1       ; 
000013EC  48E7 0480                663      MOVEM.L D5/A0, -(A7)    ;   
000013F0  6100 FE82                664      BSR hex_to_string       ;   
000013F4  4CDF 0120                665      MOVEM.L (A7)+, D5/A0    ; 
000013F8                           666      
000013F8  6000 004E                667      BRA check_mode          ;     
000013FC                           668  add_W   
000013FC  1AFC 0057                669      MOVE.B  #W_, (A5)+      ;
00001400  1AFC 0009                670      MOVE.B  #TAB, (A5)+     ;
00001404  1AFC 0023                671      MOVE.B  #SHARP, (A5)+   ;   
00001408  1AFC 0024                672      MOVE.B  #DOLLAR, (A5)+  ;   
0000140C  3C5A                     673      MOVE.W  (A2)+, A6       ;   read next opcode word size    
0000140E  123C 0004                674      MOVE.B  #word, D1       ;   
00001412  48E7 0480                675      MOVEM.L D5/A0, -(A7)    ; 
00001416  6100 FE5C                676      BSR hex_to_string       ;   
0000141A  4CDF 0120                677      MOVEM.L (A7)+, D5/A0    ;
0000141E                           678      
0000141E  6000 0028                679      BRA check_mode          ;   
00001422                           680  add_L     
00001422  1AFC 004C                681      MOVE.B  #L_, (A5)+      ;   
00001426  1AFC 0009                682      MOVE.B  #TAB, (A5)+     ;
0000142A  1AFC 0023                683      MOVE.B  #SHARP, (A5)+   ;  
0000142E  1AFC 0024                684      MOVE.B  #DOLLAR, (A5)+  ;   
00001432  2C5A                     685      MOVE.L  (A2)+, A6       ;   
00001434  123C 0008                686      MOVE.B  #long, D1       ;   
00001438  48E7 0480                687      MOVEM.L D5/A0, -(A7)  
0000143C  6100 FE36                688      BSR hex_to_string       ;   
00001440  4CDF 0120                689      MOVEM.L (A7)+, D5/A0    ;
00001444                           690      
00001444  6000 0002                691      BRA check_mode          ;   
00001448                           692      
00001448                           693  
00001448                           694  check_mode  
00001448  1AFC 002C                695      MOVE.B  #COMMA, (A5)+   ;   
0000144C  1AFC 0020                696      MOVe.B  #SPACE, (A5)+   ;   
00001450                           697      * check mode 000(Dn), 010 ((An)), 011((An)+), 100, (-(An)), 111(xxx.W or xxx.L)
00001450  3005                     698      MOVE.W  D5, D0      ;   copy opcode into D0 
00001452  3C3C 0038                699      MOVE.W  #$0038, D6  ;   bit mask in D6  
00001456  1E3C 0003                700      MOVE.B  #3, D7      ;   shift value after masking  
0000145A  6100 296E                701      BSR get_bit         ;   get mode bit    
0000145E  3200                     702      MOVE.W  D0, D1      ;   move mode bits to D1    
00001460                           703  
00001460  3005                     704      MOVE.W  D5, D0      ;   copy opcode into D0 
00001462  3C3C 0007                705      MOVE.W  #$0007, D6  ;   bit mask in D6  
00001466  1E3C 0000                706      MOVE.B  #0, D7      ;   shift value after masking  
0000146A  6100 295E                707      BSR get_bit         ;   get mode bit    
0000146E                           708      
0000146E                           709      * now D1 has mode bits, D0 has register bits    
0000146E                           710      
0000146E  0C41 0000                711      CMPI.W  #$00, D1            ;   if mode == 000   
00001472  6700 002A                712      BEQ ori_Data_reg            ;   
00001476                           713      
00001476  0C41 0002                714      CMPI.W  #$02, D1            ;   if mode == 010 
0000147A  6700 002E                715      BEQ ori_Addr_paren          ;      
0000147E                           716      
0000147E  0C41 0003                717      CMPI.W  #$03, D1            ;   if mode == 011 
00001482  6700 003A                718      BEQ ori_Addr_paren_plus     ;   
00001486                           719      
00001486  0C41 0004                720      CMPI.W  #$04, D1            ;   if mode == 100 
0000148A  6700 004A                721      BEQ ori_Addr_paren_minus    ;
0000148E                           722  
0000148E  0C41 0007                723      CMPI.w  #$07, D1            ;   if mode == 111 
00001492  6700 005A                724      BEQ ori_ea                  ;      
00001496                           725      
00001496  4CDF 2000                726      MOVEM.L (A7)+, A5           ;   Restore A5  from the stack  
0000149A  6000 FD12                727      BRA invalid_code            ;   otherwise, invalid code 
0000149E                           728      
0000149E                           729  ori_Data_reg
0000149E  1AFC 0044                730      MOVE.B  #D_, (A5)+          ; put Dn with number    
000014A2  6100 2956                731      BSR put_number              ;      
000014A6                           732  
000014A6  6000 008E                733      BRA ori_done                ;   
000014AA                           734  
000014AA                           735  ori_Addr_paren
000014AA  1AFC 0028                736      MOVE.B  #Open_paren, (A5)+  ; put (An) with number  
000014AE  1AFC 0041                737      MOVE.B  #A_, (A5)+          ;
000014B2  6100 2946                738      BSR put_number              ;      
000014B6                           739    
000014B6  1AFC 0029                740      MOVE.B  #Close_paren, (A5)+ ;
000014BA  6000 007A                741      BRA ori_done                ;   
000014BE                           742  
000014BE                           743  ori_Addr_paren_plus
000014BE  1AFC 0028                744      MOVE.B  #Open_paren, (A5)+  ; put (An)+ with number        
000014C2  1AFC 0041                745      MOVE.B  #A_, (A5)+          ;
000014C6  6100 2932                746      BSR put_number              ;   
000014CA  1AFC 0029                747      MOVE.B  #Close_paren, (A5)+ ;   
000014CE  1AFC 002B                748      MOVE.B  #PLUS, (A5)+        ;
000014D2                           749  
000014D2  6000 0062                750      BRA ori_done                ;      
000014D6                           751  ori_Addr_paren_minus
000014D6  1AFC 002D                752      MOVE.B  #MINUS, (A5)+       ; put -(An) with number    
000014DA  1AFC 0028                753      MOVE.B  #Open_paren, (A5)+  ;   
000014DE  1AFC 0041                754      MOVE.B  #A_, (A5)+          ;
000014E2  6100 2916                755      BSR put_number              ;      
000014E6  1AFC 0029                756      MOVE.B  #Close_paren, (A5)+ ;   
000014EA                           757      
000014EA  6000 004A                758      BRA ori_done                ;   
000014EE                           759  ori_ea  
000014EE  1AFC 0024                760      MOVE.B  #DOLLAR, (A5)+      ;   
000014F2  0C40 0000                761      CMPI.W  #$00, D0            ; if register == 00 
000014F6  6700 0012                762      BEQ word_ea                 ;   
000014FA                           763      
000014FA  0C40 0001                764      CMPI.W  #$01, D0            ; if register == 01   
000014FE  6700 0020                765      BEQ long_ea                 ;  
00001502                           766  
00001502  4CDF 2000                767      MOVEM.L (A7)+, A5           ;   
00001506  6000 FCA6                768      BRA invalid_code            ;    
0000150A                           769      
0000150A                           770  word_ea                         ;       
0000150A  3C5A                     771      MOVEA.W (A2)+, A6           ; read word size more opcode       
0000150C  323C 0004                772      MOVE.W  #word, D1           ;   
00001510  48E7 0480                773      MOVEM.L D5/A0, -(A7)        ;
00001514  6100 FD5E                774      BSR hex_to_string           ;       
00001518  4CDF 0120                775      MOVEM.L (A7)+, D5/A0        ;
0000151C  6000 0018                776      BRA ori_done                ;   
00001520                           777  
00001520                           778  long_ea                         ;   
00001520  2C5A                     779      MOVEA.L (A2)+, A6           ; 
00001522  323C 0008                780      MOVE.W  #long, D1           ; read long size more opcode      
00001526  48E7 0480                781      MOVEM.L D5/A0, -(A7)        ;
0000152A  6100 FD48                782      BSR hex_to_string           ;   
0000152E  4CDF 0120                783      MOVEM.L (A7)+, D5/A0        ;
00001532  6000 0002                784      BRA ori_done                ;   
00001536                           785  
00001536                           786  ori_done    
00001536                           787      * copy into the result message  ;  
00001536                           788      * get size of the message    
00001536  2C48                     789      MOVEA.L A0, A6              ; move starting address back to A6   
00001538                           790      * count till A0 == A5       ;
00001538  4246                     791      CLR D6                      ; D6 == 0    
0000153A                           792  ori_loop    
0000153A  BBC8                     793      CMPA.L  A0, A5  ;   
0000153C  6700 000C                794      BEQ ori_message_out 
00001540  5286                     795      ADDI.L  #1, D6  ;   increment count  
00001542  2A08                     796      MOVE.L  A0, D5  ;   
00001544  5285                     797      ADDI.L  #1, D5  ;   
00001546  2045                     798      MOVEA.L D5, A0  ;   increment address   
00001548  60F0                     799      BRA ori_loop    ;   
0000154A                           800  
0000154A                           801      
0000154A                           802  ori_message_out     
0000154A                           803      * D6 contains size and A6 pointing to the tempMessage   
0000154A  4CDF 2000                804      MOVEM.L (A7)+, A5   ;   Restore A5  from the stack  
0000154E  6100 FE0E                805      BSR copy_string     ;   
00001552  6000 FD08                806      BRA decode_end
00001556                           807      
00001556                           808  ***********************************************************************
00001556                           809  
00001556                           810  BCLR_immediate_EA_function 
00001556  48E7 0004                811      MOVEM.L A5, -(A7)   ;   save A5 in the stack (pointer to result message)  
0000155A  204E                     812      MOVEA.L A6, A0      ;   starting address of temp      
0000155C  2A4E                     813      MOVEA.L A6, A5      ;   move starting address of curent temp Message into A0    
0000155E                           814      
0000155E                           815      * add function name in temporary memory 
0000155E  1AFC 0042                816      MOVE.B  #B_, (A5)+   ;   
00001562  1AFC 0043                817      MOVE.B  #C_, (A5)+   ;   
00001566  1AFC 004C                818      MOVE.B  #L_, (A5)+   ; 
0000156A  1AFC 0052                819      MOVE.B  #R_, (A5)+  ;       
0000156E  1AFC 0009                820      MOVE.B  #TAB, (A5)+ ;   
00001572                           821      
00001572                           822      * check size  00 - byte, 01 - word, 10 - long     
00001572  3005                     823      MOVE.W  D5, D0  ;   copy opcode into D0 only byte size because starts with $00    
00001574  3C3C 00C0                824      MOVE.W  #$00C0, D6    ;   bit mask in D6  
00001578  1E3C 0006                825      MOVE.B  #6, D7      ;   shift value after masking   
0000157C  6100 284C                826      BSR get_bit         ;   return size in D0   
00001580                           827    
00001580  0C00 0002                828      CMPI.B  #$02, D0    ;   if size == 1 
00001584  6700 000A                829          BEQ bclr_immediate_ea_valid ;     
00001588                           830      
00001588  4CDF 2000                831      MOVEM.L (A7)+, A5   ;   
0000158C  6000 FC20                832      BRA invalid_code    ;  
00001590                           833  
00001590                           834  bclr_immediate_ea_valid ;   
00001590                           835      * put immediate value in the temp message   
00001590  1AFC 0023                836      MOVE.B  #SHARP, (A5)+   ; 
00001594  1AFC 0024                837      MOVE.B  #DOLLAR, (A5)+  ;    
00001598  3C5A                     838      MOVE.W  (A2)+, A6   ;   A6 now contains word size next opcode   
0000159A                           839      
0000159A                           840      * check if first 8 bits are 0s  
0000159A  220E                     841      MOVE.L  A6, D1      ;   
0000159C  E049                     842      LSR.W   #8, D1      ;   shift right 8   
0000159E  0C01 0000                843      CMPI.B  #$00, D1    ;   if $00 is starting bits 
000015A2  6700 000A                844      BEQ bclr_im_val           ;   true, then go to valid  
000015A6                           845      
000015A6  4CDF 2000                846      MOVEM.L (A7)+, A5   ;   Restore A5  from the stack  
000015AA  6000 FC02                847      BRA invalid_code    ;   otherwise, go to invalid code   
000015AE                           848  bclr_im_val 
000015AE  123C 0002                849      MOVE.B  #byte, D1   ; 
000015B2  48E7 0480                850      MOVEM.L D5/A0, -(A7)  
000015B6  6100 FCBC                851      BSR hex_to_string   ;   
000015BA  4CDF 0120                852      MOVEM.L (A7)+, D5/A0  ; 
000015BE                           853      
000015BE  1AFC 002C                854      MOVE.B  #COMMA, (A5)+   ;
000015C2  1AFC 0020                855      MOVE.B  #SPACE, (A5)+   ;      
000015C6                           856  
000015C6                           857      * now get mode and register number  
000015C6  3005                     858      MOVE.W  D5, D0      ;   copy opcode into D0 
000015C8  3C3C 0038                859      MOVE.W  #$0038, D6  ;   bit mask in D6  
000015CC  1E3C 0003                860      MOVE.B  #3, D7      ;   shift value after masking  
000015D0  6100 27F8                861      BSR get_bit         ;   get mode bit    
000015D4  3200                     862      MOVE.W  D0, D1      ;   move mode bits to D1    
000015D6                           863  
000015D6  3005                     864      MOVE.W  D5, D0      ;   copy opcode into D0 
000015D8  3C3C 0007                865      MOVE.W  #$0007, D6  ;   bit mask in D6  
000015DC  1E3C 0000                866      MOVE.B  #0, D7      ;   shift value after masking  
000015E0  6100 27E8                867      BSR get_bit         ;   get mode bit
000015E4                           868      
000015E4                           869      * D1 has mode, D0 has register number   
000015E4  0C41 0000                870      CMPI.W  #$00, D1    ;  000   
000015E8  6700 FEB4                871      BEQ ori_Data_reg    ;   
000015EC                           872      
000015EC  0C41 0002                873      CMPI.W  #$02, D1    ;   010 
000015F0  6700 FEB8                874      BEQ ori_Addr_paren  ;      
000015F4                           875      
000015F4  0C41 0003                876      CMPI.W  #$03, D1    ;   011 
000015F8  6700 FEC4                877      BEQ ori_Addr_paren_plus  ;   
000015FC                           878      
000015FC  0C41 0004                879      CMPI.W  #$04, D1    ;   100 
00001600  6700 FED4                880      BEQ ori_Addr_paren_minus    ;
00001604                           881  
00001604  0C41 0007                882      CMPI.w  #$07, D1    ;   111 
00001608  6700 FEE4                883      BEQ ori_ea          ;      
0000160C                           884      
0000160C                           885      
0000160C  4CDF 2000                886      MOVEM.L (A7)+, A5   ;   Restore A5  from the stack  
00001610  6000 FB9C                887      BRA invalid_code    ;   otherwise, invalid code 
00001614                           888      
00001614                           889  ***********************************************************************
00001614                           890  
00001614                           891  CMPI_function
00001614  48E7 0004                892      MOVEM.L A5, -(A7)   ;   save A5 in the stack (pointer to result message)  
00001618  204E                     893      MOVEA.L A6, A0      ;   starting address of temp      
0000161A  2A4E                     894      MOVEA.L A6, A5      ;   move starting address of curent temp Message into A0        
0000161C                           895      * add function name in temporary memory 
0000161C  1AFC 0043                896      MOVE.B  #C_, (A5)+   ;   
00001620  1AFC 004D                897      MOVE.B  #M_, (A5)+   ;   
00001624  1AFC 0050                898      MOVE.B  #P_, (A5)+  ;       
00001628  1AFC 0049                899      MOVE.B  #I_, (A5)+   ; 
0000162C  1AFC 002E                900      MOVE.B  #PERIOD, (A5)+    
00001630                           901      
00001630                           902      * check size  00 - byte, 01 - word, 10 - long     
00001630  3005                     903      MOVE.W  D5, D0  ;   copy opcode into D0 only byte size because starts with $00    
00001632  3C3C 00C0                904      MOVE.W  #$00C0, D6    ;   bit mask in D6  
00001636  1E3C 0006                905      MOVE.B  #6, D7      ;   shift value after masking   
0000163A  6100 278E                906      BSR get_bit         ;   return size in D0   
0000163E                           907      
0000163E  0C00 0000                908      CMPI.B  #$00, D0    ;   if size == 0
00001642  6700 FD92                909          BEQ add_B     ;         
00001646  0C00 0001                910      CMPI.B  #$01, D0    ;   if size == 1 
0000164A  6700 FDB0                911          BEQ add_W      
0000164E  0C00 0002                912      CMPI.B  #$02, D0    ;   if size == 2    
00001652  6700 FDCE                913          BEQ add_L   ; 
00001656                           914      
00001656  4CDF 2000                915      MOVEM.L (A7)+, A5   ;   
0000165A  6000 FB52                916      BRA invalid_code    ;  
0000165E                           917  
0000165E                           918      
0000165E                           919  ***********************************************************************
0000165E                           920  BCLR_Dn_EA 
0000165E  48E7 0004                921      MOVEM.L A5, -(A7)   ;   save A5 in the stack (pointer to result message)  
00001662  204E                     922      MOVEA.L A6, A0      ;   starting address of temp      
00001664  2A4E                     923      MOVEA.L A6, A5      ;   move starting address of curent temp Message into A0        
00001666                           924      * add function name in temporary memory 
00001666  1AFC 0042                925      MOVE.B  #B_, (A5)+   ;   
0000166A  1AFC 0043                926      MOVE.B  #C_, (A5)+   ;   
0000166E  1AFC 004C                927      MOVE.B  #L_, (A5)+  ;       
00001672  1AFC 0052                928      MOVE.B  #R_, (A5)+   ; 
00001676  1AFC 0009                929      MOVE.B  #TAB, (A5)+    
0000167A                           930  
0000167A  3005                     931      MOVE.W  D5, D0      ;   copy opcode into D0 
0000167C  3C3C 01C0                932      MOVE.W  #$01C0, D6  ;   bit mask in D6    
00001680  1E3C 0006                933      MOVE.B  #6, D7      ;   shift value after masking   
00001684  6100 2744                934      BSR get_bit         ;   
00001688                           935      
00001688  0C40 0006                936      CMPI.W  #6, D0      ;   
0000168C  6700 000A                937      BEQ bclr_dn_valid   ;   
00001690                           938      
00001690  4CDF 2000                939      MOVEM.L (A7)+, A5   ;
00001694  6000 FB18                940      BRA invalid_code    ;
00001698                           941  
00001698                           942  bclr_dn_valid                   ;
00001698                           943      * get first D register value    ;   
00001698  3005                     944      MOVE.W  D5, D0      ;   copy opcode into D0 
0000169A  3C3C 0F00                945      MOVE.W  #$0F00, D6  ; bit mask in D6    
0000169E  1E3C 0009                946      MOVE.B  #9, D7      ;   shift value after masking in D7 
000016A2  6100 2726                947      BSR get_bit     ;    
000016A6                           948  
000016A6  1AFC 0044                949      MOVE.B  #D_, (A5)+  ;
000016AA  6100 274E                950      BSR put_number  ;   
000016AE                           951  
000016AE  6000 FD98                952      BRA check_mode     ;      
000016B2                           953  ***********************************************************************
000016B2                           954  * one_start **********************************************************************************  
000016B2                           955  MOVE_B   
000016B2  48E7 0004                956      MOVEM.L A5, -(A7)   ;   save A5 in the stack (pointer to result message)  
000016B6  204E                     957      MOVEA.L A6, A0      ;   starting address of temp      
000016B8  2A4E                     958      MOVEA.L A6, A5      ;   move starting address of curent temp Message into A0
000016BA                           959      
000016BA  1AFC 004D                960      MOVE.B  #M_, (A5)+   ;   
000016BE  1AFC 004F                961      MOVE.B  #O_, (A5)+   ;   
000016C2  1AFC 0056                962      MOVE.B  #V_, (A5)+  ;       
000016C6  1AFC 0045                963      MOVE.B  #E_, (A5)+   ; 
000016CA  1AFC 002E                964      MOVE.B  #PERIOD, (A5)+  ;   
000016CE  1AFC 0042                965      MOVE.B  #B_, (A5)+  ;   
000016D2  1AFC 0009                966      MOVE.B  #TAB, (A5)+ ;   
000016D6                           967  
000016D6                           968  move_b_src     
000016D6                           969      * get source mode and register in D1 and D0 
000016D6  3005                     970      MOVE.W  D5, D0      ;   copy opcode into D0 
000016D8  3C3C 0038                971      MOVE.W  #$0038, D6  ;   bit mask in D6    
000016DC  1E3C 0003                972      MOVE.B  #3, D7      ;   shift value after masking   
000016E0  6100 26E8                973      BSR get_bit         ;
000016E4  3200                     974      MOVE.W  D0, D1      ;   D1 contains mode of source  
000016E6                           975  
000016E6  3005                     976      MOVE.W  D5, D0      ;   copy opcode into D0 
000016E8  3C3C 0007                977      MOVE.W  #$0007, D6  ;   bit mask in D6  
000016EC  1E3C 0000                978      MOVE.B  #0, D7      ;   shift value after masking   
000016F0  6100 26D8                979      BSR get_bit         ;   
000016F4                           980      
000016F4                           981      * now D1 has source mode, D0 has source register number 
000016F4  0C41 0000                982      CMPI.W  #$0000, D1          ; if mode == 0  
000016F8  6700 0032                983      BEQ move_b_Data_reg         ;   
000016FC                           984  
000016FC  0C41 0001                985      CMPI.W  #$0001, D1          ; if mode == 1  
00001700  6700 0036                986      BEQ move_b_Addr_reg         ;   
00001704                           987  
00001704  0C41 0002                988      CMPI.W  #$0002, D1          ; if mode == 2     
00001708  6700 003A                989      BEQ move_b_Addr_reg_paren ;   
0000170C                           990  
0000170C  0C41 0003                991      CMPI.W  #$0003, D1          ; if mode == 3    
00001710  6700 0046                992      BEQ move_b_Addr_reg_plus    ;   
00001714                           993  
00001714  0C41 0004                994      CMPI.W  #$0004, D1          ; if mode == 4  
00001718  6700 0056                995      BEQ move_b_Addr_reg_minus   ;   
0000171C                           996  
0000171C  0C41 0007                997      CMPI.W  #$0007, D1          ; if mode == 7  
00001720  6700 0066                998      BEQ move_b_ea_im            ;   
00001724                           999      
00001724  4CDF 2000               1000      MOVEM.L (A7)+, A5           ;   
00001728  6000 FA84               1001      BRA invalid_code            ; otherwise return invalid message  
0000172C                          1002  
0000172C                          1003  move_b_Data_reg 
0000172C  1AFC 0044               1004      MOVE.B  #D_, (A5)+          ; put Dn with number    
00001730  6100 26C8               1005      BSR put_number              ;   
00001734                          1006      
00001734  6000 00C4               1007      BRA move_b_dest             ;   
00001738                          1008  
00001738                          1009  move_b_Addr_reg 
00001738  1AFC 0041               1010      MOVE.B  #A_, (A5)+          ; put An with number    
0000173C  6100 26BC               1011      BSR put_number              ;   
00001740                          1012      
00001740  6000 00B8               1013      BRA move_b_dest             ;
00001744                          1014  
00001744                          1015  move_b_Addr_reg_paren   
00001744  1AFC 0028               1016      MOVE.B  #Open_paren, (A5)+  ; put (An) with number  
00001748  1AFC 0041               1017      MOVE.B  #A_, (A5)+          ;   
0000174C  6100 26AC               1018      BSR put_number              ;   
00001750  1AFC 0029               1019      MOVE.B  #Close_paren, (A5)+ ;   
00001754                          1020      
00001754  6000 00A4               1021      BRA move_b_dest             ;   
00001758                          1022  
00001758                          1023  move_b_addr_reg_plus            ;   
00001758  1AFC 0028               1024      MOVE.B  #Open_paren, (A5)+  ; put (An)+ with number     
0000175C  1AFC 0041               1025      MOVE.B  #A_, (A5)+          ;   
00001760  6100 2698               1026      BSR put_number              ;   
00001764  1AFC 0029               1027      MOVE.B  #Close_paren, (A5)+ ;  
00001768  1AFC 002B               1028      MOVE.B  #PLUS, (A5)+        ;   
0000176C  6000 008C               1029      BRA move_b_dest             ;
00001770                          1030  
00001770                          1031  move_b_addr_reg_minus           ; put -(An) with number 
00001770  1AFC 002D               1032      MOVE.B  #MINUS, (A5)+       ;   
00001774  1AFC 0028               1033      MOVE.B  #Open_paren, (A5)+  ;     
00001778  1AFC 0041               1034      MOVE.B  #A_, (A5)+          ;   
0000177C  6100 267C               1035      BSR put_number              ;   
00001780  1AFC 0029               1036      MOVE.B  #Close_paren, (A5)+ ;  
00001784                          1037  
00001784  6000 0074               1038      BRA move_b_dest ;
00001788                          1039  
00001788                          1040  move_b_ea_im    ;
00001788  0C40 0000               1041      CMPI.W  #$0000, D0          ; if register == 0  
0000178C  6700 001A               1042      BEQ move_b_src_word         ;   
00001790                          1043      
00001790  0C40 0001               1044      CMPI.W  #$0001, D0          ; if register == 1  
00001794  6700 002C               1045      BEQ move_b_src_long         ;   
00001798                          1046      
00001798  0C40 0004               1047      CMPI.W  #$0004, D0          ; if register == 4  
0000179C  6700 003E               1048      BEQ move_b_src_imm          ;   
000017A0                          1049      
000017A0  4CDF 2000               1050      MOVEM.L (A7)+, A5           ; otherwise return invalid message  
000017A4  6000 FA08               1051      BRA invalid_code            ;   
000017A8                          1052  
000017A8                          1053  move_b_src_word 
000017A8  1AFC 0024               1054      MOVE.B  #DOLLAR, (A5)+      ; read more opcode word size    
000017AC  3C5A                    1055      MOVEA.W (A2)+, A6           ;   
000017AE  323C 0004               1056      MOVE.W  #word, D1           ;   
000017B2  48E7 0480               1057      MOVEM.L D5/A0, -(A7)        ;
000017B6  6100 FABC               1058      BSR hex_to_string           ;   
000017BA  4CDF 0120               1059      MOVEM.L (A7)+, D5/A0        ; 
000017BE                          1060      
000017BE  6000 003A               1061      BRA move_b_dest 
000017C2                          1062  move_b_src_long
000017C2  1AFC 0024               1063      MOVE.B  #DOLLAR, (A5)+      ; read more opcode long size    
000017C6  2C5A                    1064      MOVEA.L (A2)+, A6           ;   
000017C8  323C 0008               1065      MOVE.W  #long, D1           ;   
000017CC  48E7 0480               1066      MOVEM.L D5/A0, -(A7)        ; 
000017D0  6100 FAA2               1067      BSR hex_to_string           ;   
000017D4  4CDF 0120               1068      MOVEM.L (A7)+, D5/A0        ;
000017D8                          1069      
000017D8  6000 0020               1070      BRA move_b_dest ;   
000017DC                          1071      
000017DC                          1072  move_b_src_imm      
000017DC  1AFC 0023               1073      MOVE.B  #SHARP, (A5)+       ; read more opcode word size      
000017E0  1AFC 0024               1074      MOVE.B  #DOLLAR, (A5)+      ; 
000017E4  3C5A                    1075      MOVEA.W (A2)+, A6           ;   
000017E6  323C 0002               1076      MOVE.W  #byte, D1           ;   
000017EA  48E7 0480               1077      MOVEM.L D5/A0, -(A7)        ;
000017EE  6100 FA84               1078      BSR hex_to_string           ;   
000017F2  4CDF 0120               1079      MOVEM.L (A7)+, D5/A0        ;
000017F6                          1080      
000017F6  6000 0002               1081      BRA move_b_dest ;
000017FA                          1082  
000017FA                          1083  move_b_dest
000017FA  1AFC 002C               1084      MOVE.B  #COMMA, (A5)+       ;   
000017FE  1AFC 0020               1085      MOVE.B  #SPACE, (A5)+       ;   
00001802                          1086      
00001802                          1087      * now do the samething for dest 
00001802                          1088      * get dest mode and register in D1 and D0 
00001802  3005                    1089      MOVE.W  D5, D0      ;   copy opcode into D0 
00001804  3C3C 01C0               1090      MOVE.W  #$01C0, D6  ;   bit mask in D6    
00001808  1E3C 0006               1091      MOVE.B  #6, D7      ;   shift value after masking   
0000180C  6100 25BC               1092      BSR get_bit         ;
00001810  3200                    1093      MOVE.W  D0, D1      ;   D1 contains mode of dest mode    
00001812                          1094  
00001812  3005                    1095      MOVE.W  D5, D0      ;   copy opcode into D0 
00001814  3C3C 0E00               1096      MOVE.W  #$0E00, D6  ;   bit mask in D6  
00001818  1E3C 0009               1097      MOVE.B  #9, D7      ;   shift value after masking   
0000181C  6100 25AC               1098      BSR get_bit         ;   D0 contains register of dest    
00001820                          1099      
00001820                          1100      * now D1 has dest mode, D0 has dest register number 
00001820  0C41 0000               1101      CMPI.W  #$0000, D1                  ; if mode == 0     
00001824  6700 002A               1102      BEQ dest_move_b_Data_reg            ;    
00001828                          1103  
00001828  0C41 0002               1104      CMPI.W  #$0002, D1                  ; if mode == 2  
0000182C  6700 002E               1105      BEQ dest_move_b_Addr_reg_paren      ;   
00001830                          1106  
00001830  0C41 0003               1107      CMPI.W  #$0003, D1                  ; if mode == 3  
00001834  6700 003A               1108      BEQ dest_move_b_Addr_reg_plus       ;   
00001838                          1109  
00001838  0C41 0004               1110      CMPI.W  #$0004, D1                  ; if mode == 4  
0000183C  6700 004A               1111      BEQ dest_move_b_Addr_reg_minus      ;   
00001840                          1112  
00001840  0C41 0007               1113      CMPI.W  #$0007, D1                  ; if mode == 7  
00001844  6700 005A               1114      BEQ dest_move_b_ea                  ;   
00001848                          1115      
00001848  4CDF 2000               1116      MOVEM.L (A7)+, A5                   ; otherwise return invalid message  
0000184C  6000 F960               1117      BRA invalid_code    
00001850                          1118  
00001850                          1119  dest_move_b_Data_reg 
00001850  1AFC 0044               1120      MOVE.B  #D_, (A5)+                  ; put Dn with number    
00001854  6100 25A4               1121      BSR put_number                      ;   
00001858                          1122      
00001858  6000 0092               1123      BRA move_b_done                     ;     
0000185C                          1124  
0000185C                          1125  dest_move_b_Addr_reg_paren   
0000185C  1AFC 0028               1126      MOVE.B  #Open_paren, (A5)+          ; putn (An) with number 
00001860  1AFC 0041               1127      MOVE.B  #A_, (A5)+                  ;   
00001864  6100 2594               1128      BSR put_number                      ;   
00001868  1AFC 0029               1129      MOVE.B  #Close_paren, (A5)+         ;   
0000186C                          1130      
0000186C  6000 007E               1131      BRA move_b_done                     ;   
00001870                          1132  
00001870                          1133  dest_move_b_addr_reg_plus               ; put (An)+ with number    
00001870  1AFC 0028               1134      MOVE.B  #Open_paren, (A5)+          ;     
00001874  1AFC 0041               1135      MOVE.B  #A_, (A5)+                  ;   
00001878  6100 2580               1136      BSR put_number                      ;   
0000187C  1AFC 0029               1137      MOVE.B  #Close_paren, (A5)+         ;  
00001880  1AFC 002B               1138      MOVE.B  #PLUS, (A5)+                ;   
00001884  6000 0066               1139      BRA move_b_done                     ;
00001888                          1140  
00001888                          1141  dest_move_b_addr_reg_minus              ;
00001888  1AFC 002D               1142      MOVE.B  #MINUS, (A5)+               ; put -(An) with number    
0000188C  1AFC 0028               1143      MOVE.B  #Open_paren, (A5)+          ;     
00001890  1AFC 0041               1144      MOVE.B  #A_, (A5)+                  ;   
00001894  6100 2564               1145      BSR put_number                      ;   
00001898  1AFC 0029               1146      MOVE.B  #Close_paren, (A5)+         ;  
0000189C                          1147  
0000189C  6000 004E               1148      BRA move_b_done                     ;
000018A0                          1149  
000018A0                          1150  dest_move_b_ea                          ;
000018A0  0C40 0000               1151      CMPI.W  #$0000, D0                  ; if register == 0   
000018A4  6700 0012               1152      BEQ dest_move_b_src_word            ;   
000018A8                          1153      
000018A8  0C40 0001               1154      CMPI.W  #$0001, D0                  ; if register == 1  
000018AC  6700 0024               1155      BEQ dest_move_b_src_long            ;   
000018B0                          1156      
000018B0  4CDF 2000               1157      MOVEM.L (A7)+, A5                   ;   
000018B4  6000 F8F8               1158      BRA invalid_code                    ; otherwise return invalid message     
000018B8                          1159  
000018B8                          1160  dest_move_b_src_word 
000018B8  1AFC 0024               1161      MOVE.B  #DOLLAR, (A5)+              ; read word size opcode more      
000018BC  3C5A                    1162      MOVEA.W (A2)+, A6                   ;   
000018BE  323C 0004               1163      MOVE.W  #word, D1                   ;   
000018C2  48E7 0480               1164      MOVEM.L D5/A0, -(A7)                ;
000018C6  6100 F9AC               1165      BSR hex_to_string                   ;   
000018CA  4CDF 0120               1166      MOVEM.L (A7)+, D5/A0                ;
000018CE                          1167      
000018CE  6000 001C               1168      BRA move_b_done 
000018D2                          1169  dest_move_b_src_long
000018D2  1AFC 0024               1170      MOVE.B  #DOLLAR, (A5)+              ; read long size opcode more    
000018D6  2C5A                    1171      MOVEA.L (A2)+, A6                   ;   
000018D8  323C 0008               1172      MOVE.W  #long, D1                   ;   
000018DC  48E7 0480               1173      MOVEM.L D5/A0, -(A7)                ; 
000018E0  6100 F992               1174      BSR hex_to_string                   ;   
000018E4  4CDF 0120               1175      MOVEM.L (A7)+, D5/A0                ;
000018E8                          1176      
000018E8  6000 0002               1177      BRA move_b_done                     ;   
000018EC                          1178      
000018EC                          1179  move_b_done 
000018EC  6000 FC48               1180      BRA ori_done    ;   
000018F0                          1181      
000018F0                          1182  * two_start *************************************************************************************   
000018F0                          1183  MOVE_MOVEA_L
000018F0                          1184      * check dest mode part and distinguish whether MOVE.L or MOVEA.L    
000018F0  48E7 0004               1185      MOVEM.L A5, -(A7)   ;   save A5 in the stack (pointer to result message)  
000018F4  204E                    1186      MOVEA.L A6, A0      ;   starting address of temp      
000018F6  2A4E                    1187      MOVEA.L A6, A5      ;   move starting address of curent temp Message into A0
000018F8                          1188      
000018F8  1AFC 004D               1189      MOVE.B  #M_, (A5)+      ;   
000018FC  1AFC 004F               1190      MOVE.B  #O_, (A5)+      ;   
00001900  1AFC 0056               1191      MOVE.B  #V_, (A5)+      ;       
00001904  1AFC 0045               1192      MOVE.B  #E_, (A5)+      ; 
00001908                          1193      
00001908                          1194      * get source mode and register in D1 and D0 
00001908  3005                    1195      MOVE.W  D5, D0      ;   copy opcode into D0 
0000190A  3C3C 01C0               1196      MOVE.W  #$01C0, D6  ;   bit mask in D6    
0000190E  1E3C 0006               1197      MOVE.B  #6, D7      ;   shift value after masking   
00001912  6100 24B6               1198      BSR get_bit         ;   D0 contains 6, 7, 8th bits  
00001916                          1199      
00001916  0C40 0001               1200      CMPI.W  #$0001, D0  ;   
0000191A  6700 0012               1201      BEQ MOVEA_L 
0000191E                          1202      
0000191E                          1203      * other wise, it is move L  ;   
0000191E  1AFC 002E               1204      MOVE.B  #PERIOD, (A5)+      ;   
00001922  1AFC 004C               1205      MOVE.B  #L_, (A5)+          ;   
00001926  1AFC 0009               1206      MOVE.B  #TAB, (A5)+         ;   
0000192A                          1207      
0000192A  6000 0158               1208      BRA MOVE_L                  ;   
0000192E                          1209  
0000192E                          1210      
0000192E                          1211  MOVEA_L 
0000192E  1AFC 0041               1212      MOVE.B  #A_, (A5)+          ;   
00001932  1AFC 002E               1213      MOVE.B  #PERIOD, (A5)+      ;   
00001936  1AFC 004C               1214      MOVE.B  #L_, (A5)+          ;   
0000193A  1AFC 0009               1215      MOVE.B  #TAB, (A5)+         ;   
0000193E                          1216      * get source mode and register in D1 and D0 
0000193E  3005                    1217      MOVE.W  D5, D0      ;   copy opcode into D0 
00001940  3C3C 0038               1218      MOVE.W  #$0038, D6  ;   bit mask in D6    
00001944  1E3C 0003               1219      MOVE.B  #3, D7      ;   shift value after masking   
00001948  6100 2480               1220      BSR get_bit         ;
0000194C  3200                    1221      MOVE.W  D0, D1      ;   D1 contains mode of source  
0000194E                          1222  
0000194E  3005                    1223      MOVE.W  D5, D0      ;   copy opcode into D0 
00001950  3C3C 0007               1224      MOVE.W  #$0007, D6  ;   bit mask in D6  
00001954  1E3C 0000               1225      MOVE.B  #0, D7      ;   shift value after masking   
00001958  6100 2470               1226      BSR get_bit         ;   
0000195C                          1227      
0000195C                          1228      * now D1 has source mode, D0 has source register number 
0000195C  0C41 0000               1229      CMPI.W  #$0000, D1          ; if mode == 0
00001960  6700 0032               1230      BEQ movea_l_Data_reg        ;   
00001964                          1231  
00001964  0C41 0001               1232      CMPI.W  #$0001, D1          ; if mode == 1  
00001968  6700 0036               1233      BEQ movea_l_Addr_reg        ;   
0000196C                          1234  
0000196C  0C41 0002               1235      CMPI.W  #$0002, D1          ; if mode == 2  
00001970  6700 003A               1236      BEQ movea_l_Addr_reg_paren  ;   
00001974                          1237  
00001974  0C41 0003               1238      CMPI.W  #$0003, D1          ; if mode == 3  
00001978  6700 0046               1239      BEQ movea_l_Addr_reg_plus   ;   
0000197C                          1240  
0000197C  0C41 0004               1241      CMPI.W  #$0004, D1          ; if mode == 4  
00001980  6700 0056               1242      BEQ movea_l_Addr_reg_minus  ;   
00001984                          1243  
00001984  0C41 0007               1244      CMPI.W  #$0007, D1          ; if mode == 7  
00001988  6700 0066               1245      BEQ movea_l_ea_im           ;   
0000198C                          1246      
0000198C  4CDF 2000               1247      MOVEM.L (A7)+, A5           ; otherwise return invalid message  
00001990  6000 F81C               1248      BRA invalid_code    
00001994                          1249  
00001994                          1250  movea_l_Data_reg 
00001994  1AFC 0044               1251      MOVE.B  #D_, (A5)+          ; put Dn with number    
00001998  6100 2460               1252      BSR put_number              ;   
0000199C                          1253      
0000199C  6000 00C4               1254      BRA movea_l_dest            ;   
000019A0                          1255  
000019A0                          1256  movea_l_Addr_reg 
000019A0  1AFC 0041               1257      MOVE.B  #A_, (A5)+          ; put An with number    
000019A4  6100 2454               1258      BSR put_number              ;   
000019A8                          1259      
000019A8  6000 00B8               1260      BRA movea_l_dest            ;
000019AC                          1261  
000019AC                          1262  movea_l_Addr_reg_paren   
000019AC  1AFC 0028               1263      MOVE.B  #Open_paren, (A5)+  ; put (An) with number  
000019B0  1AFC 0041               1264      MOVE.B  #A_, (A5)+          ;   
000019B4  6100 2444               1265      BSR put_number              ;   
000019B8  1AFC 0029               1266      MOVE.B  #Close_paren, (A5)+ ;   
000019BC                          1267      
000019BC  6000 00A4               1268      BRA movea_l_dest            ;   
000019C0                          1269  
000019C0                          1270  movea_l_addr_reg_plus           ;   
000019C0  1AFC 0028               1271      MOVE.B  #Open_paren, (A5)+  ; put (An)+ with number 
000019C4  1AFC 0041               1272      MOVE.B  #A_, (A5)+          ;   
000019C8  6100 2430               1273      BSR put_number              ;   
000019CC  1AFC 0029               1274      MOVE.B  #Close_paren, (A5)+ ;  
000019D0  1AFC 002B               1275      MOVE.B  #PLUS, (A5)+        ;   
000019D4  6000 008C               1276      BRA movea_l_dest            ;
000019D8                          1277  
000019D8                          1278  movea_l_addr_reg_minus          ;
000019D8  1AFC 002D               1279      MOVE.B  #MINUS, (A5)+       ; put -(An) with number 
000019DC  1AFC 0028               1280      MOVE.B  #Open_paren, (A5)+  ;     
000019E0  1AFC 0041               1281      MOVE.B  #A_, (A5)+          ;   
000019E4  6100 2414               1282      BSR put_number              ;   
000019E8  1AFC 0029               1283      MOVE.B  #Close_paren, (A5)+ ;  
000019EC                          1284  
000019EC  6000 0074               1285      BRA movea_l_dest            ;
000019F0                          1286  
000019F0                          1287  movea_l_ea_im                   ;
000019F0  0C40 0000               1288      CMPI.W  #$0000, D0          ; if register == 0  
000019F4  6700 001A               1289      BEQ movea_l_src_word        ;   
000019F8                          1290      
000019F8  0C40 0001               1291      CMPI.W  #$0001, D0          ; if register == 1  
000019FC  6700 002C               1292      BEQ movea_l_src_long        ;   
00001A00                          1293      
00001A00  0C40 0004               1294      CMPI.W  #$0004, D0          ; if register == 4  
00001A04  6700 003E               1295      BEQ movea_l_src_imm         ;   
00001A08                          1296      
00001A08  4CDF 2000               1297      MOVEM.L (A7)+, A5           ; otherwise return invalid message  
00001A0C  6000 F7A0               1298      BRA invalid_code            ;   
00001A10                          1299  
00001A10                          1300  movea_l_src_word 
00001A10  1AFC 0024               1301      MOVE.B  #DOLLAR, (A5)+      ; read word size more opcode    
00001A14  3C5A                    1302      MOVEA.W (A2)+, A6           ;   
00001A16  323C 0004               1303      MOVE.W  #word, D1           ;   
00001A1A  48E7 0480               1304      MOVEM.L D5/A0, -(A7)        ;
00001A1E  6100 F854               1305      BSR hex_to_string           ;   
00001A22  4CDF 0120               1306      MOVEM.L (A7)+, D5/A0        ;  
00001A26                          1307      
00001A26  6000 003A               1308      BRA movea_l_dest 
00001A2A                          1309  movea_l_src_long
00001A2A  1AFC 0024               1310      MOVE.B  #DOLLAR, (A5)+      ; read long size more opcode    
00001A2E  2C5A                    1311      MOVEA.L (A2)+, A6           ;   
00001A30  323C 0008               1312      MOVE.W  #long, D1           ;   
00001A34  48E7 0480               1313      MOVEM.L D5/A0, -(A7)        ;
00001A38  6100 F83A               1314      BSR hex_to_string           ;   
00001A3C  4CDF 0120               1315      MOVEM.L (A7)+, D5/A0        ; 
00001A40                          1316      
00001A40  6000 0020               1317      BRA movea_l_dest            ;   
00001A44                          1318      
00001A44                          1319  movea_l_src_imm      
00001A44  1AFC 0023               1320      MOVE.B  #SHARP, (A5)+       ; read long size more opcode    
00001A48  1AFC 0024               1321      MOVE.B  #DOLLAR, (A5)+      ; 
00001A4C  2C5A                    1322      MOVEA.L (A2)+, A6           ;   
00001A4E  323C 0008               1323      MOVE.W  #long, D1           ;   
00001A52  48E7 0480               1324      MOVEM.L D5/A0, -(A7)        ;
00001A56  6100 F81C               1325      BSR hex_to_string           ;   
00001A5A  4CDF 0120               1326      MOVEM.L (A7)+, D5/A0        ; 
00001A5E                          1327      
00001A5E  6000 0002               1328      BRA movea_l_dest            ;
00001A62                          1329  
00001A62                          1330  movea_l_dest
00001A62  1AFC 002C               1331      MOVE.B  #COMMA, (A5)+   ;   
00001A66  1AFC 0020               1332      MOVE.B  #SPACE, (A5)+   ;   
00001A6A                          1333      
00001A6A                          1334      * now do the samething for dest but don't need mode everything goes to An    
00001A6A                          1335  
00001A6A  3005                    1336      MOVE.W  D5, D0      ;   copy opcode into D0 
00001A6C  3C3C 0E00               1337      MOVE.W  #$0E00, D6  ;   bit mask in D6  
00001A70  1E3C 0009               1338      MOVE.B  #9, D7      ;   shift value after masking   
00001A74  6100 2354               1339      BSR get_bit         ;   D0 contains register of dest    
00001A78                          1340      
00001A78                          1341      * now D1 has dest mode, D0 has dest register number 
00001A78                          1342  
00001A78                          1343  dest_movea_l_Addr_reg        
00001A78  1AFC 0041               1344      MOVE.B  #A_, (A5)+  ;   
00001A7C  6100 237C               1345      BSR put_number  ;      
00001A80                          1346  
00001A80                          1347  movea_l_done    
00001A80  6000 FAB4               1348      BRA ori_done    ;   
00001A84                          1349  
00001A84                          1350  MOVE_L    
00001A84                          1351      * get source mode and register in D1 and D0 
00001A84  3005                    1352      MOVE.W  D5, D0      ;   copy opcode into D0 
00001A86  3C3C 0038               1353      MOVE.W  #$0038, D6  ;   bit mask in D6    
00001A8A  1E3C 0003               1354      MOVE.B  #3, D7      ;   shift value after masking   
00001A8E  6100 233A               1355      BSR get_bit         ;
00001A92  3200                    1356      MOVE.W  D0, D1      ;   D1 contains mode of source  
00001A94                          1357  
00001A94  3005                    1358      MOVE.W  D5, D0      ;   copy opcode into D0 
00001A96  3C3C 0007               1359      MOVE.W  #$0007, D6  ;   bit mask in D6  
00001A9A  1E3C 0000               1360      MOVE.B  #0, D7      ;   shift value after masking   
00001A9E  6100 232A               1361      BSR get_bit         ;   
00001AA2                          1362      
00001AA2                          1363      * now D1 has source mode, D0 has source register number 
00001AA2  0C41 0000               1364      CMPI.W  #$0000, D1              ; if mode == 0  
00001AA6  6700 0032               1365      BEQ move_l_Data_reg             ;   
00001AAA                          1366  
00001AAA  0C41 0001               1367      CMPI.W  #$0001, D1              ; if mode == 1    
00001AAE  6700 0036               1368      BEQ move_l_Addr_reg             ;   
00001AB2                          1369  
00001AB2  0C41 0002               1370      CMPI.W  #$0002, D1              ; if mode == 2  
00001AB6  6700 003A               1371      BEQ move_l_Addr_reg_paren       ;   
00001ABA                          1372  
00001ABA  0C41 0003               1373      CMPI.W  #$0003, D1              ; if mode == 3  
00001ABE  6700 0046               1374      BEQ move_l_Addr_reg_plus        ;   
00001AC2                          1375  
00001AC2  0C41 0004               1376      CMPI.W  #$0004, D1              ; if mode == 4  
00001AC6  6700 0056               1377      BEQ move_l_Addr_reg_minus       ;   
00001ACA                          1378  
00001ACA  0C41 0007               1379      CMPI.W  #$0007, D1              ; if mode == 7  
00001ACE  6700 0066               1380      BEQ move_l_ea_im                ;   
00001AD2                          1381      
00001AD2  4CDF 2000               1382      MOVEM.L (A7)+, A5               ; otherwise return invalid message  
00001AD6  6000 F6D6               1383      BRA invalid_code    
00001ADA                          1384  
00001ADA                          1385  move_l_Data_reg 
00001ADA  1AFC 0044               1386      MOVE.B  #D_, (A5)+              ; put Dn with number    
00001ADE  6100 231A               1387      BSR put_number                  ;   
00001AE2                          1388      
00001AE2  6000 00C4               1389      BRA move_l_dest                 ;   
00001AE6                          1390  
00001AE6                          1391  move_l_Addr_reg 
00001AE6  1AFC 0041               1392      MOVE.B  #A_, (A5)+              ; put An with number    
00001AEA  6100 230E               1393      BSR put_number                  ;   
00001AEE                          1394      
00001AEE  6000 00B8               1395      BRA move_l_dest                 ;
00001AF2                          1396  
00001AF2                          1397  move_l_Addr_reg_paren   
00001AF2  1AFC 0028               1398      MOVE.B  #Open_paren, (A5)+      ; put (An) with number   
00001AF6  1AFC 0041               1399      MOVE.B  #A_, (A5)+              ;   
00001AFA  6100 22FE               1400      BSR put_number                  ;   
00001AFE  1AFC 0029               1401      MOVE.B  #Close_paren, (A5)+     ;   
00001B02                          1402      
00001B02  6000 00A4               1403      BRA move_l_dest                 ;   
00001B06                          1404  
00001B06                          1405  move_l_addr_reg_plus                ;   
00001B06  1AFC 0028               1406      MOVE.B  #Open_paren, (A5)+      ; put (An)+ with number 
00001B0A  1AFC 0041               1407      MOVE.B  #A_, (A5)+              ;   
00001B0E  6100 22EA               1408      BSR put_number                  ;   
00001B12  1AFC 0029               1409      MOVE.B  #Close_paren, (A5)+     ;  
00001B16  1AFC 002B               1410      MOVE.B  #PLUS, (A5)+            ;   
00001B1A  6000 008C               1411      BRA move_l_dest                 ;
00001B1E                          1412  
00001B1E                          1413  move_l_addr_reg_minus   ;
00001B1E  1AFC 002D               1414      MOVE.B  #MINUS, (A5)+           ; put -(An) with number 
00001B22  1AFC 0028               1415      MOVE.B  #Open_paren, (A5)+      ;     
00001B26  1AFC 0041               1416      MOVE.B  #A_, (A5)+              ;   
00001B2A  6100 22CE               1417      BSR put_number                  ;   
00001B2E  1AFC 0029               1418      MOVE.B  #Close_paren, (A5)+     ;  
00001B32                          1419  
00001B32  6000 0074               1420      BRA move_l_dest                 ;
00001B36                          1421  
00001B36                          1422  move_l_ea_im    ;
00001B36  0C40 0000               1423      CMPI.W  #$0000, D0              ; if register == 0  
00001B3A  6700 001A               1424      BEQ move_l_src_word             ;   
00001B3E                          1425      
00001B3E  0C40 0001               1426      CMPI.W  #$0001, D0              ; if register == 1  
00001B42  6700 002C               1427      BEQ move_l_src_long             ;   
00001B46                          1428      
00001B46  0C40 0004               1429      CMPI.W  #$0004, D0              ; if register == 4  
00001B4A  6700 003E               1430      BEQ move_l_src_imm              ;   
00001B4E                          1431      
00001B4E  4CDF 2000               1432      MOVEM.L (A7)+, A5               ; otherwise return invalidemessage  
00001B52  6000 F65A               1433      BRA invalid_code                ;   
00001B56                          1434  
00001B56                          1435  move_l_src_word 
00001B56  1AFC 0024               1436      MOVE.B  #DOLLAR, (A5)+          ; read word size more opcode      
00001B5A  3C5A                    1437      MOVEA.W (A2)+, A6               ;   
00001B5C  323C 0004               1438      MOVE.W  #word, D1               ;   
00001B60  48E7 0480               1439      MOVEM.L D5/A0, -(A7)            ;
00001B64  6100 F70E               1440      BSR hex_to_string               ;   
00001B68  4CDF 0120               1441      MOVEM.L (A7)+, D5/A0            ;
00001B6C                          1442      
00001B6C  6000 003A               1443      BRA move_l_dest 
00001B70                          1444  move_l_src_long
00001B70  1AFC 0024               1445      MOVE.B  #DOLLAR, (A5)+          ; read long size more opcode    
00001B74  2C5A                    1446      MOVEA.L (A2)+, A6               ;   
00001B76  323C 0008               1447      MOVE.W  #long, D1               ;   
00001B7A  48E7 0480               1448      MOVEM.L D5/A0, -(A7)            ;  
00001B7E  6100 F6F4               1449      BSR hex_to_string               ;   
00001B82  4CDF 0120               1450      MOVEM.L (A7)+, D5/A0            ;
00001B86                          1451      
00001B86  6000 0020               1452      BRA move_l_dest                 ;   
00001B8A                          1453      
00001B8A                          1454  move_l_src_imm      
00001B8A  1AFC 0023               1455      MOVE.B  #SHARP, (A5)+           ; read long size more opcode       
00001B8E  1AFC 0024               1456      MOVE.B  #DOLLAR, (A5)+          ; 
00001B92  2C5A                    1457      MOVEA.L (A2)+, A6               ;   
00001B94  323C 0008               1458      MOVE.W  #long, D1               ;   
00001B98  48E7 0480               1459      MOVEM.L D5/A0, -(A7)            ;
00001B9C  6100 F6D6               1460      BSR hex_to_string               ;   
00001BA0  4CDF 0120               1461      MOVEM.L (A7)+, D5/A0            ;
00001BA4                          1462      
00001BA4  6000 0002               1463      BRA move_l_dest                 ;
00001BA8                          1464  
00001BA8                          1465  move_l_dest
00001BA8  1AFC 002C               1466      MOVE.B  #COMMA, (A5)+   ;   
00001BAC  1AFC 0020               1467      MOVE.B  #SPACE, (A5)+   ;   
00001BB0                          1468      
00001BB0                          1469      * now do the samething for dest 
00001BB0                          1470      * get dest mode and register in D1 and D0 
00001BB0  3005                    1471      MOVE.W  D5, D0      ;   copy opcode into D0 
00001BB2  3C3C 01C0               1472      MOVE.W  #$01C0, D6  ;   bit mask in D6    
00001BB6  1E3C 0006               1473      MOVE.B  #6, D7      ;   shift value after masking   
00001BBA  6100 220E               1474      BSR get_bit         ;
00001BBE  3200                    1475      MOVE.W  D0, D1      ;   D1 contains mode of dest mode    
00001BC0                          1476  
00001BC0  3005                    1477      MOVE.W  D5, D0      ;   copy opcode into D0 
00001BC2  3C3C 0E00               1478      MOVE.W  #$0E00, D6  ;   bit mask in D6  
00001BC6  1E3C 0009               1479      MOVE.B  #9, D7      ;   shift value after masking   
00001BCA  6100 21FE               1480      BSR get_bit         ;   D0 contains register of dest    
00001BCE                          1481      
00001BCE                          1482      * now D1 has dest mode, D0 has dest register number 
00001BCE  0C41 0000               1483      CMPI.W  #$0000, D1                  ; if mode == 0     
00001BD2  6700 002A               1484      BEQ dest_move_l_Data_reg            ;    
00001BD6                          1485  
00001BD6  0C41 0002               1486      CMPI.W  #$0002, D1                  ; if mode == 2  
00001BDA  6700 002E               1487      BEQ dest_move_l_Addr_reg_paren      ;   
00001BDE                          1488  
00001BDE  0C41 0003               1489      CMPI.W  #$0003, D1                  ; if mode == 3  
00001BE2  6700 003A               1490      BEQ dest_move_l_Addr_reg_plus       ;   
00001BE6                          1491  
00001BE6  0C41 0004               1492      CMPI.W  #$0004, D1                  ; if mode == 4  
00001BEA  6700 004A               1493      BEQ dest_move_l_Addr_reg_minus      ;   
00001BEE                          1494  
00001BEE  0C41 0007               1495      CMPI.W  #$0007, D1                  ; if mode == 7  
00001BF2  6700 005A               1496      BEQ dest_move_l_ea                  ;   
00001BF6                          1497      
00001BF6  4CDF 2000               1498      MOVEM.L (A7)+, A5                   ; otherwise return invalid message     
00001BFA  6000 F5B2               1499      BRA invalid_code    
00001BFE                          1500  
00001BFE                          1501  dest_move_l_Data_reg 
00001BFE  1AFC 0044               1502      MOVE.B  #D_, (A5)+          ; put Dn with number    
00001C02  6100 21F6               1503      BSR put_number              ;   
00001C06                          1504      
00001C06  6000 0092               1505      BRA move_l_done             ;     
00001C0A                          1506  
00001C0A                          1507  dest_move_l_Addr_reg_paren   
00001C0A  1AFC 0028               1508      MOVE.B  #Open_paren, (A5)+  ; put (An) with number       
00001C0E  1AFC 0041               1509      MOVE.B  #A_, (A5)+          ;   
00001C12  6100 21E6               1510      BSR put_number              ;   
00001C16  1AFC 0029               1511      MOVE.B  #Close_paren, (A5)+ ;   
00001C1A                          1512      
00001C1A  6000 007E               1513      BRA move_l_done             ;   
00001C1E                          1514  
00001C1E                          1515  dest_move_l_addr_reg_plus       ;   
00001C1E  1AFC 0028               1516      MOVE.B  #Open_paren, (A5)+  ; put (An)+ with number      
00001C22  1AFC 0041               1517      MOVE.B  #A_, (A5)+          ;   
00001C26  6100 21D2               1518      BSR put_number              ;   
00001C2A  1AFC 0029               1519      MOVE.B  #Close_paren, (A5)+ ;  
00001C2E  1AFC 002B               1520      MOVE.B  #PLUS, (A5)+        ;   
00001C32  6000 0066               1521      BRA move_l_done             ;
00001C36                          1522  
00001C36                          1523  dest_move_l_addr_reg_minus      ;
00001C36  1AFC 002D               1524      MOVE.B  #MINUS, (A5)+       ; put -(An) with number 
00001C3A  1AFC 0028               1525      MOVE.B  #Open_paren, (A5)+  ;     
00001C3E  1AFC 0041               1526      MOVE.B  #A_, (A5)+          ;   
00001C42  6100 21B6               1527      BSR put_number              ;   
00001C46  1AFC 0029               1528      MOVE.B  #Close_paren, (A5)+ ;  
00001C4A                          1529  
00001C4A  6000 004E               1530      BRA move_l_done             ;
00001C4E                          1531  
00001C4E                          1532  dest_move_l_ea                  ;
00001C4E  0C40 0000               1533      CMPI.W  #$0000, D0          ; if register == 0  
00001C52  6700 0012               1534      BEQ dest_move_l_src_word    ;   
00001C56                          1535      
00001C56  0C40 0001               1536      CMPI.W  #$0001, D0          ; if register == 1  
00001C5A  6700 0024               1537      BEQ dest_move_l_src_long    ;   
00001C5E                          1538      
00001C5E  4CDF 2000               1539      MOVEM.L (A7)+, A5           ;   
00001C62  6000 F54A               1540      BRA invalid_code            ;   
00001C66                          1541  
00001C66                          1542  dest_move_l_src_word 
00001C66  1AFC 0024               1543      MOVE.B  #DOLLAR, (A5)+      ;   
00001C6A  3C5A                    1544      MOVEA.W (A2)+, A6           ; read word size opcode more       
00001C6C  323C 0004               1545      MOVE.W  #word, D1           ;   
00001C70  48E7 0480               1546      MOVEM.L D5/A0, -(A7)        ;
00001C74  6100 F5FE               1547      BSR hex_to_string           ;   
00001C78  4CDF 0120               1548      MOVEM.L (A7)+, D5/A0        ;
00001C7C                          1549      
00001C7C  6000 001C               1550      BRA move_l_done 
00001C80                          1551  dest_move_l_src_long
00001C80  1AFC 0024               1552      MOVE.B  #DOLLAR, (A5)+      ; read long size opcode more    
00001C84  2C5A                    1553      MOVEA.L (A2)+, A6           ;   
00001C86  323C 0008               1554      MOVE.W  #long, D1           ;   
00001C8A  48E7 0480               1555      MOVEM.L D5/A0, -(A7)        ; 
00001C8E  6100 F5E4               1556      BSR hex_to_string           ;   
00001C92  4CDF 0120               1557      MOVEM.L (A7)+, D5/A0        ;
00001C96                          1558      
00001C96  6000 0002               1559      BRA move_l_done             ;   
00001C9A                          1560      
00001C9A                          1561  move_l_done 
00001C9A                          1562      
00001C9A  6000 F89A               1563      BRA ori_done    ;    
00001C9E                          1564  
00001C9E                          1565  * three_start ***************************************************************************   
00001C9E                          1566  MOVE_MOVEA_W    
00001C9E                          1567  * check dest mode part and distinguish whether MOVE.L or MOVEA.L    
00001C9E  48E7 0004               1568      MOVEM.L A5, -(A7)   ;   save A5 in the stack (pointer to result message)  
00001CA2  204E                    1569      MOVEA.L A6, A0      ;   starting address of temp      
00001CA4  2A4E                    1570      MOVEA.L A6, A5      ;   move starting address of curent temp Message into A0
00001CA6                          1571      
00001CA6  1AFC 004D               1572      MOVE.B  #M_, (A5)+   ;   
00001CAA  1AFC 004F               1573      MOVE.B  #O_, (A5)+   ;   
00001CAE  1AFC 0056               1574      MOVE.B  #V_, (A5)+  ;       
00001CB2  1AFC 0045               1575      MOVE.B  #E_, (A5)+   ; 
00001CB6                          1576      
00001CB6                          1577      * get source mode and register in D1 and D0 
00001CB6  3005                    1578      MOVE.W  D5, D0      ;   copy opcode into D0 
00001CB8  3C3C 01C0               1579      MOVE.W  #$01C0, D6  ;   bit mask in D6    
00001CBC  1E3C 0006               1580      MOVE.B  #6, D7      ;   shift value after masking   
00001CC0  6100 2108               1581      BSR get_bit         ;   D0 contains 6, 7, 8th bits  
00001CC4                          1582      
00001CC4  0C40 0001               1583      CMPI.W  #$0001, D0          ;   
00001CC8  6700 0012               1584      BEQ MOVEA_W 
00001CCC                          1585      
00001CCC                          1586      * other wise, it is move L  ;   
00001CCC  1AFC 002E               1587      MOVE.B  #PERIOD, (A5)+      ;   
00001CD0  1AFC 0057               1588      MOVE.B  #W_, (A5)+          ;   
00001CD4  1AFC 0009               1589      MOVE.B  #TAB, (A5)+         ;   
00001CD8                          1590      
00001CD8  6000 0158               1591      BRA MOVE_W                  ;   
00001CDC                          1592  
00001CDC                          1593      
00001CDC                          1594  MOVEA_W 
00001CDC  1AFC 0041               1595      MOVE.B  #A_, (A5)+      ;   
00001CE0  1AFC 002E               1596      MOVE.B  #PERIOD, (A5)+  ;   
00001CE4  1AFC 0057               1597      MOVE.B  #W_, (A5)+      ;   
00001CE8  1AFC 0009               1598      MOVE.B  #TAB, (A5)+     ;   
00001CEC                          1599      * get source mode and register in D1 and D0 
00001CEC  3005                    1600      MOVE.W  D5, D0      ;   copy opcode into D0 
00001CEE  3C3C 0038               1601      MOVE.W  #$0038, D6  ;   bit mask in D6    
00001CF2  1E3C 0003               1602      MOVE.B  #3, D7      ;   shift value after masking   
00001CF6  6100 20D2               1603      BSR get_bit         ;
00001CFA  3200                    1604      MOVE.W  D0, D1      ;   D1 contains mode of source  
00001CFC                          1605  
00001CFC  3005                    1606      MOVE.W  D5, D0      ;   copy opcode into D0 
00001CFE  3C3C 0007               1607      MOVE.W  #$0007, D6  ;   bit mask in D6  
00001D02  1E3C 0000               1608      MOVE.B  #0, D7      ;   shift value after masking   
00001D06  6100 20C2               1609      BSR get_bit         ;   
00001D0A                          1610      
00001D0A                          1611      * now D1 has source mode, D0 has source register number 
00001D0A  0C41 0000               1612      CMPI.W  #$0000, D1          ; if mode == 0  
00001D0E  6700 0032               1613      BEQ movea_w_Data_reg        ;   
00001D12                          1614  
00001D12  0C41 0001               1615      CMPI.W  #$0001, D1          ; if mode == 1  
00001D16  6700 0036               1616      BEQ movea_w_Addr_reg        ;   
00001D1A                          1617  
00001D1A  0C41 0002               1618      CMPI.W  #$0002, D1          ; if mode == 2  
00001D1E  6700 003A               1619      BEQ movea_w_Addr_reg_paren  ;   
00001D22                          1620  
00001D22  0C41 0003               1621      CMPI.W  #$0003, D1          ; if mode == 3  
00001D26  6700 0046               1622      BEQ movea_w_Addr_reg_plus   ;   
00001D2A                          1623  
00001D2A  0C41 0004               1624      CMPI.W  #$0004, D1          ; if mode == 4  
00001D2E  6700 0056               1625      BEQ movea_w_Addr_reg_minus  ;   
00001D32                          1626  
00001D32  0C41 0007               1627      CMPI.W  #$0007, D1          ; if mode == 7  
00001D36  6700 0066               1628      BEQ movea_w_ea_im           ;   
00001D3A                          1629      
00001D3A  4CDF 2000               1630      MOVEM.L (A7)+, A5           ; otherwise return invalid message  
00001D3E  6000 F46E               1631      BRA invalid_code    
00001D42                          1632  
00001D42                          1633  movea_w_Data_reg 
00001D42  1AFC 0044               1634      MOVE.B  #D_, (A5)+          ; put Dn with number    
00001D46  6100 20B2               1635      BSR put_number              ;   
00001D4A                          1636      
00001D4A  6000 00C4               1637      BRA movea_w_dest            ;   
00001D4E                          1638  
00001D4E                          1639  movea_w_Addr_reg 
00001D4E  1AFC 0041               1640      MOVE.B  #A_, (A5)+          ; put An with number    
00001D52  6100 20A6               1641      BSR put_number              ;   
00001D56                          1642      
00001D56  6000 00B8               1643      BRA movea_w_dest            ;
00001D5A                          1644  
00001D5A                          1645  movea_w_Addr_reg_paren   
00001D5A  1AFC 0028               1646      MOVE.B  #Open_paren, (A5)+  ; put (An) with number  
00001D5E  1AFC 0041               1647      MOVE.B  #A_, (A5)+          ;   
00001D62  6100 2096               1648      BSR put_number              ;   
00001D66  1AFC 0029               1649      MOVE.B  #Close_paren, (A5)+ ;   
00001D6A                          1650      
00001D6A  6000 00A4               1651      BRA movea_w_dest            ;   
00001D6E                          1652  
00001D6E                          1653  movea_w_addr_reg_plus           ;   
00001D6E  1AFC 0028               1654      MOVE.B  #Open_paren, (A5)+  ; put (An)+ with number      
00001D72  1AFC 0041               1655      MOVE.B  #A_, (A5)+          ;   
00001D76  6100 2082               1656      BSR put_number              ;   
00001D7A  1AFC 0029               1657      MOVE.B  #Close_paren, (A5)+ ;  
00001D7E  1AFC 002B               1658      MOVE.B  #PLUS, (A5)+        ;   
00001D82  6000 008C               1659      BRA movea_w_dest            ;
00001D86                          1660  
00001D86                          1661  movea_w_addr_reg_minus          ;
00001D86  1AFC 002D               1662      MOVE.B  #MINUS, (A5)+       ; put -(An) with number 
00001D8A  1AFC 0028               1663      MOVE.B  #Open_paren, (A5)+  ;     
00001D8E  1AFC 0041               1664      MOVE.B  #A_, (A5)+          ;   
00001D92  6100 2066               1665      BSR put_number              ;   
00001D96  1AFC 0029               1666      MOVE.B  #Close_paren, (A5)+ ;  
00001D9A                          1667  
00001D9A  6000 0074               1668      BRA movea_w_dest            ;
00001D9E                          1669  
00001D9E                          1670  movea_w_ea_im                   ;
00001D9E  0C40 0000               1671      CMPI.W  #$0000, D0          ;   if register == 0    
00001DA2  6700 001A               1672      BEQ movea_w_src_word        ;   
00001DA6                          1673      
00001DA6  0C40 0001               1674      CMPI.W  #$0001, D0          ;   if register == 1    
00001DAA  6700 002C               1675      BEQ movea_w_src_long        ;   
00001DAE                          1676      
00001DAE  0C40 0004               1677      CMPI.W  #$0004, D0          ;   if register == 4    
00001DB2  6700 003E               1678      BEQ movea_w_src_imm         ;   
00001DB6                          1679      
00001DB6  4CDF 2000               1680      MOVEM.L (A7)+, A5           ;   
00001DBA  6000 F3F2               1681      BRA invalid_code            ; return invalid message    
00001DBE                          1682  
00001DBE                          1683  movea_w_src_word 
00001DBE  1AFC 0024               1684      MOVE.B  #DOLLAR, (A5)+      ;   
00001DC2  3C5A                    1685      MOVEA.W (A2)+, A6           ; read more opcode wordsize    
00001DC4  323C 0004               1686      MOVE.W  #word, D1           ;   
00001DC8  48E7 0480               1687      MOVEM.L D5/A0, -(A7)        ;        
00001DCC  6100 F4A6               1688      BSR hex_to_string           ;   
00001DD0  4CDF 0120               1689      MOVEM.L (A7)+, D5/A0        ;  
00001DD4                          1690      
00001DD4  6000 003A               1691      BRA movea_w_dest            ; 
00001DD8                          1692  movea_w_src_long
00001DD8  1AFC 0024               1693      MOVE.B  #DOLLAR, (A5)+      ;   
00001DDC  2C5A                    1694      MOVEA.L (A2)+, A6           ; read more opcode longsize 
00001DDE  323C 0008               1695      MOVE.W  #long, D1           ;   
00001DE2  48E7 0480               1696      MOVEM.L D5/A0, -(A7)        ; 
00001DE6  6100 F48C               1697      BSR hex_to_string           ;   
00001DEA  4CDF 0120               1698      MOVEM.L (A7)+, D5/A0        ; 
00001DEE                          1699      
00001DEE  6000 0020               1700      BRA movea_w_dest            ;   
00001DF2                          1701      
00001DF2                          1702  movea_w_src_imm      
00001DF2  1AFC 0023               1703      MOVE.B  #SHARP, (A5)+       ;   
00001DF6  1AFC 0024               1704      MOVE.B  #DOLLAR, (A5)+      ; 
00001DFA  3C5A                    1705      MOVEA.W (A2)+, A6           ; read more opcode wordsize 
00001DFC  323C 0004               1706      MOVE.W  #word, D1           ;   
00001E00  48E7 0480               1707      MOVEM.L D5/A0, -(A7)        ;
00001E04  6100 F46E               1708      BSR hex_to_string           ;   
00001E08  4CDF 0120               1709      MOVEM.L (A7)+, D5/A0        ; 
00001E0C                          1710      
00001E0C  6000 0002               1711      BRA movea_w_dest            ;
00001E10                          1712  
00001E10                          1713  movea_w_dest
00001E10  1AFC 002C               1714      MOVE.B  #COMMA, (A5)+   ;   
00001E14  1AFC 0020               1715      MOVE.B  #SPACE, (A5)+   ;   
00001E18                          1716      
00001E18                          1717      * now do the samething for dest but don't need mode everything goes to An    
00001E18                          1718  
00001E18  3005                    1719      MOVE.W  D5, D0      ;   copy opcode into D0 
00001E1A  3C3C 0E00               1720      MOVE.W  #$0E00, D6  ;   bit mask in D6  
00001E1E  1E3C 0009               1721      MOVE.B  #9, D7      ;   shift value after masking   
00001E22  6100 1FA6               1722      BSR get_bit         ;   D0 contains register of dest    
00001E26                          1723      
00001E26                          1724      * now D1 has dest mode, D0 has dest register number 
00001E26                          1725  
00001E26                          1726  dest_movea_w_Addr_reg        
00001E26  1AFC 0041               1727      MOVE.B  #A_, (A5)+      ;   
00001E2A  6100 1FCE               1728      BSR put_number          ;      
00001E2E                          1729  
00001E2E                          1730  movea_w_done    
00001E2E  6000 F706               1731      BRA ori_done    ;   
00001E32                          1732  
00001E32                          1733  MOVE_W    
00001E32                          1734      * get source mode and register in D1 and D0 
00001E32  3005                    1735      MOVE.W  D5, D0      ;   copy opcode into D0 
00001E34  3C3C 0038               1736      MOVE.W  #$0038, D6  ;   bit mask in D6    
00001E38  1E3C 0003               1737      MOVE.B  #3, D7      ;   shift value after masking   
00001E3C  6100 1F8C               1738      BSR get_bit         ;
00001E40  3200                    1739      MOVE.W  D0, D1      ;   D1 contains mode of source  
00001E42                          1740  
00001E42  3005                    1741      MOVE.W  D5, D0      ;   copy opcode into D0 
00001E44  3C3C 0007               1742      MOVE.W  #$0007, D6  ;   bit mask in D6  
00001E48  1E3C 0000               1743      MOVE.B  #0, D7      ;   shift value after masking   
00001E4C  6100 1F7C               1744      BSR get_bit         ;   
00001E50                          1745      
00001E50                          1746      * now D1 has source mode, D0 has source register number 
00001E50  0C41 0000               1747      CMPI.W  #$0000, D1          ; if mode == 0  
00001E54  6700 0032               1748      BEQ move_w_Data_reg         ;   
00001E58                          1749  
00001E58  0C41 0001               1750      CMPI.W  #$0001, D1          ; if mode == 1  
00001E5C  6700 0036               1751      BEQ move_w_Addr_reg         ;   
00001E60                          1752  
00001E60  0C41 0002               1753      CMPI.W  #$0002, D1          ; if mode == 2     
00001E64  6700 003A               1754      BEQ move_w_Addr_reg_paren   ;   
00001E68                          1755  
00001E68  0C41 0003               1756      CMPI.W  #$0003, D1          ; if mode == 3  
00001E6C  6700 0046               1757      BEQ move_w_Addr_reg_plus    ;   
00001E70                          1758  
00001E70  0C41 0004               1759      CMPI.W  #$0004, D1          ; if mode == 4  
00001E74  6700 0056               1760      BEQ move_w_Addr_reg_minus   ;   
00001E78                          1761  
00001E78  0C41 0007               1762      CMPI.W  #$0007, D1          ; if mode == 7  
00001E7C  6700 0066               1763      BEQ move_w_ea_im            ;   
00001E80                          1764      
00001E80  4CDF 2000               1765      MOVEM.L (A7)+, A5           ; otherwise return invalid opcode   
00001E84  6000 F328               1766      BRA invalid_code    
00001E88                          1767  
00001E88                          1768  move_w_Data_reg 
00001E88  1AFC 0044               1769      MOVE.B  #D_, (A5)+          ; put Dn with number    
00001E8C  6100 1F6C               1770      BSR put_number              ;   
00001E90                          1771      
00001E90  6000 00C4               1772      BRA move_w_dest             ;   
00001E94                          1773  
00001E94                          1774  move_w_Addr_reg 
00001E94  1AFC 0041               1775      MOVE.B  #A_, (A5)+          ; put An with number    
00001E98  6100 1F60               1776      BSR put_number              ;   
00001E9C                          1777      
00001E9C  6000 00B8               1778      BRA move_w_dest             ;
00001EA0                          1779  
00001EA0                          1780  move_w_Addr_reg_paren   
00001EA0  1AFC 0028               1781      MOVE.B  #Open_paren, (A5)+  ; put (An) with number  
00001EA4  1AFC 0041               1782      MOVE.B  #A_, (A5)+          ;   
00001EA8  6100 1F50               1783      BSR put_number              ;   
00001EAC  1AFC 0029               1784      MOVE.B  #Close_paren, (A5)+ ;   
00001EB0                          1785      
00001EB0  6000 00A4               1786      BRA move_w_dest             ;   
00001EB4                          1787  
00001EB4                          1788  move_w_addr_reg_plus            ; put (An)+ with number   
00001EB4  1AFC 0028               1789      MOVE.B  #Open_paren, (A5)+  ;     
00001EB8  1AFC 0041               1790      MOVE.B  #A_, (A5)+          ;   
00001EBC  6100 1F3C               1791      BSR put_number              ;   
00001EC0  1AFC 0029               1792      MOVE.B  #Close_paren, (A5)+ ;  
00001EC4  1AFC 002B               1793      MOVE.B  #PLUS, (A5)+        ;   
00001EC8  6000 008C               1794      BRA move_w_dest             ;
00001ECC                          1795  
00001ECC                          1796  move_w_addr_reg_minus           ;
00001ECC  1AFC 002D               1797      MOVE.B  #MINUS, (A5)+       ; put -(An) with number    
00001ED0  1AFC 0028               1798      MOVE.B  #Open_paren, (A5)+  ;     
00001ED4  1AFC 0041               1799      MOVE.B  #A_, (A5)+          ;   
00001ED8  6100 1F20               1800      BSR put_number              ;   
00001EDC  1AFC 0029               1801      MOVE.B  #Close_paren, (A5)+ ;  
00001EE0                          1802  
00001EE0  6000 0074               1803      BRA move_w_dest             ;
00001EE4                          1804  
00001EE4                          1805  move_w_ea_im                    ;
00001EE4  0C40 0000               1806      CMPI.W  #$0000, D0          ; check if register == 0     
00001EE8  6700 001A               1807      BEQ move_w_src_word         ;   
00001EEC                          1808      
00001EEC  0C40 0001               1809      CMPI.W  #$0001, D0          ; check if register == 1    
00001EF0  6700 002C               1810      BEQ move_w_src_long         ;   
00001EF4                          1811      
00001EF4  0C40 0004               1812      CMPI.W  #$0004, D0          ; check if register == 4       
00001EF8  6700 003E               1813      BEQ move_w_src_imm          ;   
00001EFC                          1814      
00001EFC  4CDF 2000               1815      MOVEM.L (A7)+, A5           ; otherwise return invalid message  
00001F00  6000 F2AC               1816      BRA invalid_code            ;   
00001F04                          1817  
00001F04                          1818  move_w_src_word 
00001F04  1AFC 0024               1819      MOVE.B  #DOLLAR, (A5)+      ;   
00001F08  3C5A                    1820      MOVEA.W (A2)+, A6           ;   
00001F0A  323C 0004               1821      MOVE.W  #word, D1           ; read more opcode wordsize 
00001F0E  48E7 0480               1822      MOVEM.L D5/A0, -(A7)        ; 
00001F12  6100 F360               1823      BSR hex_to_string           ;   
00001F16  4CDF 0120               1824      MOVEM.L (A7)+, D5/A0        ;
00001F1A                          1825      
00001F1A  6000 003A               1826      BRA move_w_dest 
00001F1E                          1827  move_w_src_long
00001F1E  1AFC 0024               1828      MOVE.B  #DOLLAR, (A5)+      ;   
00001F22  2C5A                    1829      MOVEA.L (A2)+, A6           ; read more opcode longsize   
00001F24  323C 0008               1830      MOVE.W  #long, D1           ;   
00001F28  48E7 0480               1831      MOVEM.L D5/A0, -(A7)        ;
00001F2C  6100 F346               1832      BSR hex_to_string           ;   
00001F30  4CDF 0120               1833      MOVEM.L (A7)+, D5/A0        ;
00001F34                          1834      
00001F34  6000 0020               1835      BRA move_w_dest             ;   
00001F38                          1836      
00001F38                          1837  move_w_src_imm      
00001F38  1AFC 0023               1838      MOVE.B  #SHARP, (A5)+       ;   
00001F3C  1AFC 0024               1839      MOVE.B  #DOLLAR, (A5)+      ; 
00001F40  3C5A                    1840      MOVEA.W (A2)+, A6           ; read more opcode word size       
00001F42  323C 0004               1841      MOVE.W  #word, D1           ;   
00001F46  48E7 0480               1842      MOVEM.L D5/A0, -(A7)        ;  
00001F4A  6100 F328               1843      BSR hex_to_string           ;   
00001F4E  4CDF 0120               1844      MOVEM.L (A7)+, D5/A0        ;
00001F52                          1845      
00001F52  6000 0002               1846      BRA move_w_dest             ;
00001F56                          1847  
00001F56                          1848  move_w_dest
00001F56  1AFC 002C               1849      MOVE.B  #COMMA, (A5)+   ;   
00001F5A  1AFC 0020               1850      MOVE.B  #SPACE, (A5)+   ;   
00001F5E                          1851      
00001F5E                          1852      * now do the samething for dest 
00001F5E                          1853      * get dest mode and register in D1 and D0 
00001F5E  3005                    1854      MOVE.W  D5, D0      ;   copy opcode into D0 
00001F60  3C3C 01C0               1855      MOVE.W  #$01C0, D6  ;   bit mask in D6    
00001F64  1E3C 0006               1856      MOVE.B  #6, D7      ;   shift value after masking   
00001F68  6100 1E60               1857      BSR get_bit         ;
00001F6C  3200                    1858      MOVE.W  D0, D1      ;   D1 contains mode of dest mode    
00001F6E                          1859  
00001F6E  3005                    1860      MOVE.W  D5, D0      ;   copy opcode into D0 
00001F70  3C3C 0E00               1861      MOVE.W  #$0E00, D6  ;   bit mask in D6  
00001F74  1E3C 0009               1862      MOVE.B  #9, D7      ;   shift value after masking   
00001F78  6100 1E50               1863      BSR get_bit         ;   D0 contains register of dest    
00001F7C                          1864      
00001F7C                          1865      * now D1 has dest mode, D0 has dest register number 
00001F7C  0C41 0000               1866      CMPI.W  #$0000, D1          ;   if mode == 0    
00001F80  6700 002A               1867      BEQ dest_move_w_Data_reg ;    
00001F84                          1868  
00001F84  0C41 0002               1869      CMPI.W  #$0002, D1          ;   if mode == 2    
00001F88  6700 002E               1870      BEQ dest_move_w_Addr_reg_paren ;   
00001F8C                          1871  
00001F8C  0C41 0003               1872      CMPI.W  #$0003, D1          ;   if mode == 3    
00001F90  6700 003A               1873      BEQ dest_move_w_Addr_reg_plus    ;   
00001F94                          1874  
00001F94  0C41 0004               1875      CMPI.W  #$0004, D1          ;   if mode == 4    
00001F98  6700 004A               1876      BEQ dest_move_w_Addr_reg_minus   ;   
00001F9C                          1877  
00001F9C  0C41 0007               1878      CMPI.W  #$0007, D1          ;   if mode == 7    
00001FA0  6700 005A               1879      BEQ dest_move_w_ea          ;   
00001FA4                          1880      
00001FA4  4CDF 2000               1881      MOVEM.L (A7)+, A5           ;   
00001FA8  6000 F204               1882      BRA invalid_code            ; 
00001FAC                          1883  
00001FAC                          1884  dest_move_w_Data_reg 
00001FAC  1AFC 0044               1885      MOVE.B  #D_, (A5)+          ; put Dn with number 
00001FB0  6100 1E48               1886      BSR put_number              ;   
00001FB4                          1887      
00001FB4  6000 0092               1888      BRA move_w_done             ;     
00001FB8                          1889  
00001FB8                          1890  dest_move_w_Addr_reg_paren   
00001FB8  1AFC 0028               1891      MOVE.B  #Open_paren, (A5)+  ; put (An) with number   
00001FBC  1AFC 0041               1892      MOVE.B  #A_, (A5)+          ;   
00001FC0  6100 1E38               1893      BSR put_number              ;   
00001FC4  1AFC 0029               1894      MOVE.B  #Close_paren, (A5)+ ;   
00001FC8                          1895      
00001FC8  6000 007E               1896      BRA move_w_done             ;   
00001FCC                          1897  
00001FCC                          1898  dest_move_w_addr_reg_plus       ;   
00001FCC  1AFC 0028               1899      MOVE.B  #Open_paren, (A5)+  ; put (An)+ with number      
00001FD0  1AFC 0041               1900      MOVE.B  #A_, (A5)+          ;   
00001FD4  6100 1E24               1901      BSR put_number              ;   
00001FD8  1AFC 0029               1902      MOVE.B  #Close_paren, (A5)+ ;  
00001FDC  1AFC 002B               1903      MOVE.B  #PLUS, (A5)+        ;   
00001FE0  6000 0066               1904      BRA move_w_done             ;
00001FE4                          1905  
00001FE4                          1906  dest_move_w_addr_reg_minus      ;
00001FE4  1AFC 002D               1907      MOVE.B  #MINUS, (A5)+       ; put -(An) with number    
00001FE8  1AFC 0028               1908      MOVE.B  #Open_paren, (A5)+  ;     
00001FEC  1AFC 0041               1909      MOVE.B  #A_, (A5)+          ;   
00001FF0  6100 1E08               1910      BSR put_number              ;   
00001FF4  1AFC 0029               1911      MOVE.B  #Close_paren, (A5)+ ;  
00001FF8                          1912  
00001FF8  6000 004E               1913      BRA move_w_done             ;
00001FFC                          1914  
00001FFC                          1915  dest_move_w_ea                  
00001FFC  0C40 0000               1916      CMPI.W  #$0000, D0          ; check if register == 0    
00002000  6700 0012               1917      BEQ dest_move_w_src_word    ;   
00002004                          1918      
00002004  0C40 0001               1919      CMPI.W  #$0001, D0          ; check if register == 1    
00002008  6700 0024               1920      BEQ dest_move_w_src_long    ;   
0000200C                          1921      
0000200C  4CDF 2000               1922      MOVEM.L (A7)+, A5           ;   
00002010  6000 F19C               1923      BRA invalid_code            ; otherwise print invalid mode     
00002014                          1924  
00002014                          1925  dest_move_w_src_word 
00002014  1AFC 0024               1926      MOVE.B  #DOLLAR, (A5)+      ; 
00002018  3C5A                    1927      MOVEA.W (A2)+, A6           ; read word size opcode more      
0000201A  323C 0004               1928      MOVE.W  #word, D1           ;   
0000201E  48E7 0480               1929      MOVEM.L D5/A0, -(A7)        ;  
00002022  6100 F250               1930      BSR hex_to_string           ; put address in the temp message     
00002026  4CDF 0120               1931      MOVEM.L (A7)+, D5/A0        ;
0000202A                          1932      
0000202A  6000 001C               1933      BRA move_w_done             ;
0000202E                          1934  dest_move_w_src_long
0000202E  1AFC 0024               1935      MOVE.B  #DOLLAR, (A5)+      ;   
00002032  2C5A                    1936      MOVEA.L (A2)+, A6           ; read long size opcode more       
00002034  323C 0008               1937      MOVE.W  #long, D1           ;   
00002038  48E7 0480               1938      MOVEM.L D5/A0, -(A7)        ;  
0000203C  6100 F236               1939      BSR hex_to_string           ; put address in the temp message   
00002040  4CDF 0120               1940      MOVEM.L (A7)+, D5/A0        ;
00002044                          1941      
00002044  6000 0002               1942      BRA move_w_done             ;   
00002048                          1943      
00002048                          1944  move_w_done 
00002048                          1945      
00002048  6000 F4EC               1946      BRA ori_done    ;    
0000204C                          1947      
0000204C                          1948  *********four_start *********************
0000204C                          1949  NEG_function      
0000204C  48E7 0004               1950      MOVEM.L A5, -(A7)   ;   save A5 in the stack (pointer to result message)  
00002050  204E                    1951      MOVEA.L A6, A0      ;   starting address of temp      
00002052  2A4E                    1952      MOVEA.L A6, A5      ;   move starting address of curent temp Message into A0
00002054                          1953      
00002054                          1954  *Move NEG. into the temporary result*********
00002054  1AFC 004E               1955      MOVE.B  #N_, (A5)+
00002058  1AFC 0045               1956      MOVE.B  #E_, (A5)+
0000205C  1AFC 0047               1957      MOVE.B  #G_, (A5)+
00002060  1AFC 002E               1958      MOVE.B  #PERIOD, (A5)+
00002064                          1959      
00002064  3005                    1960      MOVE.W  D5, D0      ;   move the opcode into d0
00002066  3C3C 00C0               1961      MOVE.W  #$00C0, D6  ;   move the bitmask into d6
0000206A  1E3C 0006               1962      MOVE.B  #6, D7      ;   intended shift after masking into d7
0000206E  6100 1D5A               1963      BSR get_bit         ;   get the size returned in d0
00002072                          1964      
00002072  0C00 0000               1965      CMPI.B  #$00, D0
00002076  6700 0012               1966          BEQ is_byte
0000207A  0C00 0001               1967      CMPI.B  #$01, D0
0000207E  6700 0016               1968          BEQ is_word
00002082  0C00 0002               1969      CMPI.B  #$02, D0
00002086  6700 001A               1970          BEQ is_long
0000208A                          1971          
0000208A                          1972  is_byte
0000208A  1AFC 0042               1973      MOVE.B  #B_, (A5)+       ;   move B to end of result
0000208E  1AFC 0009               1974      MOVE.B  #TAB, (A5)+      ;   move tab to end of result to prepare for EA
00002092  6000 001A               1975      BRA getEA
00002096                          1976      
00002096                          1977  is_word
00002096  1AFC 0057               1978      MOVE.B  #W_, (A5)+       ;   move W to end of result
0000209A  1AFC 0009               1979      MOVE.B  #TAB, (A5)+      ;   move tab to end of result to prepare for EA
0000209E  6000 000E               1980      BRA getEA
000020A2                          1981  
000020A2                          1982  is_long
000020A2  1AFC 004C               1983      MOVE.B  #L_, (A5)+       ;   move L to end of result
000020A6  1AFC 0009               1984      MOVE.B  #TAB, (A5)+      ;   move tab to end of result to prepare for EA    
000020AA  6000 0002               1985      BRA getEA
000020AE                          1986      
000020AE                          1987  *************Get effective address*****************************************
000020AE                          1988  getEA
000020AE  3005                    1989      MOVE.W  D5, D0          ;   move opcode into d0
000020B0  3C3C 0038               1990      MOVE.W  #$0038, D6      ;   bitmask to get mode bits
000020B4  1E3C 0003               1991      MOVE.B  #3, D7          ;   number to shift after masking
000020B8  6100 1D10               1992      BSR get_bit             ;   get these bits in d0
000020BC  3200                    1993      MOVE.W  D0, D1          ;   move mode bits into d1
000020BE                          1994      
000020BE  3005                    1995      MOVE.W  D5, D0          ;   move the opcode into d0 again
000020C0  3C3C 0007               1996      MOVE.W  #$0007, D6      ;   mask for last three bits
000020C4  3E3C 0000               1997      MOVE.W  #0, D7          ;   no shift needed
000020C8  6100 1D00               1998      BSR get_bit             ;   get register bits in d0
000020CC                          1999  
000020CC  0C41 0000               2000      CMPI.W  #$00, D1        ;   check if mode bits are 000 
000020D0  6700 002A               2001      BEQ neg_Data_reg        ;   branch to (Dn)
000020D4                          2002      
000020D4  0C41 0002               2003      CMPI.W  #$02, D1        ;   check if mode bits are 010
000020D8  6700 002E               2004      BEQ neg_Addr_paren      ;   branch to add (An)   
000020DC                          2005      
000020DC  0C41 0003               2006      CMPI.W  #$03, D1        ;   check if mode bits are 011
000020E0  6700 003A               2007      BEQ neg_Addr_paren_plus ;   branch to add (An)+
000020E4                          2008      
000020E4  0C41 0004               2009      CMPI.W  #$04, D1        ;   check if mode bits are 100
000020E8  6700 004A               2010      BEQ neg_Addr_paren_minus   ;    branch to add -(An)
000020EC                          2011  
000020EC  0C41 0007               2012      CMPI.w  #$07, D1        ;   Check if mode bits are 000
000020F0  6700 005A               2013      BEQ neg_ea              ;   branch to check if W or L
000020F4                          2014      
000020F4  4CDF 2000               2015      MOVEM.L (A7)+, A5       ;   Restore A5  from the stack  
000020F8  6000 F0B4               2016      BRA invalid_code        ;   invalid code 
000020FC                          2017      
000020FC                          2018  neg_Data_reg
000020FC  1AFC 0044               2019      MOVE.B  #D_, (A5)+      ;   move 'D' to result 
00002100  6100 1CF8               2020      BSR put_number          ;   put register number (in D0) 
00002104                          2021  
00002104  6000 F430               2022      BRA ori_done            ;   finished
00002108                          2023  
00002108                          2024  neg_Addr_paren
00002108  1AFC 0028               2025      MOVE.B  #Open_paren, (A5)+  ;   Add '('
0000210C  1AFC 0041               2026      MOVE.B  #A_, (A5)+          ;   Add 'A'
00002110  6100 1CE8               2027      BSR put_number              ;   Add register num (from d0)   
00002114                          2028    
00002114  1AFC 0029               2029      MOVE.B  #Close_paren, (A5)+ ;   Add ')'
00002118  6000 F41C               2030      BRA ori_done                ;   finished
0000211C                          2031  
0000211C                          2032  neg_Addr_paren_plus
0000211C  1AFC 0028               2033      MOVE.B  #Open_paren, (A5)+  ;   Add '(' 
00002120  1AFC 0041               2034      MOVE.B  #A_, (A5)+          ;   Add 'A'
00002124  6100 1CD4               2035      BSR put_number              ;   Add register num (from d0)
00002128  1AFC 0029               2036      MOVE.B  #Close_paren, (A5)+ ;   Add ')'
0000212C  1AFC 002B               2037      MOVE.B  #PLUS, (A5)+        ;   Add '+'
00002130                          2038          
00002130  6000 F404               2039      BRA ori_done                ;   finished  
00002134                          2040    
00002134                          2041  neg_Addr_paren_minus
00002134  1AFC 002D               2042      MOVE.B  #MINUS, (A5)+       ;   Add '-'  
00002138  1AFC 0028               2043      MOVE.B  #Open_paren, (A5)+  ;   Add '('
0000213C  1AFC 0041               2044      MOVE.B  #A_, (A5)+          ;   Add 'A'
00002140  6100 1CB8               2045      BSR put_number              ;   Add register num (from d0)    
00002144  1AFC 0029               2046      MOVE.B  #Close_paren, (A5)+ ;   Add ')'
00002148                          2047      
00002148  6000 F3EC               2048      BRA ori_done                ;   finished 
0000214C                          2049      
0000214C                          2050  neg_ea  
0000214C  1AFC 0024               2051      MOVE.B  #DOLLAR, (A5)+      ;   Add '$'
00002150  0C40 0000               2052      CMPI.W  #$00, D0            ;   Check if is word
00002154  6700 0012               2053      BEQ neg_word_ea             ;   branch if word
00002158                          2054      
00002158  0C40 0001               2055      CMPI.W  #$01, D0            ;   check if is long
0000215C  6700 0020               2056      BEQ neg_long_ea             ;   branch if long
00002160                          2057  
00002160  4CDF 2000               2058      MOVEM.L (A7)+, A5           ;   restore A5 from stack
00002164  6000 F048               2059      BRA invalid_code            ;   code is invalid
00002168                          2060      
00002168                          2061  neg_word_ea      
00002168  3C5A                    2062      MOVEA.W (A2)+, A6           ;   
0000216A  323C 0004               2063      MOVE.W  #word, D1           ;   
0000216E  48E7 0080               2064      MOVEM.L A0, -(A7)  
00002172  6100 F100               2065      BSR hex_to_string           ;   
00002176  4CDF 0100               2066      MOVEM.L (A7)+, A0           ;
0000217A                          2067      
0000217A  6000 F3BA               2068      BRA ori_done                ;   
0000217E                          2069  
0000217E                          2070  neg_long_ea                
0000217E  2C5A                    2071      MOVEA.L (A2)+, A6           ;   
00002180  323C 0008               2072      MOVE.W  #long, D1           ;   
00002184  48E7 0080               2073      MOVEM.L A0, -(A7)  
00002188  6100 F0EA               2074      BSR hex_to_string           ;   
0000218C  4CDF 0100               2075      MOVEM.L (A7)+, A0           ;
00002190                          2076      
00002190  6000 F3A4               2077      BRA ori_done                ;   
00002194                          2078  ***************************END OF NEG***********************************
00002194                          2079  MOVEM_W_L_RtoM
00002194  48E7 0004               2080      MOVEM.L A5, -(A7)   ;   save A5 in the stack (pointer to result message)  
00002198  204E                    2081      MOVEA.L A6, A0      ;   starting address of temp      
0000219A  2A4E                    2082      MOVEA.L A6, A5      ;   move starting address of curent temp Message into A0
0000219C                          2083  
0000219C                          2084  *********Move movem to temp result************
0000219C  1AFC 004D               2085      MOVE.B  #M_, (A5)+
000021A0  1AFC 004F               2086      MOVE.B  #O_, (A5)+
000021A4  1AFC 0056               2087      MOVE.B  #V_, (A5)+
000021A8  1AFC 0045               2088      MOVE.B  #E_, (A5)+
000021AC  1AFC 004D               2089      MOVE.B  #M_, (A5)+
000021B0  1AFC 002E               2090      MOVE.B  #PERIOD, (A5)+
000021B4                          2091      
000021B4  3005                    2092      MOVE.W  D5, D0          ;   move opcode into d0
000021B6  3C3C 0040               2093      MOVE.W  #$0040, D6      ;   bitmask to get size bit
000021BA  1E3C 0006               2094      MOVE.B  #6, D7          ;   number to shift after masking
000021BE  6100 1C0A               2095      BSR get_bit             ;   get this bit in d0
000021C2                          2096      
000021C2  0C40 0000               2097      CMPI.W  #$00, D0
000021C6  6700 0012               2098      BEQ movem_w_RtM
000021CA  0C40 0001               2099      CMPI.W  #$01, D0
000021CE  6700 0016               2100      BEQ movem_l_RtM
000021D2                          2101      
000021D2                          2102  movem_invalid
000021D2  4CDF 2000               2103      MOVEM.L (A7)+, A5       ;   Restore A5  from the stack  
000021D6  6000 EFD6               2104      BRA invalid_code        ;   invalid code 
000021DA                          2105  
000021DA                          2106  movem_w_RtM
000021DA  1AFC 0057               2107      MOVE.B  #W_, (A5)+
000021DE  1AFC 0009               2108      MOVE.B  #TAB, (A5)+
000021E2  6000 000E               2109      BRA movem_RtM
000021E6                          2110      
000021E6                          2111  movem_l_RtM
000021E6  1AFC 004C               2112      MOVE.B  #L_, (A5)+
000021EA  1AFC 0009               2113      MOVE.B  #TAB, (A5)+
000021EE  6000 0002               2114      BRA movem_RtM
000021F2                          2115  
000021F2                          2116  movem_RtM
000021F2                          2117  ****Validation****
000021F2  381A                    2118      MOVE.W (A2)+, D4       ;   move register list mask into d4 
000021F4  0C44 0000               2119      CMPI.W  #$00, D4        ;   validate that D4 is not all 0s
000021F8  67D8                    2120      BEQ movem_invalid
000021FA                          2121  ***Check if EA mode is predecrement***
000021FA  3005                    2122      MOVE.W  D5, D0          ;   move opcode into d0
000021FC  3C3C 0038               2123      MOVE.W  #$0038, D6      ;   bitmask to get mode bits
00002200  1E3C 0003               2124      MOVE.B  #3, D7          ;   number to shift after masking
00002204  6100 1BC4               2125      BSR get_bit             ;   get these bits in d0
00002208                          2126      
00002208  0C40 0004               2127      CMPI.W  #$04, D0        ;   check if mode bits are 100 -(An)
0000220C  6700 00CC               2128      BEQ movem_predec        ;   branch to predec mode for reg list mas
00002210                          2129      
00002210  123C 0000               2130      MOVE.B  #0, D1          ;   set D1 to 0 (acts as counter)
00002214                          2131      
00002214                          2132  rlm_dn_loop
00002214  0C41 0008               2133      CMPI.W  #8, D1          ;   check counter
00002218  6700 0030               2134      BEQ rlm_an_loop         ;   if 8, move to an loop (bits 8-15)
0000221C  6100 0066               2135      BSR get_lsb             ;   get lsb in D0
00002220  0C40 0001               2136      CMPI.W  #1, D0          ;   if bit == 1, branch to add to list 
00002224  6700 0008               2137      BEQ add_reg             ;   add to list
00002228  5201                    2138      ADDI.B  #1, D1          ;   increment ctr
0000222A  E24C                    2139      LSR.W   #1, D4          ;   shift D4 right to get next lsb
0000222C  60E6                    2140      BRA rlm_dn_loop         ;   continue loop
0000222E                          2141      
0000222E                          2142     
0000222E                          2143  add_reg
0000222E  1001                    2144      MOVE.B  D1, D0          ;   move counter into d0
00002230  1AFC 0044               2145      MOVE.B  #D_, (A5)+      ;   add 'D' to result msg
00002234  6100 1BC4               2146      BSR put_number          ;   add reg num (counter) to result msg
00002238  5201                    2147      ADDI.B  #1, D1          ;   add 1 to counter
0000223A  E24C                    2148      LSR.W   #1, D4          ;   
0000223C  0C04 0000               2149      CMPI.B  #$00, D4        ;   if rest is 0, no need to continue
00002240  6700 0052               2150      BEQ RtoM_EA
00002244  1AFC 002F               2151      MOVE.B  #SLASH, (A5)+   ;   add '/' to result
00002248  60CA                    2152      BRA rlm_dn_loop         ;   continue loop
0000224A                          2153      
0000224A                          2154      
0000224A                          2155  rlm_an_loop
0000224A  123C 0000               2156      MOVE.B  #0, D1          ;   reset counter
0000224E                          2157  an_loop
0000224E  0C41 0008               2158      CMPI.W  #8, D1          ;   check counter
00002252  6700 0040               2159      BEQ RtoM_EA             ;   if 0, move to EA
00002256  6100 002C               2160      BSR get_lsb             ;   get lsb in D0
0000225A  0C40 0001               2161      CMPI.W  #1, D0          ;   if bit == 1, branch to add to list 
0000225E  6700 0008               2162      BEQ add_an_reg          ;   add to list
00002262  5201                    2163      ADDI.B  #1, D1          ;   increment ctr
00002264  E24C                    2164      LSR.W   #1, D4          ;   shift D4 right to get next lsb
00002266  60E6                    2165      BRA an_loop             ;   continue loop
00002268                          2166      
00002268                          2167     
00002268                          2168  add_an_reg
00002268  1001                    2169      MOVE.B  D1, D0          ;   move counter into d0
0000226A  1AFC 0041               2170      MOVE.B  #A_, (A5)+      ;   add 'A' to result msg
0000226E  6100 1B8A               2171      BSR put_number          ;   add reg num (counter) to result msg
00002272  5201                    2172      ADDI.B  #1, D1          ;   add 1 to counter
00002274  E24C                    2173      LSR.W   #1, D4          ;   shift right for next lsb
00002276  0C04 0000               2174      CMPI.B  #$0000, D4        ;   if rest is 0 no need to continue
0000227A  6700 0018               2175      BEQ RtoM_EA
0000227E  1AFC 002F               2176      MOVE.B  #SLASH, (A5)+   ;   add '/' to result
00002282  60CA                    2177      BRA an_loop             ;   continue loop
00002284                          2178  
00002284                          2179  get_lsb
00002284  3004                    2180      MOVE.W  D4, D0          ;   move reg list mask into d0
00002286  3C3C 0001               2181      MOVE.W  #$0001, D6      ;   bitmask to get ls bit
0000228A  1E3C 0000               2182      MOVE.B  #0, D7          ;   number to shift after masking (none needed)
0000228E  6100 1B3A               2183      BSR get_bit             ;   get this bit in d0
00002292  4E75                    2184      RTS
00002294                          2185  
00002294                          2186  RtoM_EA
00002294  1AFC 002C               2187      MOVE.B  #COMMA, (A5)+
00002298  1AFC 0020               2188      MOVE.B  #SPACE, (A5)+
0000229C                          2189      
0000229C  3005                    2190      MOVE.W  D5, D0          ;   move opcode into d0
0000229E  3C3C 0038               2191      MOVE.W  #$0038, D6      ;   bitmask to get mode bits
000022A2  1E3C 0003               2192      MOVE.B  #3, D7          ;   number to shift after masking
000022A6  6100 1B22               2193      BSR get_bit             ;   get these bits in d0
000022AA  3200                    2194      MOVE.W  D0, D1          ;   move mode bits into d1
000022AC                          2195      
000022AC  3005                    2196      MOVE.W  D5, D0          ;   move the opcode into d0 again
000022AE  3C3C 0007               2197      MOVE.W  #$0007, D6      ;   mask for last three bits
000022B2  3E3C 0000               2198      MOVE.W  #0, D7          ;   no shift needed
000022B6  6100 1B12               2199      BSR get_bit             ;   get register bits in d0
000022BA                          2200      
000022BA  0C41 0002               2201      CMPI.W  #$02, D1        ;   check if mode bits are 010
000022BE  6700 FE48               2202      BEQ neg_Addr_paren      ;   branch to add (An)   
000022C2                          2203      
000022C2  0C41 0004               2204      CMPI.W  #$04, D1        ;   check if mode bits are 100
000022C6  6700 FE6C               2205      BEQ neg_Addr_paren_minus   ;    branch to add -(An)
000022CA                          2206  
000022CA  0C41 0007               2207      CMPI.w  #$07, D1        ;   Check if mode bits are 111
000022CE  6700 FE7C               2208      BEQ neg_ea              ;   branch to check if W or L
000022D2                          2209      
000022D2  4CDF 2000               2210      MOVEM.L (A7)+, A5       ;   Restore A5  from the stack  
000022D6  6000 EED6               2211      BRA invalid_code        ;   invalid code 
000022DA                          2212      
000022DA                          2213  ******this mode works only for predecrement (RtM)
000022DA                          2214  movem_predec
000022DA  123C 0008               2215      MOVE.B  #8, D1          ;   set counter
000022DE                          2216  RtM_predec_loop
000022DE  0C01 0000               2217      CMPI.B  #0, D1          ;   check counter
000022E2  6700 002E               2218      BEQ RtM_dn_predec       ;   if 0, move to Dn loop (bits 8-15)
000022E6  619C                    2219      BSR get_lsb             ;   get lsb in D0
000022E8  0C00 0001               2220      CMPI.B  #1, D0          ;   if bit == 1, branch to add to list 
000022EC  6700 0008               2221      BEQ add_an_reg_predec   ;   add to list
000022F0  E24C                    2222      LSR.W   #1, D4          ;   shift right for next lsb
000022F2  5301                    2223      SUBI.B  #1, D1          ;   decrement ctr
000022F4  60E8                    2224      BRA RtM_predec_loop     ;   continue loop
000022F6                          2225      
000022F6                          2226     
000022F6                          2227  add_an_reg_predec
000022F6  5301                    2228      SUBI.B   #1, D1         ;   subtract 1 from counter
000022F8  1001                    2229      MOVE.B  D1, D0          ;   move counter into d0
000022FA  1AFC 0041               2230      MOVE.B  #A_, (A5)+      ;   add 'A' to result msg
000022FE  6100 1AFA               2231      BSR put_number          ;   add reg num (counter) to result msg
00002302  E24C                    2232      LSR.W   #1, D4          ;   shift D4 right to prep for next lsb
00002304  0C44 0000               2233      CMPI.W  #$0000, D4      ;   if the rest of D4 is 0, move on. No slash needed
00002308  6700 0008               2234      BEQ RtM_dn_predec
0000230C  1AFC 002F               2235      MOVE.B  #SLASH, (A5)+   ;   add '/' to result
00002310                          2236      
00002310  60CC                    2237      BRA RtM_predec_loop         ;   continue loop
00002312                          2238      
00002312                          2239      
00002312                          2240  RtM_dn_predec
00002312  123C 0008               2241      MOVE.B  #8, D1          ;   reset counter
00002316                          2242  RtM_dn_loop
00002316  0C01 0000               2243      CMPI.B  #0, D1          ;   check counter
0000231A  6700 FF78               2244      BEQ RtoM_EA             ;   if 0, get EA
0000231E  6100 FF64               2245      BSR get_lsb             ;   get lsb in D0
00002322  0C00 0001               2246      CMPI.B  #1, D0          ;   if bit == 1, branch to add to list 
00002326  6700 0008               2247      BEQ add_dn_reg_RtM      ;   add to list
0000232A  E24C                    2248      LSR.W   #1, D4          ;   shift right for next lsb
0000232C  5301                    2249      SUBI.B  #1, D1          ;   decrement ctr
0000232E  60E6                    2250      BRA RtM_dn_loop         ;   continue loop
00002330                          2251      
00002330                          2252     
00002330                          2253  add_dn_reg_RtM
00002330  5301                    2254      SUBI.B  #1, D1          ;   decrement counter
00002332  1001                    2255      MOVE.B  D1, D0          ;   move counter into d0
00002334  1AFC 0044               2256      MOVE.B  #D_, (A5)+      ;   add 'D' to result msg
00002338  6100 1AC0               2257      BSR put_number          ;   add reg num (counter) to result msg
0000233C  E24C                    2258      LSR.W   #1, D4          ;   shift D4 right to get next lsb
0000233E  0C44 0000               2259      CMPI.W  #$0000, D4      ;   if rest is 0, get EA
00002342  6700 FF50               2260      BEQ RtoM_EA
00002346  1AFC 002F               2261      MOVE.B  #SLASH, (A5)+   ;   add '/' to result
0000234A                          2262      
0000234A  60CA                    2263      BRA RtM_dn_loop         ;   continue loop
0000234C                          2264  
0000234C                          2265    
0000234C                          2266  **********************END OF RtM***********************
0000234C                          2267  MULS_DIVS_L_MOVEM_W_L_MtoR  
0000234C  48E7 0004               2268      MOVEM.L A5, -(A7)       ;   save A5 in the stack (pointer to result message)  
00002350  204E                    2269      MOVEA.L A6, A0          ;   starting address of temp      
00002352  2A4E                    2270      MOVEA.L A6, A5          ;   move starting address of curent temp Message
00002354                          2271      
00002354  3005                    2272      MOVE.W  D5, D0          ;   move opcode into d0
00002356  3C3C 00C0               2273      MOVE.W  #$00C0, D6      ;   bitmask to get bits 6,7
0000235A  1E3C 0006               2274      MOVE.B  #6, D7          ;   number to shift after masking
0000235E  6100 1A6A               2275      BSR get_bit             ;   get these bits in d0
00002362                          2276  
00002362  0C40 0000               2277      CMPI.W  #$00, D0
00002366  6700 000E               2278      BEQ muls_l              
0000236A  0C40 0001               2279      CMPI.W  #$01, D0
0000236E  6700 01EC               2280      BEQ divs_l
00002372                          2281      
00002372  6000 0298               2282      BRA movem_w_l_mtr
00002376                          2283      
00002376                          2284  muls_l
00002376  1AFC 004D               2285      MOVE.B  #M_, (A5)+
0000237A  1AFC 0055               2286      MOVE.B  #U_, (A5)+
0000237E  1AFC 004C               2287      MOVE.B  #L_, (A5)+
00002382  1AFC 0053               2288      MOVE.B  #S_, (A5)+
00002386  1AFC 002E               2289      MOVE.B  #PERIOD, (A5)+
0000238A  1AFC 004C               2290      MOVE.B  #L_, (A5)+
0000238E                          2291      
0000238E  6100 0006               2292      BSR muls_l_EA
00002392  6000 0138               2293      BRA check_muls
00002396                          2294      
00002396                          2295  muls_l_EA
00002396  3005                    2296      MOVE.W  D5, D0          ;   move opcode into d0
00002398  3C3C 0038               2297      MOVE.W  #$0038, D6      ;   bitmask to get mode bits
0000239C  1E3C 0003               2298      MOVE.B  #3, D7          ;   number to shift after masking
000023A0  6100 1A28               2299      BSR get_bit             ;   get these bits in d0
000023A4  3200                    2300      MOVE.W  D0, D1          ;   move mode bits into d1
000023A6                          2301      
000023A6  3005                    2302      MOVE.W  D5, D0          ;   move the opcode into d0 again
000023A8  3C3C 0007               2303      MOVE.W  #$0007, D6      ;   mask for last three bits
000023AC  3E3C 0000               2304      MOVE.W  #0, D7          ;   no shift needed
000023B0  6100 1A18               2305      BSR get_bit             ;   get register bits in d0
000023B4                          2306  
000023B4  0C41 0000               2307      CMPI.W  #$00, D1        ;   check if mode bits are 000 
000023B8  6700 002A               2308      BEQ muls_Data_reg        ;   branch to (Dn)
000023BC                          2309      
000023BC  0C41 0002               2310      CMPI.W  #$02, D1        ;   check if mode bits are 010
000023C0  6700 0034               2311      BEQ muls_Addr_paren      ;   branch to add (An)   
000023C4                          2312      
000023C4  0C41 0003               2313      CMPI.W  #$03, D1        ;   check if mode bits are 011
000023C8  6700 0046               2314      BEQ muls_Addr_paren_plus ;   branch to add (An)+
000023CC                          2315      
000023CC  0C41 0004               2316      CMPI.W  #$04, D1        ;   check if mode bits are 100
000023D0  6700 005C               2317      BEQ muls_Addr_paren_minus   ;    branch to add -(An)
000023D4                          2318  
000023D4  0C41 0007               2319      CMPI.w  #$07, D1        ;   Check if mode bits are 111
000023D8  6700 0072               2320      BEQ muls_ea              ;   branch to check if W or L or data
000023DC                          2321      
000023DC  4CDF 2000               2322      MOVEM.L (A7)+, A5       ;   Restore A5  from the stack  
000023E0  6000 EDCC               2323      BRA invalid_code        ;   invalid code 
000023E4                          2324      
000023E4                          2325  muls_Data_reg
000023E4  1AFC 0044               2326      MOVE.B  #D_, (A5)+      ;   move 'D' to result 
000023E8  6100 1A10               2327      BSR put_number          ;   put register number (in D0) 
000023EC                          2328  
000023EC  1AFC 002C               2329      MOVE.B  #COMMA, (A5)+
000023F0  1AFC 0020               2330      MOVE.B  #SPACE, (A5)+
000023F4  4E75                    2331      RTS
000023F6                          2332  
000023F6                          2333  muls_Addr_paren
000023F6  1AFC 0028               2334      MOVE.B  #Open_paren, (A5)+  ;   Add '('
000023FA  1AFC 0041               2335      MOVE.B  #A_, (A5)+          ;   Add 'A'
000023FE  6100 19FA               2336      BSR put_number              ;   Add register num (from d0)   
00002402                          2337    
00002402  1AFC 0029               2338      MOVE.B  #Close_paren, (A5)+ ;   Add ')'
00002406  1AFC 002C               2339      MOVE.B  #COMMA, (A5)+
0000240A  1AFC 0020               2340      MOVE.B  #SPACE, (A5)+
0000240E  4E75                    2341      RTS
00002410                          2342  
00002410                          2343  muls_Addr_paren_plus
00002410  1AFC 0028               2344      MOVE.B  #Open_paren, (A5)+  ;   Add '(' 
00002414  1AFC 0041               2345      MOVE.B  #A_, (A5)+          ;   Add 'A'
00002418  6100 19E0               2346      BSR put_number              ;   Add register num (from d0)
0000241C  1AFC 0029               2347      MOVE.B  #Close_paren, (A5)+ ;   Add ')'
00002420  1AFC 002B               2348      MOVE.B  #PLUS, (A5)+        ;   Add '+'
00002424                          2349          
00002424  1AFC 002C               2350      MOVE.B  #COMMA, (A5)+
00002428  1AFC 0020               2351      MOVE.B  #SPACE, (A5)+
0000242C  4E75                    2352      RTS
0000242E                          2353    
0000242E                          2354  muls_Addr_paren_minus
0000242E  1AFC 002D               2355      MOVE.B  #MINUS, (A5)+       ;   Add '-'  
00002432  1AFC 0028               2356      MOVE.B  #Open_paren, (A5)+  ;   Add '('
00002436  1AFC 0041               2357      MOVE.B  #A_, (A5)+          ;   Add 'A'
0000243A  6100 19BE               2358      BSR put_number              ;   Add register num (from d0)    
0000243E  1AFC 0029               2359      MOVE.B  #Close_paren, (A5)+ ;   Add ')'
00002442                          2360      
00002442  1AFC 002C               2361      MOVE.B  #COMMA, (A5)+
00002446  1AFC 0020               2362      MOVE.B  #SPACE, (A5)+
0000244A  4E75                    2363      RTS
0000244C                          2364      
0000244C                          2365  muls_ea  
0000244C  1AFC 0024               2366      MOVE.B  #DOLLAR, (A5)+      ;   Add '$'
00002450  0C40 0000               2367      CMPI.W  #$00, D0            ;   Check if is word
00002454  6700 001A               2368      BEQ muls_word_ea             ;   branch if word
00002458                          2369      
00002458  0C40 0001               2370      CMPI.W  #$01, D0            ;   check if is long
0000245C  6700 002E               2371      BEQ muls_long_ea             ;   branch if long
00002460                          2372      
00002460  0C40 0003               2373      CMPI.W  #$03, D0
00002464  6700 0042               2374      BEQ muls_data_ea
00002468                          2375  
00002468  4CDF 2000               2376      MOVEM.L (A7)+, A5           ;   restore A5 from stack
0000246C  6000 ED40               2377      BRA invalid_code            ;   code is invalid
00002470                          2378      
00002470                          2379  muls_word_ea      
00002470  3C5A                    2380      MOVEA.W (A2)+, A6      ;   
00002472  323C 0004               2381      MOVE.W  #word, D1   ;   
00002476  48E7 0080               2382      MOVEM.L A0, -(A7)  
0000247A  6100 EDF8               2383      BSR hex_to_string   ;   
0000247E  4CDF 0100               2384      MOVEM.L (A7)+, A0  ;
00002482                          2385      
00002482  1AFC 002C               2386      MOVE.B  #COMMA, (A5)+
00002486  1AFC 0020               2387      MOVE.B  #SPACE, (A5)+
0000248A  4E75                    2388      RTS 
0000248C                          2389  
0000248C                          2390  muls_long_ea                
0000248C  2C5A                    2391      MOVEA.L (A2)+, A6      ;   
0000248E  323C 0008               2392      MOVE.W  #long, D1   ;   
00002492  48E7 0080               2393      MOVEM.L A0, -(A7)  
00002496  6100 EDDC               2394      BSR hex_to_string   ;   
0000249A  4CDF 0100               2395      MOVEM.L (A7)+, A0  ;
0000249E                          2396      
0000249E  1AFC 002C               2397      MOVE.B  #COMMA, (A5)+
000024A2  1AFC 0020               2398      MOVE.B  #SPACE, (A5)+
000024A6  4E75                    2399      RTS
000024A8                          2400      
000024A8                          2401  muls_data_ea
000024A8  1AFC 0023               2402      MOVE.B  #SHARP, (A5)+   ;   
000024AC  1AFC 0024               2403      MOVE.B  #DOLLAR, (A5)+ ; 
000024B0  3C5A                    2404      MOVEA.W (A2)+, A6      ;   
000024B2  323C 0004               2405      MOVE.W  #word, D1   ;   
000024B6  48E7 0480               2406      MOVEM.L D5/A0, -(A7)  
000024BA  6100 EDB8               2407      BSR hex_to_string   ; 
000024BE  4CDF 0120               2408      MOVEM.L (A7)+, D5/A0   ;  
000024C2                          2409      
000024C2  1AFC 002C               2410      MOVE.B  #COMMA, (A5)+
000024C6  1AFC 0020               2411      MOVE.B  #SPACE, (A5)+
000024CA  4E75                    2412      RTS
000024CC                          2413  
000024CC                          2414  ********END OF EA FOR MULS (also used for divs)*******
000024CC                          2415  check_muls
000024CC                          2416  **VALIDATE FORMAT**
000024CC  381A                    2417      MOVE.W (A2)+, D4        ;   move next 16 bits into d4              ***************************************************************************************************************
000024CE  0C44 0000               2418      CMPI.W  #$00, D4        ;   validate that D4 is not all 0s
000024D2  6700 FCFE               2419      BEQ movem_invalid       ;   invalid if true
000024D6                          2420      
000024D6  3004                    2421      MOVE.W  D4, D0          ;   move next 16 bits into d0
000024D8  3C3C 0800               2422      MOVE.W  #$0800, D6      ;   bitmask to check bit 11- needs to be 1
000024DC  1E3C 000B               2423      MOVE.B  #11, D7         ;   number to shift after masking
000024E0  6100 18E8               2424      BSR get_bit             ;   get this bit in d0
000024E4                          2425      
000024E4  0C40 0001               2426      CMPI.W  #$01, D0        ;   compare result with necessary format (bit 11 = 1)
000024E8  6600 FCE8               2427      BNE movem_invalid       ;   if not equal, invalid code
000024EC                          2428      
000024EC  3004                    2429      MOVE.W  D4, D0          ;   move bits into d0
000024EE  3C3C 0400               2430      MOVE.W  #$0400, D6      ;   bitmask to get bit 10
000024F2  1E3C 000A               2431      MOVE.B  #10, D7         ;   number to shift after masking
000024F6  6100 18D2               2432      BSR get_bit             ;   get this bit in d0
000024FA                          2433      
000024FA  0C00 0000               2434      CMPI.B  #$00, D0        ;   check size bit
000024FE  6700 000E               2435      BEQ one_reg_muls
00002502  0C00 0001               2436      CMPI.B  #$01, D0        ;   check size bit
00002506  6700 0020               2437      BEQ range_reg_muls
0000250A                          2438      
0000250A  6000 FCC6               2439      BRA movem_invalid       ;   if somehow doesn't get branched- invalid code
0000250E                          2440      
0000250E                          2441  one_reg_muls
0000250E  3004                    2442      MOVE.W  D4, D0          ;   move next 16 bits into d0
00002510  3C3C 0700               2443      MOVE.W  #$0700, D6      ;   bitmask to check bits 12-14 (register)
00002514  1E3C 000C               2444      MOVE.B  #12, D7         ;   number to shift after masking
00002518  6100 18B0               2445      BSR get_bit             ;   get this bits in d0
0000251C                          2446      
0000251C  1AFC 0044               2447      MOVE.B  #D_, (A5)+
00002520  6100 18D8               2448      BSR put_number          ;   add data register
00002524  6000 F010               2449      BRA ori_done            ;   finished
00002528                          2450      
00002528                          2451  range_reg_muls
00002528  3004                    2452      MOVE.W  D4, D0          ;   move next 16 bits into d0
0000252A  3C3C 0700               2453      MOVE.W  #$0700, D6      ;   bitmask to check bits 12-14 (register)
0000252E  1E3C 000C               2454      MOVE.B  #12, D7         ;   number to shift after masking
00002532  6100 1896               2455      BSR get_bit             ;   get this bits in d0
00002536                          2456      
00002536  1AFC 0044               2457      MOVE.B  #D_, (A5)+
0000253A  6100 18BE               2458      BSR put_number          ;   add data register
0000253E                          2459      
0000253E  3004                    2460      MOVE.W  D4, D0          ;   move next 16 bits into d0
00002540  3C3C 0007               2461      MOVE.W  #$0007, D6      ;   bitmask to check bits 0-2 (register 2)
00002544  1E3C 0000               2462      MOVE.B  #0, D7          ;   number to shift after masking
00002548  6100 1880               2463      BSR get_bit             ;   get this bits in d0
0000254C                          2464      
0000254C  1AFC 002D               2465      MOVE.B  #DASH, (A5)+
00002550  1AFC 0044               2466      MOVE.B  #D_, (A5)+
00002554  6100 18A4               2467      BSR put_number
00002558                          2468      
00002558  6000 EFDC               2469      BRA ori_done            ;   finished
0000255C                          2470  ***********END OF MULS.L*****************
0000255C                          2471  
0000255C                          2472  divs_l
0000255C  1AFC 0044               2473      MOVE.B  #D_, (A5)+
00002560  1AFC 0049               2474      MOVE.B  #I_, (A5)+
00002564  1AFC 0056               2475      MOVE.B  #V_, (A5)+
00002568  1AFC 0053               2476      MOVE.B  #S_, (A5)+
0000256C  1AFC 002E               2477      MOVE.B  #PERIOD, (A5)+
00002570  1AFC 004C               2478      MOVE.B  #L_, (A5)+
00002574                          2479      
00002574  6100 FE20               2480      BSR muls_l_EA
00002578  6000 0002               2481      BRA check_divs
0000257C                          2482      
0000257C                          2483  check_divs
0000257C                          2484  **VALIDATE FORMAT**
0000257C  381A                    2485      MOVE.W (A2)+, D4        ;   move next 16 bits into d4              ***************************************************************************************************************
0000257E  0C44 0000               2486      CMPI.W  #$00, D4        ;   validate that D4 is not all 0s
00002582  6700 FC4E               2487      BEQ movem_invalid       ;   invalid if true
00002586                          2488      
00002586  3004                    2489      MOVE.W  D4, D0          ;   move next 16 bits into d0
00002588  3C3C 0800               2490      MOVE.W  #$0800, D6      ;   bitmask to check bit 11- needs to be 1
0000258C  1E3C 000B               2491      MOVE.B  #11, D7         ;   number to shift after masking
00002590  6100 1838               2492      BSR get_bit             ;   get this bit in d0
00002594                          2493      
00002594  0C40 0001               2494      CMPI.W  #$01, D0        ;   compare result with necessary format (bit 11 = 1)
00002598  6600 FC38               2495      BNE movem_invalid       ;   if not equal, invalid code
0000259C                          2496      
0000259C  3004                    2497      MOVE.W  D4, D0          ;   move bits into d0
0000259E  3C3C 0400               2498      MOVE.W  #$0400, D6      ;   bitmask to get bit 10
000025A2  1E3C 000A               2499      MOVE.B  #10, D7         ;   number to shift after masking
000025A6  6100 1822               2500      BSR get_bit             ;   get this bit in d0
000025AA                          2501      
000025AA  0C00 0000               2502      CMPI.B  #$00, D0        ;   check size bit
000025AE  6700 000E               2503      BEQ one_reg_divs
000025B2  0C00 0001               2504      CMPI.B  #$01, D0        ;   check size bit
000025B6  6700 0020               2505      BEQ range_reg_divs
000025BA                          2506      
000025BA  6000 FC16               2507      BRA movem_invalid       ;   if somehow doesn't get branched- invalid code
000025BE                          2508      
000025BE                          2509  one_reg_divs
000025BE  3004                    2510      MOVE.W  D4, D0          ;   move next 16 bits into d0
000025C0  3C3C 0700               2511      MOVE.W  #$0700, D6      ;   bitmask to check bits 12-14 (register)
000025C4  1E3C 000C               2512      MOVE.B  #12, D7         ;   number to shift after masking
000025C8  6100 1800               2513      BSR get_bit             ;   get this bits in d0
000025CC                          2514      
000025CC  1AFC 0044               2515      MOVE.B  #D_, (A5)+
000025D0  6100 1828               2516      BSR put_number          ;   add data register
000025D4  6000 EF60               2517      BRA ori_done            ;   finished
000025D8                          2518      
000025D8                          2519  range_reg_divs
000025D8  3004                    2520      MOVE.W  D4, D0          ;   move next 16 bits into d0
000025DA  3C3C 0700               2521      MOVE.W  #$0700, D6      ;   bitmask to check bits 12-14 (register)
000025DE  1E3C 000C               2522      MOVE.B  #12, D7         ;   number to shift after masking
000025E2  6100 17E6               2523      BSR get_bit             ;   get this bits in d0
000025E6                          2524      
000025E6  1AFC 0044               2525      MOVE.B  #D_, (A5)+
000025EA  6100 180E               2526      BSR put_number          ;   add data register
000025EE                          2527      
000025EE  3004                    2528      MOVE.W  D4, D0          ;   move next 16 bits into d0
000025F0  3C3C 0007               2529      MOVE.W  #$0007, D6      ;   bitmask to check bits 0-2 (register 2)
000025F4  1E3C 0000               2530      MOVE.B  #0, D7          ;   number to shift after masking
000025F8  6100 17D0               2531      BSR get_bit             ;   get this bits in d0
000025FC                          2532      
000025FC  1AFC 003A               2533      MOVE.B  #COLON, (A5)+
00002600  1AFC 0044               2534      MOVE.B  #D_, (A5)+
00002604  6100 17F4               2535      BSR put_number
00002608                          2536      
00002608  6000 EF2C               2537      BRA ori_done            ;   finished
0000260C                          2538      
0000260C                          2539  *********END OF DIVS.l***************************************
0000260C                          2540      
0000260C                          2541  movem_w_l_mtr
0000260C  1AFC 004D               2542      MOVE.B  #M_, (A5)+
00002610  1AFC 004F               2543      MOVE.B  #O_, (A5)+
00002614  1AFC 0056               2544      MOVE.B  #V_, (A5)+
00002618  1AFC 0045               2545      MOVE.B  #E_, (A5)+
0000261C  1AFC 004D               2546      MOVE.B  #M_, (A5)+
00002620  1AFC 002E               2547      MOVE.B  #PERIOD, (A5)+
00002624                          2548  
00002624  0C40 0002               2549      CMPI.W  #$02, D0
00002628  6700 0012               2550      BEQ movem_w_mtr
0000262C  0C40 0003               2551      CMPI.W  #$03, D0
00002630  6700 0016               2552      BEQ movem_l_mtr
00002634                          2553      
00002634  4CDF 2000               2554      MOVEM.L (A7)+, A5           ;   restore A5 from stack
00002638  6000 EB74               2555      BRA invalid_code            ;   code is invalid
0000263C                          2556      
0000263C                          2557  movem_w_mtr
0000263C  1AFC 0057               2558      MOVE.B  #W_, (A5)+
00002640  1AFC 0009               2559      MOVE.B  #TAB, (A5)+
00002644  6000 000E               2560      BRA movem_MtR
00002648                          2561      
00002648                          2562  movem_l_mtr
00002648  1AFC 004C               2563      MOVE.B  #L_, (A5)+
0000264C  1AFC 0009               2564      MOVE.B  #TAB, (A5)+
00002650  6000 0002               2565      BRA movem_MtR
00002654                          2566      
00002654                          2567  movem_MtR
00002654  381A                    2568      MOVE.W (A2)+, D4        ;   move register list mask into d4              ***************************************************************************************************************
00002656  0C44 0000               2569      CMPI.W  #$0000, D4        ;   validate that D4 is not all 0s
0000265A  6700 FB76               2570      BEQ movem_invalid
0000265E                          2571   
0000265E                          2572  MtR_movem_EA 
0000265E  3005                    2573      MOVE.W  D5, D0          ;   move opcode into d0
00002660  3C3C 0038               2574      MOVE.W  #$0038, D6      ;   bitmask to get mode bits
00002664  1E3C 0003               2575      MOVE.B  #3, D7          ;   number to shift after masking
00002668  6100 1760               2576      BSR get_bit             ;   get these bits in d0
0000266C  3200                    2577      MOVE.W  D0, D1          ;   move mode bits into d1
0000266E                          2578      
0000266E  3005                    2579      MOVE.W  D5, D0          ;   move the opcode into d0 again
00002670  3C3C 0007               2580      MOVE.W  #$0007, D6      ;   mask for last three bits
00002674  3E3C 0000               2581      MOVE.W  #0, D7          ;   no shift needed
00002678  6100 1750               2582      BSR get_bit             ;   get register bits in d0
0000267C                          2583      
0000267C  0C41 0002               2584      CMPI.W  #$02, D1        ;   check if mode bits are 010
00002680  6700 001A               2585      BEQ MtR_Addr_paren      ;   branch to add (An)   
00002684                          2586      
00002684  0C41 0003               2587      CMPI.W  #$03, D1        ;   check if mode bits are 011
00002688  6700 0032               2588      BEQ MtR_Addr_paren_plus ;   branch to add (An)+
0000268C                          2589  
0000268C  0C41 0007               2590      CMPI.W  #$07, D1        ;   Check if mode bits are 111
00002690  6700 004E               2591      BEQ MtR_ea              ;   branch to check if W or L
00002694                          2592      
00002694  4CDF 2000               2593      MOVEM.L (A7)+, A5       ;   Restore A5  from the stack  
00002698  6000 EB14               2594      BRA invalid_code        ;   invalid code 
0000269C                          2595  
0000269C                          2596  MtR_Addr_paren
0000269C  1AFC 0028               2597      MOVE.B  #Open_paren, (A5)+  ;   Add '('
000026A0  1AFC 0041               2598      MOVE.B  #A_, (A5)+          ;   Add 'A'
000026A4  6100 1754               2599      BSR put_number              ;   Add register num (from d0)   
000026A8  1AFC 0029               2600      MOVE.B  #Close_paren, (A5)+ ;   Add ')'
000026AC                          2601      
000026AC  1AFC 002C               2602      MOVE.B  #COMMA, (A5)+
000026B0  1AFC 0020               2603      MOVE.B  #SPACE, (A5)+
000026B4  123C 0000               2604      MOVE.B  #0, D1              ;  set counter 
000026B8  6000 0086               2605      BRA MtR_dn_loop             ;  branch to loop for list of registers
000026BC                          2606  
000026BC                          2607  MtR_Addr_paren_plus
000026BC  1AFC 0028               2608      MOVE.B  #Open_paren, (A5)+  ;   Add '(' 
000026C0  1AFC 0041               2609      MOVE.B  #A_, (A5)+          ;   Add 'A'
000026C4  6100 1734               2610      BSR put_number              ;   Add register num (from d0)
000026C8  1AFC 0029               2611      MOVE.B  #Close_paren, (A5)+ ;   Add ')'
000026CC  1AFC 002B               2612      MOVE.B  #PLUS, (A5)+        ;   Add '+'
000026D0                          2613          
000026D0  1AFC 002C               2614      MOVE.B  #COMMA, (A5)+
000026D4  1AFC 0020               2615      MOVE.B  #SPACE, (A5)+
000026D8  123C 0000               2616      MOVE.B  #0, D1              ;  set counter 
000026DC  6000 0062               2617      BRA MtR_dn_loop             ;  branch to loop for list of registers
000026E0                          2618      
000026E0                          2619  MtR_ea 
000026E0  1AFC 0024               2620      MOVE.B  #DOLLAR, (A5)+      ;   Add '$'
000026E4  0C40 0000               2621      CMPI.W  #$00, D0            ;   Check if is word
000026E8  6700 0012               2622      BEQ MtR_word_ea             ;   branch if word
000026EC                          2623      
000026EC  0C40 0001               2624      CMPI.W  #$01, D0            ;   check if is long
000026F0  6700 002C               2625      BEQ MtR_long_ea             ;   branch if long
000026F4                          2626  
000026F4  4CDF 2000               2627      MOVEM.L (A7)+, A5           ;   restore A5 from stack
000026F8  6000 EAB4               2628      BRA invalid_code            ;   code is invalid
000026FC                          2629      
000026FC                          2630  MtR_word_ea      
000026FC  3C5A                    2631      MOVEA.W (A2)+, A6      ;   
000026FE  323C 0004               2632      MOVE.W  #word, D1   ;   
00002702  48E7 0080               2633      MOVEM.L A0, -(A7)  
00002706  6100 EB6C               2634      BSR hex_to_string   ;   
0000270A  4CDF 0100               2635      MOVEM.L (A7)+, A0  ;
0000270E                          2636      
0000270E  1AFC 002C               2637      MOVE.B  #COMMA, (A5)+
00002712  1AFC 0020               2638      MOVE.B  #SPACE, (A5)+
00002716  123C 0000               2639      MOVE.B  #0, D1              ;  set counter 
0000271A  6000 0024               2640      BRA MtR_dn_loop             ;  branch to loop for list of registers   
0000271E                          2641  
0000271E                          2642  MtR_long_ea                
0000271E  2C5A                    2643      MOVEA.L (A2)+, A6      ;   
00002720  323C 0008               2644      MOVE.W  #long, D1   ;   
00002724  48E7 0080               2645      MOVEM.L A0, -(A7)  
00002728  6100 EB4A               2646      BSR hex_to_string   ;   
0000272C  4CDF 0100               2647      MOVEM.L (A7)+, A0  ;
00002730                          2648      
00002730  1AFC 002C               2649      MOVE.B  #COMMA, (A5)+
00002734  1AFC 0020               2650      MOVE.B  #SPACE, (A5)+
00002738  123C 0000               2651      MOVE.B  #0, D1              ;  set counter 
0000273C  6000 0002               2652      BRA MtR_dn_loop             ;  branch to loop for list of registers
00002740                          2653     
00002740                          2654  ************************************END of MtR EA********************************************
00002740                          2655  MtR_dn_loop
00002740  0C41 0008               2656      CMPI.W  #8, D1          ;   check counter
00002744  6700 0030               2657      BEQ MtR_an_loop         ;   if 8, move to an loop (bits 8-15)
00002748  6100 FB3A               2658      BSR get_lsb             ;   get lsb in D0
0000274C  0C40 0001               2659      CMPI.W  #1, D0          ;   if bit == 1, branch to add to list 
00002750  6700 0008               2660      BEQ MtR_add_reg             ;   add to list
00002754  5201                    2661      ADDI.B  #1, D1          ;   increment ctr
00002756  E24C                    2662      LSR.W   #1, D4          ;   shift D4 right to get next lsb
00002758  60E6                    2663      BRA MtR_dn_loop         ;   continue loop
0000275A                          2664      
0000275A                          2665     
0000275A                          2666  MtR_add_reg
0000275A  1001                    2667      MOVE.B  D1, D0          ;   move counter into d0
0000275C  1AFC 0044               2668      MOVE.B  #D_, (A5)+      ;   add 'D' to result msg
00002760  6100 1698               2669      BSR put_number          ;   add reg num (counter) to result msg
00002764  5201                    2670      ADDI.B  #1, D1          ;   add 1 to counter
00002766  E24C                    2671      LSR.W   #1, D4          ;   
00002768  0C44 0000               2672      CMPI.W  #$0000, D4      ;   if rest is 0, no need to continue
0000276C  6700 EDC8               2673      BEQ ori_done
00002770  1AFC 002F               2674      MOVE.B  #SLASH, (A5)+   ;   add '/' to result
00002774  60CA                    2675      BRA MtR_dn_loop         ;   continue loop
00002776                          2676      
00002776                          2677      
00002776                          2678  MtR_an_loop
00002776  123C 0000               2679      MOVE.B  #0, D1          ;   reset counter
0000277A                          2680  an_loop_MtR
0000277A  0C41 0008               2681      CMPI.W  #8, D1          ;   check counter
0000277E  6700 EDB6               2682      BEQ ori_done            ;   if 0, done
00002782  6100 FB00               2683      BSR get_lsb             ;   get lsb in D0
00002786  0C40 0001               2684      CMPI.W  #1, D0          ;   if bit == 1, branch to add to list 
0000278A  6700 0008               2685      BEQ add_an_reg_MtR          ;   add to list
0000278E  5201                    2686      ADDI.B  #1, D1          ;   increment ctr
00002790  E24C                    2687      LSR.W   #1, D4          ;   shift D4 right to get next lsb
00002792  60E6                    2688      BRA an_loop_MtR             ;   continue loop
00002794                          2689      
00002794                          2690     
00002794                          2691  add_an_reg_MtR
00002794  1001                    2692      MOVE.B  D1, D0          ;   move counter into d0
00002796  1AFC 0041               2693      MOVE.B  #A_, (A5)+      ;   add 'A' to result msg
0000279A  6100 165E               2694      BSR put_number          ;   add reg num (counter) to result msg
0000279E  5201                    2695      ADDI.B  #1, D1          ;   add 1 to counter
000027A0  E24C                    2696      LSR.W   #1, D4          ;   shift right for next lsb
000027A2  0C04 0000               2697      CMPI.B  #$0000, D4        ;   if rest is 0 no need to continue
000027A6  6700 ED8E               2698      BEQ ori_done
000027AA  1AFC 002F               2699      MOVE.B  #SLASH, (A5)+   ;   add '/' to result
000027AE  60CA                    2700      BRA an_loop_MtR             ;   continue loop
000027B0                          2701      
000027B0                          2702  **********JSR***********
000027B0                          2703  JSR_function    
000027B0  48E7 0004               2704      MOVEM.L A5, -(A7)   ;   save A5 in the stack (pointer to result message)  
000027B4  204E                    2705      MOVEA.L A6, A0      ;   starting address of temp      
000027B6  2A4E                    2706      MOVEA.L A6, A5      ;   move starting address of curent temp Message into A0
000027B8                          2707      
000027B8                          2708  *****PUT JSR IN TEMP RESULT
000027B8  1AFC 004A               2709      MOVE.B  #J_, (A5)+
000027BC  1AFC 0053               2710      MOVE.B  #S_, (A5)+
000027C0  1AFC 0052               2711      MOVE.B  #R_, (A5)+
000027C4  1AFC 0009               2712      MOVE.B  #TAB, (A5)+
000027C8                          2713      
000027C8                          2714  *Get EA*
000027C8  3005                    2715      MOVE.W  D5, D0          ;   move opcode into d0
000027CA  3C3C 0038               2716      MOVE.W  #$0038, D6      ;   bitmask to get mode bits
000027CE  1E3C 0003               2717      MOVE.B  #3, D7          ;   number to shift after masking
000027D2  6100 15F6               2718      BSR get_bit             ;   get these bits in d0
000027D6  3200                    2719      MOVE.W  D0, D1          ;   move mode bits into d1
000027D8                          2720      
000027D8  3005                    2721      MOVE.W  D5, D0          ;   move the opcode into d0 again
000027DA  3C3C 0007               2722      MOVE.W  #$0007, D6      ;   mask for last three bits
000027DE  3E3C 0000               2723      MOVE.W  #0, D7          ;   no shift needed
000027E2  6100 15E6               2724      BSR get_bit             ;   get register bits in d0
000027E6                          2725      
000027E6  0C41 0002               2726      CMPI.W  #$02, D1        ;   check if mode bits are 010
000027EA  6700 F91C               2727      BEQ neg_Addr_paren      ;   branch to add (An)   
000027EE                          2728  
000027EE  0C41 0007               2729      CMPI.W  #$07, D1        ;   Check if mode bits are 111
000027F2  6700 F958               2730      BEQ neg_ea              ;   branch to check if W or L
000027F6                          2731      
000027F6  4CDF 2000               2732      MOVEM.L (A7)+, A5       ;   Restore A5  from the stack  
000027FA  6000 E9B2               2733      BRA invalid_code        ;   invalid code 
000027FE                          2734      
000027FE                          2735  *********END OF JSR****************
000027FE                          2736  
000027FE                          2737  LEA_function
000027FE  48E7 0004               2738      MOVEM.L A5, -(A7)   ;   save A5 in the stack (pointer to result message)  
00002802  204E                    2739      MOVEA.L A6, A0      ;   starting address of temp      
00002804  2A4E                    2740      MOVEA.L A6, A5      ;   move starting address of curent temp Message into A0
00002806                          2741      
00002806                          2742  ******MOVE LEA INTO TEMP RESULT************************
00002806  1AFC 004C               2743      MOVE.B  #L_, (A5)+
0000280A  1AFC 0045               2744      MOVE.B  #E_, (A5)+
0000280E  1AFC 0041               2745      MOVE.B  #A_, (A5)+
00002812  1AFC 0009               2746      MOVE.B  #TAB, (A5)+
00002816                          2747      
00002816                          2748  lea_EA
00002816  3005                    2749      MOVE.W  D5, D0          ;   move opcode into d0
00002818  3C3C 0038               2750      MOVE.W  #$0038, D6      ;   bitmask to get mode bits
0000281C  1E3C 0003               2751      MOVE.B  #3, D7          ;   number to shift after masking
00002820  6100 15A8               2752      BSR get_bit             ;   get these bits in d0
00002824  3200                    2753      MOVE.W  D0, D1          ;   move mode bits into d1
00002826                          2754      
00002826  3005                    2755      MOVE.W  D5, D0          ;   move the opcode into d0 again
00002828  3C3C 0007               2756      MOVE.W  #$0007, D6      ;   mask for last three bits
0000282C  3E3C 0000               2757      MOVE.W  #0, D7          ;   no shift needed
00002830  6100 1598               2758      BSR get_bit             ;   get register bits in d0
00002834                          2759      
00002834  0C41 0002               2760      CMPI.W  #$02, D1        ;   check if mode bits are 010
00002838  6700 0012               2761      BEQ lea_Addr_paren      ;   branch to add (An)   
0000283C                          2762  
0000283C  0C41 0007               2763      CMPI.W  #$07, D1        ;   Check if mode bits are 111
00002840  6700 001E               2764      BEQ lea_word_long_ea    ;   branch to check if W or L
00002844                          2765      
00002844  4CDF 2000               2766      MOVEM.L (A7)+, A5       ;   Restore A5  from the stack  
00002848  6000 E964               2767      BRA invalid_code        ;   invalid code 
0000284C                          2768      
0000284C                          2769  
0000284C                          2770  lea_Addr_paren
0000284C  1AFC 0028               2771      MOVE.B  #Open_paren, (A5)+  ;   Add '('
00002850  1AFC 0041               2772      MOVE.B  #A_, (A5)+          ;   Add 'A'
00002854  6100 15A4               2773      BSR put_number              ;   Add register num (from d0)   
00002858                          2774    
00002858  1AFC 0029               2775      MOVE.B  #Close_paren, (A5)+ ;   Add ')'
0000285C  6000 004A               2776      BRA lea_add_an
00002860                          2777      
00002860                          2778  lea_word_long_ea  
00002860  1AFC 0024               2779      MOVE.B  #DOLLAR, (A5)+      ;   Add '$'
00002864  0C40 0000               2780      CMPI.W  #$00, D0            ;   Check if is word
00002868  6700 0012               2781      BEQ lea_word_ea             ;   branch if word
0000286C                          2782      
0000286C  0C40 0001               2783      CMPI.W  #$01, D0            ;   check if is long
00002870  6700 0020               2784      BEQ lea_long_ea             ;   branch if long
00002874                          2785  
00002874  4CDF 2000               2786      MOVEM.L (A7)+, A5           ;   restore A5 from stack
00002878  6000 E934               2787      BRA invalid_code            ;   code is invalid
0000287C                          2788      
0000287C                          2789  lea_word_ea      
0000287C  3C5A                    2790      MOVEA.W (A2)+, A6      ;   
0000287E  323C 0004               2791      MOVE.W  #word, D1   ;   
00002882  48E7 0080               2792      MOVEM.L A0, -(A7)  
00002886  6100 E9EC               2793      BSR hex_to_string   ;   
0000288A  4CDF 0100               2794      MOVEM.L (A7)+, A0  ;
0000288E                          2795      
0000288E  6000 0018               2796      BRA lea_add_an  
00002892                          2797  
00002892                          2798  lea_long_ea                
00002892  2C5A                    2799      MOVEA.L (A2)+, A6      ;   
00002894  323C 0008               2800      MOVE.W  #long, D1   ;   
00002898  48E7 0080               2801      MOVEM.L A0, -(A7)  
0000289C  6100 E9D6               2802      BSR hex_to_string   ;   
000028A0  4CDF 0100               2803      MOVEM.L (A7)+, A0  ;
000028A4                          2804      
000028A4  6000 0002               2805      BRA lea_add_an
000028A8                          2806      
000028A8                          2807  lea_add_an
000028A8  1AFC 002C               2808      MOVE.B  #COMMA, (A5)+
000028AC  1AFC 0020               2809      MOVE.B  #SPACE, (A5)+
000028B0  1AFC 0041               2810      MOVE.B  #A_, (A5)+
000028B4                          2811      
000028B4  3005                    2812      MOVE.W  D5, D0          ;   move opcode into d0
000028B6  3C3C 0E00               2813      MOVE.W  #$0E00, D6      ;   bitmask to get register bits
000028BA  1E3C 0009               2814      MOVE.B  #9, D7          ;   number to shift after masking
000028BE  6100 150A               2815      BSR get_bit             ;   get these bits in d0
000028C2                          2816      
000028C2  6100 1536               2817      BSR put_number          ;   Add the register number to result
000028C6  6000 EC6E               2818      BRA ori_done            ;   finished
000028CA                          2819  
000028CA                          2820  * five_start **********************
000028CA                          2821  SUBQ_function     
000028CA  48E7 0004               2822      MOVEM.L A5, -(A7)   ;   save A5 in the stack (pointer to result message)  
000028CE  204E                    2823      MOVEA.L A6, A0      ;   starting address of temp      
000028D0  2A4E                    2824      MOVEA.L A6, A5      ;   move starting address of curent temp Message into A0
000028D2                          2825      
000028D2                          2826  *Move SUBQ. into the temporary result*********
000028D2  1AFC 0053               2827      MOVE.B  #S_, (A5)+
000028D6  1AFC 0055               2828      MOVE.B  #U_, (A5)+
000028DA  1AFC 0042               2829      MOVE.B  #B_, (A5)+
000028DE  1AFC 0051               2830      MOVE.B  #Q_, (A5)+
000028E2  1AFC 002E               2831      MOVE.B  #PERIOD, (A5)+
000028E6                          2832      
000028E6  3005                    2833      MOVE.W  D5, D0      ;   move the opcode into d0
000028E8  3C3C 00C0               2834      MOVE.W  #$00C0, D6  ;   move the bitmask into d6
000028EC  1E3C 0006               2835      MOVE.B  #6, D7      ;   intended shift after masking into d7
000028F0  6100 14D8               2836      BSR get_bit         ;   get the size returned in d0
000028F4                          2837      
000028F4  0C00 0000               2838      CMPI.B  #$00, D0
000028F8  6700 0012               2839          BEQ subq_is_byte
000028FC  0C00 0001               2840      CMPI.B  #$01, D0
00002900  6700 0016               2841          BEQ subq_is_word
00002904  0C00 0002               2842      CMPI.B  #$02, D0
00002908  6700 001A               2843          BEQ subq_is_long
0000290C                          2844          
0000290C                          2845  subq_is_byte
0000290C  1AFC 0042               2846      MOVE.B  #B_, (A5)+       ;   move B to end of result
00002910  1AFC 0009               2847      MOVE.B  #TAB, (A5)+      ;   move tab to end of result to prepare for EA
00002914  6000 001A               2848      BRA get_subq_data
00002918                          2849      
00002918                          2850  subq_is_word
00002918  1AFC 0057               2851      MOVE.B  #W_, (A5)+       ;   move W to end of result
0000291C  1AFC 0009               2852      MOVE.B  #TAB, (A5)+      ;   move tab to end of result to prepare for EA
00002920  6000 000E               2853      BRA get_subq_data
00002924                          2854  
00002924                          2855  subq_is_long
00002924  1AFC 004C               2856      MOVE.B  #L_, (A5)+       ;   move L to end of result
00002928  1AFC 0009               2857      MOVE.B  #TAB, (A5)+      ;   move tab to end of result to prepare for EA    
0000292C  6000 0002               2858      BRA get_subq_data
00002930                          2859      
00002930                          2860  *******Get the data field and add this. After this, get EA(will be same as neg EA)
00002930                          2861  get_subq_data
00002930  1AFC 0023               2862      MOVE.B  #SHARP, (A5)+
00002934                          2863      
00002934  3005                    2864      MOVE.W  D5, D0
00002936  3C3C 0E00               2865      MOVE.W  #$0E00, D6
0000293A  1E3C 0009               2866      MOVE.B  #9, D7
0000293E  6100 148A               2867      BSR get_bit
00002942                          2868      
00002942  0C00 0000               2869      CMPI.B  #$00, D0
00002946  6700 0012               2870          BEQ subq_eight
0000294A                          2871          
0000294A  6100 14AE               2872      BSR put_number
0000294E  1AFC 002C               2873      MOVE.B #COMMA, (A5)+
00002952  1AFC 0020               2874      MOVE.B #SPACE, (A5)+
00002956  6000 0012               2875      BRA get_subq_EA
0000295A                          2876      
0000295A                          2877  subq_eight                  ;   SUBQ supports 1-8 (000= 8)
0000295A  1AFC 0038               2878      MOVE.B  #EIGHT_, (A5)+  ;
0000295E  1AFC 002C               2879      MOVE.B  #COMMA, (A5)+   ;   
00002962  1AFC 0020               2880      MOVE.B  #SPACE, (A5)+   ;
00002966  6000 0002               2881      BRA get_subq_EA         ;
0000296A                          2882      
0000296A                          2883  get_subq_EA
0000296A  3005                    2884      MOVE.W  D5, D0          ;   move opcode into d0
0000296C  3C3C 0038               2885      MOVE.W  #$0038, D6      ;   bitmask to get mode bits
00002970  1E3C 0003               2886      MOVE.B  #3, D7          ;   number to shift after masking
00002974  6100 1454               2887      BSR get_bit             ;   get these bits in d0
00002978  3200                    2888      MOVE.W  D0, D1          ;   move mode bits into d1
0000297A                          2889      
0000297A  3005                    2890      MOVE.W  D5, D0          ;   move the opcode into d0 again
0000297C  3C3C 0007               2891      MOVE.W  #$0007, D6      ;   mask for last three bits
00002980  3E3C 0000               2892      MOVE.W  #0, D7          ;   no shift needed
00002984  6100 1444               2893      BSR get_bit             ;   get register bits in d0
00002988                          2894      
00002988                          2895  *************************This section refers to code used above for NEG***********
00002988  0C41 0000               2896      CMPI.W  #$00, D1        ;   check if mode bits are 000 
0000298C  6700 F76E               2897      BEQ neg_Data_reg        ;   branch to (Dn)
00002990                          2898      
00002990  0C41 0001               2899      CMPI.W  #$01, D1        ;   check if mode bits are 001
00002994  6700 002A               2900      BEQ subq_add_an
00002998                          2901      
00002998  0C41 0002               2902      CMPI.W  #$02, D1        ;   check if mode bits are 010
0000299C  6700 F76A               2903      BEQ neg_Addr_paren      ;   branch to add (An)   
000029A0                          2904      
000029A0  0C41 0003               2905      CMPI.W  #$03, D1        ;   check if mode bits are 011
000029A4  6700 F776               2906      BEQ neg_Addr_paren_plus ;   branch to add (An)+
000029A8                          2907      
000029A8  0C41 0004               2908      CMPI.W  #$04, D1        ;   check if mode bits are 100
000029AC  6700 F786               2909      BEQ neg_Addr_paren_minus   ;    branch to add -(An)
000029B0                          2910  
000029B0  0C41 0007               2911      CMPI.w  #$07, D1        ;   Check if mode bits are 111
000029B4  6700 F796               2912      BEQ neg_ea              ;   branch to check if W or L
000029B8                          2913      
000029B8  4CDF 2000               2914      MOVEM.L (A7)+, A5       ;   Restore A5  from the stack  
000029BC  6000 E7F0               2915      BRA invalid_code        ;   invalid code 
000029C0                          2916      
000029C0                          2917  subq_add_an
000029C0  1AFC 0041               2918      MOVE.B #A_, (A5)+       ;   Add 'A'
000029C4  6100 1434               2919      BSR put_number          ;   Add register num (from d0)
000029C8                          2920      
000029C8  6000 EB6C               2921      BRA ori_done            ;   finished
000029CC                          2922      
000029CC                          2923  
000029CC                          2924  * six_start ***********************
000029CC                          2925  BRA_function 
000029CC  48E7 0004               2926      MOVEM.L A5, -(A7)   ;   save A5 in the stack (pointer to result message)  
000029D0  204E                    2927      MOVEA.L A6, A0      ;   starting address of temp      
000029D2  2A4E                    2928      MOVEA.L A6, A5      ;   move starting address of curent temp Message into A0
000029D4                          2929  
000029D4                          2930  
000029D4  1AFC 0042               2931      MOVE.B  #B_, (A5)+  ;   
000029D8  1AFC 0052               2932      MOVE.B  #R_, (A5)+  ;   
000029DC  1AFC 0041               2933      MOVE.B  #A_, (A5)+  ;   
000029E0  1AFC 0009               2934      MOVE.B  #TAB, (A5)+    ;   
000029E4                          2935      * get source mode and register in D1 and D0 
000029E4  3005                    2936      MOVE.W  D5, D0      ;   copy opcode into D0 
000029E6  3C3C 00FF               2937      MOVE.W  #$00FF, D6  ;   bit mask in D6    
000029EA  1E3C 0000               2938      MOVE.B  #0, D7      ;   shift value after masking   
000029EE  6100 13DA               2939      BSR get_bit         ;   masked opcode in D0
000029F2                          2940      
000029F2                          2941  bra_check   
000029F2  0C00 0000               2942      CMPI.B  #$00, D0    ;   if last 8 bits are $00  
000029F6  6000 0012               2943      BRA bra_word        ;   go to word branch   
000029FA                          2944      
000029FA  0C00 00FF               2945      CMPI.B  #$FF, D0    ;   if last 8bits are $FF   
000029FE  6000 0014               2946      BRA bra_long        ;   go to long branch   
00002A02                          2947      
00002A02                          2948      * otherwise add current opcode number += D0 (8bit displacement) 
00002A02  320A                    2949      MOVE.W  A2, D1  ;     
00002A04  D081                    2950      ADD.L   D1, D0  ;   opcode += 8bit displacement -> D0   ;   
00002A06  6000 0016               2951      BRA bra_end ;   
00002A0A                          2952      
00002A0A                          2953      
00002A0A                          2954  bra_word    
00002A0A  320A                    2955      MOVE.W  A2, D1          ;       
00002A0C  301A                    2956      MOVE.W   (A2)+, D0      ;
00002A0E  D081                    2957      ADD.L   D1, D0          ; Add displacement and current opcode address   
00002A10                          2958        
00002A10  6000 000C               2959      BRA bra_end             ;   
00002A14                          2960  
00002A14                          2961  bra_long    
00002A14  320A                    2962      MOVE.W  A2, D1          ;    
00002A16  201A                    2963      MOVE.L  (A2)+, D0       ;
00002A18  D081                    2964      ADD.L   D1, D0          ; Add displacement and current opcode address   
00002A1A                          2965        
00002A1A  6000 0002               2966      BRA bra_end             ;   
00002A1E                          2967  
00002A1E                          2968  bra_end  
00002A1E  1AFC 0024               2969      MOVE.B  #DOLLAR, (A5)+  ;       
00002A22  2C40                    2970      MOVEA.L D0, A6          ;   
00002A24  323C 0008               2971      MOVE.W  #long, D1       ;   
00002A28  48E7 0480               2972      MOVEM.L D5/A0, -(A7)    ;  
00002A2C  6100 E846               2973      BSR hex_to_string       ; put hex address of displacement + opcode into temp message       
00002A30  4CDF 0120               2974      MOVEM.L (A7)+, D5/A0    ;
00002A34                          2975  
00002A34  6000 EB00               2976      BRA ori_done            ;   
00002A38                          2977  
00002A38                          2978  BCC_function    
00002A38  48E7 0004               2979      MOVEM.L A5, -(A7)   ;   save A5 in the stack (pointer to result message)  
00002A3C  204E                    2980      MOVEA.L A6, A0      ;   starting address of temp      
00002A3E  2A4E                    2981      MOVEA.L A6, A5      ;   move starting address of curent temp Message into A0
00002A40                          2982  
00002A40                          2983  
00002A40  1AFC 0042               2984      MOVE.B  #B_, (A5)+  ;   
00002A44  1AFC 0043               2985      MOVE.B  #C_, (A5)+  ;   
00002A48  1AFC 0043               2986      MOVE.B  #C_, (A5)+  ;   
00002A4C  1AFC 0009               2987      MOVE.B  #TAB, (A5)+    ;   
00002A50                          2988      * get source mode and register in D1 and D0 
00002A50  3005                    2989      MOVE.W  D5, D0      ;   copy opcode into D0 
00002A52  3C3C 00FF               2990      MOVE.W  #$00FF, D6  ;   bit mask in D6    
00002A56  1E3C 0000               2991      MOVE.B  #0, D7      ;   shift value after masking   
00002A5A  6100 136E               2992      BSR get_bit         ;   masked opcode in D0
00002A5E                          2993  
00002A5E  6092                    2994      BRA bra_check       ;    
00002A60                          2995  
00002A60                          2996  BCS_function 
00002A60  48E7 0004               2997      MOVEM.L A5, -(A7)   ;   save A5 in the stack (pointer to result message)  
00002A64  204E                    2998      MOVEA.L A6, A0      ;   starting address of temp      
00002A66  2A4E                    2999      MOVEA.L A6, A5      ;   move starting address of curent temp Message into A0
00002A68                          3000  
00002A68                          3001  
00002A68  1AFC 0042               3002      MOVE.B  #B_, (A5)+  ;   
00002A6C  1AFC 0043               3003      MOVE.B  #C_, (A5)+  ;   
00002A70  1AFC 0053               3004      MOVE.B  #S_, (A5)+  ;   
00002A74  1AFC 0009               3005      MOVE.B  #TAB, (A5)+    ;   
00002A78                          3006      * get source mode and register in D1 and D0 
00002A78  3005                    3007      MOVE.W  D5, D0      ;   copy opcode into D0 
00002A7A  3C3C 00FF               3008      MOVE.W  #$00FF, D6  ;   bit mask in D6    
00002A7E  1E3C 0000               3009      MOVE.B  #0, D7      ;   shift value after masking   
00002A82  6100 1346               3010      BSR get_bit         ;   masked opcode in D0
00002A86                          3011  
00002A86  6000 FF6A               3012      BRA bra_check       ;    
00002A8A                          3013  
00002A8A                          3014  BVC_function    
00002A8A  48E7 0004               3015      MOVEM.L A5, -(A7)   ;   save A5 in the stack (pointer to result message)  
00002A8E  204E                    3016      MOVEA.L A6, A0      ;   starting address of temp      
00002A90  2A4E                    3017      MOVEA.L A6, A5      ;   move starting address of curent temp Message into A0
00002A92                          3018  
00002A92                          3019  
00002A92  1AFC 0042               3020      MOVE.B  #B_, (A5)+  ;   
00002A96  1AFC 0056               3021      MOVE.B  #V_, (A5)+  ;   
00002A9A  1AFC 0043               3022      MOVE.B  #C_, (A5)+  ;   
00002A9E  1AFC 0009               3023      MOVE.B  #TAB, (A5)+    ;   
00002AA2                          3024      * get source mode and register in D1 and D0 
00002AA2  3005                    3025      MOVE.W  D5, D0      ;   copy opcode into D0 
00002AA4  3C3C 00FF               3026      MOVE.W  #$00FF, D6  ;   bit mask in D6    
00002AA8  1E3C 0000               3027      MOVE.B  #0, D7      ;   shift value after masking   
00002AAC  6100 131C               3028      BSR get_bit         ;   masked opcode in D0
00002AB0                          3029  
00002AB0  6000 FF40               3030      BRA bra_check       ;    
00002AB4                          3031      
00002AB4                          3032  BGE_function    
00002AB4  48E7 0004               3033      MOVEM.L A5, -(A7)   ;   save A5 in the stack (pointer to result message)  
00002AB8  204E                    3034      MOVEA.L A6, A0      ;   starting address of temp      
00002ABA  2A4E                    3035      MOVEA.L A6, A5      ;   move starting address of curent temp Message into A0
00002ABC                          3036  
00002ABC                          3037  
00002ABC  1AFC 0042               3038      MOVE.B  #B_, (A5)+  ;   
00002AC0  1AFC 0047               3039      MOVE.B  #G_, (A5)+  ;   
00002AC4  1AFC 0045               3040      MOVE.B  #E_, (A5)+  ;   
00002AC8  1AFC 0009               3041      MOVE.B  #TAB, (A5)+    ;   
00002ACC                          3042      * get source mode and register in D1 and D0 
00002ACC  3005                    3043      MOVE.W  D5, D0      ;   copy opcode into D0 
00002ACE  3C3C 00FF               3044      MOVE.W  #$00FF, D6  ;   bit mask in D6    
00002AD2  1E3C 0000               3045      MOVE.B  #0, D7      ;   shift value after masking   
00002AD6  6100 12F2               3046      BSR get_bit         ;   masked opcode in D0
00002ADA                          3047  
00002ADA  6000 FF16               3048      BRA bra_check       ;    
00002ADE                          3049      
00002ADE                          3050  BLT_function    
00002ADE  48E7 0004               3051      MOVEM.L A5, -(A7)   ;   save A5 in the stack (pointer to result message)  
00002AE2  204E                    3052      MOVEA.L A6, A0      ;   starting address of temp      
00002AE4  2A4E                    3053      MOVEA.L A6, A5      ;   move starting address of curent temp Message into A0
00002AE6                          3054  
00002AE6                          3055  
00002AE6  1AFC 0042               3056      MOVE.B  #B_, (A5)+  ;   
00002AEA  1AFC 004C               3057      MOVE.B  #L_, (A5)+  ;   
00002AEE  1AFC 0054               3058      MOVE.B  #T_, (A5)+  ;   
00002AF2  1AFC 0009               3059      MOVE.B  #TAB, (A5)+    ;   
00002AF6                          3060      * get source mode and register in D1 and D0 
00002AF6  3005                    3061      MOVE.W  D5, D0      ;   copy opcode into D0 
00002AF8  3C3C 00FF               3062      MOVE.W  #$00FF, D6  ;   bit mask in D6    
00002AFC  1E3C 0000               3063      MOVE.B  #0, D7      ;   shift value after masking   
00002B00  6100 12C8               3064      BSR get_bit         ;   masked opcode in D0
00002B04                          3065  
00002B04  6000 FEEC               3066      BRA bra_check       ;    
00002B08                          3067  
00002B08                          3068  * eight_start *********************** 
00002B08                          3069  OR_DIVS_W   
00002B08  48E7 0004               3070      MOVEM.L A5, -(A7)   ;    save A5 in the stack (pointer to result message)  
00002B0C  204E                    3071      MOVEA.L A6, A0      ;   starting address of temp      
00002B0E  2A4E                    3072      MOVEA.L A6, A5      ;   move starting address of curent temp Message into A0 
00002B10                          3073      
00002B10                          3074  *decipher from or or divs.w
00002B10  3005                    3075      MOVE.W  D5, D0      ;   move the opcode into d0
00002B12  3C3C 01C0               3076      MOVE.W  #$01C0, D6  ;   move the bitmask into d6
00002B16  1E3C 0006               3077      MOVE.B  #6, D7      ;   intended shift after masking into d7
00002B1A  6100 12AE               3078      BSR get_bit         ;   get the opmode returned in d0
00002B1E                          3079      
00002B1E  0C00 0007               3080      CMPI.B  #$07, D0    ;   is it DIVS.W
00002B22  6700 007C               3081      BEQ divs_w
00002B26  6000 0002               3082      BRA or
00002B2A                          3083      
00002B2A                          3084  or
00002B2A  1AFC 004F               3085      MOVE.B  #O_, (A5)+
00002B2E  1AFC 0052               3086      MOVE.B  #R_, (A5)+
00002B32                          3087      
00002B32  3400                    3088      MOVE.W  D0, D2          ;   copy the opmod into D2
00002B34                          3089      
00002B34  3005                    3090      MOVE.W  D5, D0          ;   move opcode into d0
00002B36  3C3C 0E00               3091      MOVE.W  #$0E00, D6      ;   bitmask to get register bits
00002B3A  1E3C 0009               3092      MOVE.B  #9, D7          ;   number to shift after masking
00002B3E  6100 128A               3093      BSR get_bit             ;   get these bits in d0
00002B42  3200                    3094      MOVE.W  D0, D1          ;   copy the register into D1
00002B44                          3095      
00002B44  3005                    3096      MOVE.W  D5, D0          ;   move opcode into d0
00002B46  3C3C 0038               3097      MOVE.W  #$0038, D6      ;   bitmask to get mode bits
00002B4A  1E3C 0003               3098      MOVE.B  #3, D7          ;   number to shift after masking
00002B4E  6100 127A               3099      BSR get_bit             ;   get these bits in d0
00002B52  3600                    3100      MOVE.W  D0, D3          ;   move EA mode bits into d3
00002B54                          3101      
00002B54  3005                    3102      MOVE.W  D5, D0          ;   move the opcode into d0 again
00002B56  3C3C 0007               3103      MOVE.W  #$0007, D6      ;   mask for last three bits
00002B5A  3E3C 0000               3104      MOVE.W  #0, D7          ;   no shift needed
00002B5E  6100 126A               3105      BSR get_bit             ;   get EA register bits in d4
00002B62  3800                    3106      MOVE.W  D0,D4           ;   move into d4
00002B64                          3107      
00002B64                          3108      *if EA mode is 001- An- invalid code (OR identical to ADD except doesn't
00002B64                          3109      *support An
00002B64  0C03 0001               3110      CMPI.B  #$01, D3
00002B68  6700 0E98               3111      BEQ add_invalid
00002B6C                          3112      
00002B6C  0C02 0000               3113      CMPI.B  #0, D2  
00002B70  6700 0894               3114      BEQ add_byte_sourceEA
00002B74  0C02 0001               3115      CMPI.B  #1, D2
00002B78  6700 08A4               3116      BEQ add_word_sourceEA
00002B7C  0C02 0002               3117      CMPI.B  #2, D2
00002B80  6700 08AC               3118      BEQ add_long_sourceEA
00002B84  0C02 0004               3119      CMPI.B  #4, D2  
00002B88  6700 08B4               3120      BEQ add_byte_destEA
00002B8C  0C02 0005               3121      CMPI.B  #5, D2  
00002B90  6700 08C4               3122      BEQ add_word_destEA
00002B94  0C02 0006               3123      CMPI.B  #6, D2  
00002B98  6700 08CC               3124      BEQ add_long_destEA
00002B9C                          3125      
00002B9C  6000 0E64               3126      BRA add_invalid
00002BA0                          3127      
00002BA0                          3128  *****end of or****
00002BA0                          3129  
00002BA0                          3130  *DIVS.W and MULS.W are identical in structure except for their first four bits
00002BA0                          3131  *This function reuses functions from muls.w 
00002BA0                          3132  divs_w  
00002BA0  3400                    3133      MOVE.W  D0, D2          ;   copy the opmod into D2
00002BA2                          3134      
00002BA2  0C02 0007               3135      CMPI.B  #7, D2  
00002BA6  6700 0006               3136      BEQ keep_DIVS_W
00002BAA  6000 E602               3137      BRA invalid_code  
00002BAE                          3138  
00002BAE                          3139  keep_DIVS_W 
00002BAE  1AFC 0044               3140      MOVE.B  #D_, (A5)+  
00002BB2  1AFC 0049               3141      MOVE.B  #I_, (A5)+  
00002BB6  1AFC 0056               3142      MOVE.B  #V_, (A5)+  
00002BBA  1AFC 0053               3143      MOVE.B  #S_, (A5)+  
00002BBE  1AFC 002E               3144      MOVE.B  #PERIOD, (A5)+  
00002BC2  1AFC 0057               3145      MOVE.B  #W_, (A5)+
00002BC6  1AFC 0009               3146      MOVE.B  #TAB, (A5)+  
00002BCA                          3147      
00002BCA  3005                    3148      MOVE.W  D5, D0          ;   move opcode into d0
00002BCC  3C3C 0E00               3149      MOVE.W  #$0E00, D6      ;   bitmask to get register bits
00002BD0  1E3C 0009               3150      MOVE.B  #9, D7          ;   number to shift after masking
00002BD4  6100 11F4               3151      BSR get_bit             ;   get these bits in d0
00002BD8  3200                    3152      MOVE.W  D0, D1          ;   copy the register into D1
00002BDA                          3153      
00002BDA  3005                    3154      MOVE.W  D5, D0          ;   move opcode into d0
00002BDC  3C3C 0038               3155      MOVE.W  #$0038, D6      ;   bitmask to get mode bits
00002BE0  1E3C 0003               3156      MOVE.B  #3, D7          ;   number to shift after masking
00002BE4  6100 11E4               3157      BSR get_bit             ;   get these bits in d0
00002BE8  3600                    3158      MOVE.W  D0, D3          ;   move EA mode bits into d3
00002BEA                          3159      
00002BEA  3005                    3160      MOVE.W  D5, D0          ;   move the opcode into d0 again
00002BEC  3C3C 0007               3161      MOVE.W  #$0007, D6      ;   mask for last three bits
00002BF0  3E3C 0000               3162      MOVE.W  #0, D7          ;   no shift needed
00002BF4  6100 11D4               3163      BSR get_bit             ;   get EA register bits in d4
00002BF8  3800                    3164      MOVE.W  D0,D4           ;   move into d4
00002BFA                          3165      
00002BFA  6000 05C8               3166      BRA MULS_W_ea            * branch to MULS function for EA and Dn
00002BFE                          3167      
00002BFE                          3168  * nine_start ***********************
00002BFE                          3169  SUB_function    
00002BFE  48E7 0004               3170      MOVEM.L A5, -(A7)     ;    save A5 in the stack (pointer to result message)  
00002C02  204E                    3171      MOVEA.L A6, A0      ;   starting address of temp      
00002C04  2A4E                    3172      MOVEA.L A6, A5      ;   move starting address of curent temp Message into A0
00002C06                          3173      
00002C06                          3174      *Move SUB. into the temporary result*********
00002C06  1AFC 0053               3175      MOVE.B  #S_, (A5)+
00002C0A  1AFC 0055               3176      MOVE.B  #U_, (A5)+
00002C0E  1AFC 0042               3177      MOVE.B  #B_, (A5)+
00002C12                          3178      
00002C12  3005                    3179      MOVE.W  D5, D0          ;   move opcode into d0
00002C14  3C3C 0E00               3180      MOVE.W  #$0E00, D6      ;   bitmask to get register bits
00002C18  1E3C 0009               3181      MOVE.B  #9, D7          ;   number to shift after masking
00002C1C  6100 11AC               3182      BSR get_bit             ;   get these bits in d0
00002C20  3200                    3183      MOVE.W  D0, D1          ;   copy the register into D1
00002C22                          3184      
00002C22  3005                    3185      MOVE.W  D5, D0      ;   move the opcode into d0
00002C24  3C3C 01C0               3186      MOVE.W  #$01C0, D6  ;   move the bitmask into d6
00002C28  1E3C 0006               3187      MOVE.B  #6, D7      ;   intended shift after masking into d7
00002C2C  6100 119C               3188      BSR get_bit         ;   get the opmode returned in d0
00002C30  1400                    3189      MOVE.B  D0,D2       ;   move into d2
00002C32                          3190  
00002C32  3005                    3191      MOVE.W  D5, D0          ;   move opcode into d0
00002C34  3C3C 0038               3192      MOVE.W  #$0038, D6      ;   bitmask to get mode bits
00002C38  1E3C 0003               3193      MOVE.B  #3, D7          ;   number to shift after masking
00002C3C  6100 118C               3194      BSR get_bit             ;   get these bits in d0
00002C40  3600                    3195      MOVE.W  D0, D3          ;   move EA mode bits into D3
00002C42                          3196      
00002C42  3005                    3197      MOVE.W  D5, D0          ;   move the opcode into d0 again
00002C44  3C3C 0007               3198      MOVE.W  #$0007, D6      ;   mask for last three bits
00002C48  3E3C 0000               3199      MOVE.W  #0, D7          ;   no shift needed
00002C4C  6100 117C               3200      BSR get_bit             ;   get EA register bits in D4
00002C50  3800                    3201      MOVE.W  D0,D4           ;   move into D4
00002C52                          3202  
00002C52  0C02 0000               3203      CMPI.B  #0, D2  
00002C56  6700 07AE               3204      BEQ add_byte_sourceEA
00002C5A  0C02 0001               3205      CMPI.B  #1, D2
00002C5E  6700 07BE               3206      BEQ add_word_sourceEA
00002C62  0C02 0002               3207      CMPI.B  #2, D2
00002C66  6700 07C6               3208      BEQ add_long_sourceEA
00002C6A  0C02 0004               3209      CMPI.B  #4, D2  
00002C6E  6700 07CE               3210      BEQ add_byte_destEA
00002C72  0C02 0005               3211      CMPI.B  #5, D2  
00002C76  6700 07DE               3212      BEQ add_word_destEA
00002C7A  0C02 0006               3213      CMPI.B  #6, D2  
00002C7E  6700 07E6               3214      BEQ add_long_destEA
00002C82                          3215  
00002C82  6000 0D7E               3216      BRA add_invalid  
00002C86                          3217       
00002C86                          3218  
00002C86                          3219      
00002C86                          3220  * B_start   ***********************
00002C86                          3221  EOR_CMP 
00002C86  48E7 0004               3222      MOVEM.L A5, -(A7)     ;    save A5 in the stack (pointer to result message)  
00002C8A  204E                    3223      MOVEA.L A6, A0      ;   starting address of temp      
00002C8C  2A4E                    3224      MOVEA.L A6, A5      ;   move starting address of curent temp Message into A0
00002C8E                          3225      
00002C8E                          3226  
00002C8E  3005                    3227      MOVE.W  D5, D0  
00002C90  EF48                    3228      LSL.W   #7, D0  
00002C92  3C3C E000               3229      MOVE.W  #$E000, D6  
00002C96  1E3C 000D               3230      MOVE.B  #13, D7 
00002C9A  6100 112E               3231      BSR get_bit 
00002C9E  3400                    3232      MOVE.W  D0, D2           * copy the value of bits stored in from 8-6 into D2
00002CA0                          3233      
00002CA0  3005                    3234      MOVE.W  D5, D0           
00002CA2  E948                    3235      LSL.W   #4, D0  
00002CA4  3C3C E000               3236      MOVE.W  #$E000, D6  
00002CA8  1E3C 000D               3237      MOVE.B  #13, D7
00002CAC  6100 111C               3238      BSR get_bit
00002CB0  3200                    3239      MOVE.W  D0, D1  *       copy the register into D1
00002CB2                          3240              
00002CB2  3005                    3241      MOVE.W  D5, D0  
00002CB4  E148                    3242      LSL.W   #8, D0 
00002CB6  E548                    3243      LSL.W   #2, D0   
00002CB8  3C3C E000               3244      MOVE.W  #$E000, D6  
00002CBC  1E3C 000D               3245      MOVE.B  #13, D7 
00002CC0  6100 1108               3246      BSR get_bit
00002CC4  3600                    3247      MOVE.W  D0, D3           * copy the EA MODE into D3
00002CC6                          3248      
00002CC6  3005                    3249      MOVE.W  D5, D0  
00002CC8  E148                    3250      LSL.W   #8, D0
00002CCA  EB48                    3251      LSL.W   #5, D0  
00002CCC  3C3C E000               3252      MOVE.W  #$E000, D6  
00002CD0  1E3C 000D               3253      MOVE.B  #13, D7 
00002CD4  6100 10F4               3254      BSR get_bit
00002CD8  3800                    3255      MOVE.W  D0, D4           * copy the EA Register into D4    
00002CDA                          3256   
00002CDA  0C02 0000               3257      CMPI.B  #0, D2  
00002CDE  6700 002E               3258      BEQ CMP_B_  
00002CE2  0C02 0001               3259      CMPI.B  #1, D2
00002CE6  6700 0042               3260      BEQ CMP_W_    
00002CEA  0C02 0002               3261      CMPI.B  #2, D2
00002CEE  6700 0056               3262      BEQ CMP_L_    
00002CF2  0C02 0004               3263      CMPI.B  #4, D2
00002CF6  6700 006A               3264      BEQ EOR_B_    
00002CFA  0C02 0005               3265      CMPI.B  #5, D2
00002CFE  6700 007E               3266      BEQ EOR_W_   
00002D02  0C02 0006               3267      CMPI.B  #6, D2
00002D06  6700 0092               3268      BEQ EOR_L_    
00002D0A  6000 E4A2               3269      BRA invalid_code
00002D0E                          3270  
00002D0E                          3271  CMP_B_
00002D0E  1AFC 0043               3272      MOVE.B  #C_, (A5)+  
00002D12  1AFC 004D               3273      MOVE.B  #M_, (A5)+  
00002D16  1AFC 0050               3274      MOVE.B  #P_, (A5)+  
00002D1A  1AFC 002E               3275      MOVE.B  #PERIOD, (A5)+  
00002D1E  1AFC 0042               3276      MOVE.B  #B_, (A5)+  
00002D22  1AFC 0009               3277      MOVE.B  #TAB, (A5)+ 
00002D26  6000 008E               3278      BRA CMP_EA  
00002D2A                          3279      
00002D2A                          3280  CMP_W_
00002D2A  1AFC 0043               3281      MOVE.B  #C_, (A5)+  
00002D2E  1AFC 004D               3282      MOVE.B  #M_, (A5)+  
00002D32  1AFC 0050               3283      MOVE.B  #P_, (A5)+  
00002D36  1AFC 002E               3284      MOVE.B  #PERIOD, (A5)+  
00002D3A  1AFC 0057               3285      MOVE.B  #W_, (A5)+      
00002D3E  1AFC 0009               3286      MOVE.B  #TAB, (A5)+     
00002D42  6000 0072               3287      BRA CMP_EA  
00002D46                          3288  
00002D46                          3289  CMP_L_  
00002D46  1AFC 0043               3290          MOVE.B  #C_, (A5)+    
00002D4A  1AFC 004D               3291          MOVE.B  #M_, (A5)+     
00002D4E  1AFC 0050               3292          MOVE.B  #P_, (A5)+  
00002D52  1AFC 002E               3293          MOVE.B  #PERIOD, (A5)+  
00002D56  1AFC 004C               3294          MOVE.B  #L_, (A5)+  
00002D5A  1AFC 0009               3295          MOVE.B  #TAB, (A5)+         
00002D5E  6000 0056               3296          BRA CMP_EA
00002D62                          3297        
00002D62                          3298  EOR_B_
00002D62  1AFC 0045               3299      MOVE.B  #E_, (A5)+  
00002D66  1AFC 004F               3300      MOVE.B  #O_, (A5)+  
00002D6A  1AFC 0052               3301      MOVE.B  #R_, (A5)+  
00002D6E  1AFC 002E               3302      MOVE.B  #PERIOD, (A5)+  
00002D72  1AFC 0042               3303      MOVE.B  #B_, (A5)+  
00002D76  1AFC 0009               3304      MOVE.B  #TAB, (A5)+
00002D7A  6000 0268               3305      BRA EOR_EA  
00002D7E                          3306      
00002D7E                          3307  EOR_W_
00002D7E  1AFC 0045               3308      MOVE.B  #E_, (A5)+  
00002D82  1AFC 004F               3309      MOVE.B  #O_, (A5)+  
00002D86  1AFC 0052               3310      MOVE.B  #R_, (A5)+  
00002D8A  1AFC 002E               3311      MOVE.B  #PERIOD, (A5)+  
00002D8E  1AFC 0057               3312      MOVE.B  #W_, (A5)+  
00002D92  1AFC 0009               3313      MOVE.B  #TAB, (A5)+  
00002D96  6000 024C               3314      BRA EOR_EA  
00002D9A                          3315      
00002D9A                          3316  EOR_L_
00002D9A  1AFC 0045               3317      MOVE.B  #E_, (A5)+  
00002D9E  1AFC 004F               3318      MOVE.B  #O_, (A5)+  
00002DA2  1AFC 0052               3319      MOVE.B  #R_, (A5)+  
00002DA6  1AFC 002E               3320      MOVE.B  #PERIOD, (A5)+  
00002DAA  1AFC 004C               3321      MOVE.B  #L_, (A5)+  
00002DAE  1AFC 0009               3322      MOVE.B  #TAB, (A5)+  
00002DB2  6000 0230               3323      BRA EOR_EA  
00002DB6                          3324      
00002DB6                          3325  CMP_EA
00002DB6                          3326       * check mode if it's valid 
00002DB6                          3327       * addressing Mode is Dn
00002DB6  0C03 0000               3328          CMPI.B  #0, D3  
00002DBA  6700 002E               3329          BEQ CMP_Dn
00002DBE                          3330            
00002DBE  0C03 0001               3331           CMPI.B #1, D3  
00002DC2  6700 0046               3332           BEQ    CMP_An
00002DC6                          3333      
00002DC6                          3334          * addressing Mode is (An)
00002DC6  0C03 0002               3335         CMPI.B  #2, D3
00002DCA  6700 005E               3336          BEQ CMP_indirect_An  
00002DCE                          3337          
00002DCE                          3338          * addressing Mode is (An)+
00002DCE  0C03 0003               3339          CMPI.B  #3, D3  
00002DD2  6700 007E               3340          BEQ CMP_An_plus
00002DD6                          3341          
00002DD6                          3342          * addressing Mode is -(An)
00002DD6  0C03 0004               3343          CMPI.B  #4, D3  
00002DDA  6700 00A2               3344          BEQ CMP_Minus_An
00002DDE                          3345          
00002DDE                          3346          * addressing Mode is either (xxx).W or (xxx).L
00002DDE  0C03 0007               3347          CMPI.B  #7, D3 
00002DE2  6700 00C6               3348          BEQ CMP_word_long_data  
00002DE6  6000 0338               3349          BRA CMP_EOR_invalid
00002DEA                          3350     
00002DEA                          3351   
00002DEA                          3352  CMP_Dn
00002DEA  1AFC 0044               3353          MOVE.B  #D_, (A5)+
00002DEE  1004                    3354          MOVE.B  D4, D0
00002DF0  6100 1008               3355          BSR put_number
00002DF4  1AFC 002C               3356          MOVE.B  #COMMA, (A5)+
00002DF8  1AFC 0020               3357          MOVE.B  #SPACE, (A5)+            
00002DFC  1AFC 0044               3358          MOVE.B  #D_, (A5)+
00002E00  1001                    3359          MOVE.B  D1, D0  
00002E02  6100 0FF6               3360          BSR put_number    
00002E06  6000 0320               3361          BRA CMP_done  
00002E0A                          3362         
00002E0A                          3363         
00002E0A                          3364  CMP_An
00002E0A  1AFC 0041               3365      MOVE.B  #A_, (A5)+
00002E0E  1004                    3366      MOVE.B  D4, D0
00002E10  6100 0FE8               3367      BSR put_number
00002E14  1AFC 002C               3368      MOVE.B  #COMMA, (A5)+
00002E18  1AFC 0020               3369      MOVE.B  #SPACE, (A5)+
00002E1C  1AFC 0044               3370      MOVE.B  #D_, (A5)+
00002E20  1001                    3371      MOVE.B  D1, D0  
00002E22  6100 0FD6               3372      BSR put_number
00002E26  6000 0300               3373      BRA CMP_done         
00002E2A                          3374         
00002E2A                          3375  CMP_indirect_An
00002E2A  1AFC 0028               3376      MOVE.B  #Open_paren, (A5)+
00002E2E  1AFC 0041               3377      MOVE.B  #A_, (A5)+
00002E32  1004                    3378      MOVE.B  D4, D0
00002E34  6100 0FC4               3379      BSR put_number
00002E38  1AFC 0029               3380      MOVE.B  #Close_paren, (A5)+
00002E3C  1AFC 002C               3381      MOVE.B  #COMMA, (A5)+
00002E40  1AFC 0020               3382      MOVE.B  #SPACE, (A5)+
00002E44  1AFC 0044               3383      MOVE.B  #D_, (A5)+
00002E48  1001                    3384      MOVE.B  D1, D0  
00002E4A  6100 0FAE               3385      BSR put_number
00002E4E  6000 02D8               3386      BRA CMP_done  
00002E52                          3387    
00002E52                          3388  CMP_An_plus 
00002E52  1AFC 0028               3389      MOVE.B  #Open_paren, (A5)+
00002E56  1AFC 0041               3390      MOVE.B  #A_, (A5)+
00002E5A  1004                    3391      MOVE.B  D4, D0
00002E5C  6100 0F9C               3392      BSR put_number
00002E60  1AFC 0029               3393      MOVE.B  #Close_paren, (A5)+
00002E64  1AFC 002B               3394      MOVE.B  #PLUS, (A5)+
00002E68  1AFC 002C               3395      MOVE.B  #COMMA, (A5)+
00002E6C  1AFC 0020               3396      MOVE.B  #SPACE, (A5)+       
00002E70  1AFC 0044               3397      MOVE.B  #D_, (A5)+
00002E74  1001                    3398      MOVE.B  D1, D0  
00002E76  6100 0F82               3399      BSR put_number  
00002E7A  6000 02AC               3400      BRA CMP_done
00002E7E                          3401      
00002E7E                          3402  CMP_Minus_An
00002E7E  1AFC 002D               3403      MOVE.B  #MINUS, (A5)+
00002E82  1AFC 0028               3404      MOVE.B  #Open_paren, (A5)+
00002E86  1AFC 0041               3405      MOVE.B  #A_, (A5)+
00002E8A  1004                    3406      MOVE.B  D4, D0
00002E8C  6100 0F6C               3407      BSR put_number
00002E90  1AFC 0029               3408      MOVE.B  #Close_paren, (A5)+
00002E94  1AFC 002C               3409      MOVE.B  #COMMA, (A5)+
00002E98  1AFC 0020               3410      MOVE.B  #SPACE, (A5)+       
00002E9C  1AFC 0044               3411      MOVE.B  #D_, (A5)+
00002EA0  1001                    3412      MOVE.B  D1, D0
00002EA2  6100 0F56               3413      BSR put_number        
00002EA6  6000 0280               3414      BRA CMP_done
00002EAA                          3415  
00002EAA                          3416  CMP_word_long_data
00002EAA  0C04 0000               3417      CMPI.B  #0, D4
00002EAE  6700 0016               3418      BEQ CMP_word
00002EB2  0C04 0001               3419      CMPI.B  #1, D4
00002EB6  6700 003C               3420      BEQ CMP_long
00002EBA  0C04 0004               3421      CMPI.B  #4, D4  
00002EBE  6700 0062               3422      BEQ CMP_data    
00002EC2  6000 025C               3423      BRA CMP_EOR_invalid
00002EC6                          3424      
00002EC6                          3425  CMP_word
00002EC6  1E01                    3426      MOVE.B  D1, D7    
00002EC8  1AFC 0024               3427      MOVE.B  #DOLLAR, (A5)+
00002ECC  3C5A                    3428      MOVEA.W (A2)+, A6   
00002ECE  323C 0004               3429      MOVE.W  #word, D1   
00002ED2  48E7 0080               3430      MOVEM.L A0, -(A7) 
00002ED6  6100 E39C               3431      BSR hex_to_string 
00002EDA  1AFC 002C               3432      MOVE.B  #COMMA, (A5)+
00002EDE  1AFC 0020               3433      MOVE.B  #SPACE, (A5)+    
00002EE2  1AFC 0044               3434      MOVE.B  #D_,    (A5)+
00002EE6  1007                    3435      MOVE.B  D7, D0  
00002EE8  6100 0F10               3436      BSR put_number  
00002EEC  4CDF 0100               3437      MOVEM.L (A7)+, A0   
00002EF0  6000 0236               3438      BRA CMP_done      
00002EF4                          3439      
00002EF4                          3440  CMP_long 
00002EF4  1E01                    3441      MOVE.B  D1, D7  
00002EF6  1AFC 0024               3442      MOVE.B  #DOLLAR, (A5)+  
00002EFA  2C5A                    3443      MOVEA.L (A2)+, A6   
00002EFC  323C 0008               3444      MOVE.W  #long, D1   
00002F00  48E7 0080               3445      MOVEM.L A0, -(A7)   
00002F04  6100 E36E               3446      BSR hex_to_string    
00002F08  1AFC 002C               3447      MOVE.B  #COMMA, (A5)+   
00002F0C  1AFC 0020               3448      MOVE.B  #SPACE, (A5)+   
00002F10  4CDF 0100               3449      MOVEM.L (A7)+, A0   
00002F14  1AFC 0044               3450      MOVE.B  #D_, (A5)+  
00002F18  1007                    3451      MOVE.B  D7, D0  
00002F1A  6100 0EDE               3452      BSR put_number  
00002F1E  6000 0208               3453      BRA CMP_done
00002F22                          3454  
00002F22                          3455  CMP_data
00002F22  0C02 0000               3456      CMPI.B  #0, D2  
00002F26  6700 0016               3457      BEQ CMP_data_byte    
00002F2A  0C02 0001               3458      CMPI.B  #1, D2  
00002F2E  6700 0050               3459      BEQ CMP_data_word    
00002F32  0C02 0002               3460      CMPI.B  #2, D2  
00002F36  6700 007A               3461      BEQ CMP_data_long    
00002F3A                          3462      
00002F3A  6000 01E4               3463      BRA CMP_EOR_invalid        
00002F3E                          3464  
00002F3E                          3465  CMP_data_byte
00002F3E  1E01                    3466      MOVE.B  D1, D7  
00002F40  1AFC 0023               3467      MOVE.B  #SHARP, (A5)+   ;   
00002F44  1AFC 0024               3468      MOVE.B  #DOLLAR, (A5)+ ; 
00002F48  3C5A                    3469      MOVEA.W (A2)+, A6      ;
00002F4A                          3470      
00002F4A                          3471      * check if first 8 bits are 0s  
00002F4A  220E                    3472      MOVE.L  A6, D1      ;   
00002F4C  E049                    3473      LSR.W   #8, D1      ;   shift right 8   
00002F4E  0C01 0000               3474      CMPI.B  #$00, D1    ;   if $00 is starting bits 
00002F52  6700 0006               3475      BEQ CMP_valid
00002F56  6000 01C8               3476      BRA CMP_EOR_invalid      
00002F5A                          3477  
00002F5A                          3478  CMP_valid
00002F5A  123C 0002               3479      MOVE.B  #byte, D1   ;   
00002F5E  48E7 0480               3480      MOVEM.L D5/A0, -(A7)  
00002F62  6100 E310               3481      BSR hex_to_string   ; 
00002F66  4CDF 0120               3482      MOVEM.L (A7)+, D5/A0   ; 
00002F6A  1AFC 002C               3483      MOVE.B  #COMMA, (A5)+   
00002F6E  1AFC 0020               3484      MOVE.B  #SPACE, (A5)+  
00002F72  1AFC 0044               3485      MOVE.B  #D_, (A5)+  
00002F76  1007                    3486      MOVE.B  D7, D0  
00002F78  6100 0E80               3487      BSR put_number    
00002F7C  6000 01AA               3488      BRA CMP_done      
00002F80                          3489     
00002F80                          3490  CMP_data_word     
00002F80  1E01                    3491      MOVE.B  D1, D7  
00002F82  1AFC 0023               3492      MOVE.B  #SHARP, (A5)+   ;   
00002F86  1AFC 0024               3493      MOVE.B  #DOLLAR, (A5)+ ; 
00002F8A  3C5A                    3494      MOVEA.W (A2)+, A6      ;   
00002F8C  323C 0004               3495      MOVE.W  #word, D1   ;   
00002F90  48E7 0480               3496      MOVEM.L D5/A0, -(A7)  
00002F94  6100 E2DE               3497      BSR hex_to_string   ; 
00002F98  4CDF 0120               3498      MOVEM.L (A7)+, D5/A0   ; 
00002F9C  1AFC 002C               3499      MOVE.B  #COMMA, (A5)+   
00002FA0  1AFC 0020               3500      MOVE.B  #SPACE, (A5)+  
00002FA4  1AFC 0044               3501      MOVE.B  #D_, (A5)+  
00002FA8  1007                    3502      MOVE.B  D7, D0  
00002FAA  6100 0E4E               3503      BSR put_number    
00002FAE  6000 0178               3504      BRA CMP_done    
00002FB2                          3505   
00002FB2                          3506  CMP_data_long
00002FB2  1E01                    3507      MOVE.B  D1, D7       
00002FB4  1AFC 0023               3508      MOVE.B  #SHARP, (A5)+   ;   
00002FB8  1AFC 0024               3509      MOVE.B  #DOLLAR, (A5)+ ; 
00002FBC  2C5A                    3510      MOVEA.L (A2)+, A6      ;   
00002FBE  323C 0008               3511      MOVE.W  #long, D1   ;   
00002FC2  48E7 0480               3512      MOVEM.L D5/A0, -(A7)  
00002FC6  6100 E2AC               3513      BSR hex_to_string   ; 
00002FCA  4CDF 0120               3514      MOVEM.L (A7)+, D5/A0   ; 
00002FCE  1AFC 002C               3515      MOVE.B  #COMMA, (A5)+   
00002FD2  1AFC 0020               3516      MOVE.B  #SPACE, (A5)+  
00002FD6  1AFC 0044               3517      MOVE.B  #D_, (A5)+  
00002FDA  1007                    3518      MOVE.B  D7, D0  
00002FDC  6100 0E1C               3519      BSR put_number    
00002FE0  6000 0146               3520      BRA CMP_done    
00002FE4                          3521  
00002FE4                          3522  EOR_EA  
00002FE4                          3523       * check mode if it's valid 
00002FE4                          3524       * addressing Mode is Dn
00002FE4  0C03 0000               3525      CMPI.B  #0, D3  
00002FE8  6700 0026               3526      BEQ EOR_Dn
00002FEC                          3527                  
00002FEC                          3528      * addressing Mode is (An)
00002FEC  0C03 0002               3529      CMPI.B  #2, D3
00002FF0  6700 003E               3530      BEQ EOR_indirect_An  
00002FF4                          3531          
00002FF4                          3532          * addressing Mode is (An)+
00002FF4  0C03 0003               3533      CMPI.B  #3, D3  
00002FF8  6700 005E               3534     BEQ EOR_An_plus
00002FFC                          3535          
00002FFC                          3536          * addressing Mode is -(An)
00002FFC  0C03 0004               3537       CMPI.B  #4, D3  
00003000  6700 0082               3538      BEQ EOR_Minus_An
00003004                          3539          
00003004                          3540          * addressing Mode is either (xxx).W or (xxx).L
00003004  0C03 0007               3541      CMPI.B  #7, D3 
00003008  6700 00A6               3542      BEQ EOR_word_long
0000300C  6000 0112               3543       BRA CMP_EOR_invalid     
00003010                          3544   
00003010                          3545  EOR_Dn
00003010  1AFC 0044               3546      MOVE.B  #D_, (A5)+
00003014  1001                    3547      MOVE.B  D1, D0  
00003016  6100 0DE2               3548      BSR put_number
0000301A  1AFC 002C               3549      MOVE.B  #COMMA, (A5)+
0000301E  1AFC 0020               3550      MOVE.B  #SPACE, (A5)+
00003022                          3551      
00003022  1AFC 0044               3552      MOVE.B  #D_, (A5)+
00003026  1004                    3553      MOVE.B  D4, D0
00003028  6100 0DD0               3554      BSR put_number
0000302C  6000 00FA               3555      BRA CMP_done  
00003030                          3556         
00003030                          3557  EOR_indirect_An
00003030  1AFC 0044               3558      MOVE.B  #D_, (A5)+
00003034  1001                    3559      MOVE.B  D1, D0  
00003036  6100 0DC2               3560      BSR put_number
0000303A  1AFC 002C               3561      MOVE.B  #COMMA, (A5)+
0000303E  1AFC 0020               3562      MOVE.B  #SPACE, (A5)+
00003042                          3563      
00003042  1AFC 0028               3564      MOVE.B  #Open_paren, (A5)+
00003046  1AFC 0041               3565      MOVE.B  #A_, (A5)+
0000304A  1004                    3566      MOVE.B  D4, D0
0000304C  6100 0DAC               3567      BSR put_number
00003050  1AFC 0029               3568      MOVE.B  #Close_paren, (A5)+  
00003054  6000 00D2               3569      BRA CMP_done  
00003058                          3570    
00003058                          3571  EOR_An_plus
00003058  1AFC 0044               3572      MOVE.B  #D_, (A5)+
0000305C  1001                    3573      MOVE.B  D1, D0  
0000305E  6100 0D9A               3574      BSR put_number
00003062  1AFC 002C               3575      MOVE.B  #COMMA, (A5)+
00003066  1AFC 0020               3576      MOVE.B  #SPACE, (A5)+    
0000306A  1AFC 0028               3577      MOVE.B  #Open_paren, (A5)+
0000306E  1AFC 0041               3578      MOVE.B  #A_, (A5)+
00003072  1004                    3579      MOVE.B  D4, D0
00003074  6100 0D84               3580      BSR put_number
00003078  1AFC 0029               3581      MOVE.B  #Close_paren, (A5)+
0000307C  1AFC 002B               3582      MOVE.B  #PLUS, (A5)+
00003080  6000 00A6               3583      BRA CMP_done
00003084                          3584      
00003084                          3585  EOR_Minus_An
00003084  1AFC 0044               3586      MOVE.B  #D_, (A5)+
00003088  1001                    3587      MOVE.B  D1, D0  
0000308A  6100 0D6E               3588      BSR put_number
0000308E  1AFC 002C               3589      MOVE.B  #COMMA, (A5)+
00003092  1AFC 0020               3590      MOVE.B  #SPACE, (A5)+    
00003096                          3591      
00003096  1AFC 002D               3592      MOVE.B  #MINUS, (A5)+
0000309A  1AFC 0028               3593      MOVE.B  #Open_paren, (A5)+
0000309E  1AFC 0041               3594      MOVE.B  #A_, (A5)+
000030A2  1004                    3595      MOVE.B  D4, D0
000030A4  6100 0D54               3596      BSR put_number
000030A8  1AFC 0029               3597      MOVE.B  #Close_paren, (A5)+
000030AC  6000 007A               3598      BRA CMP_done
000030B0                          3599  
000030B0                          3600  EOR_word_long
000030B0  0C04 0000               3601      CMPI.B  #0, D4
000030B4  6700 000E               3602      BEQ EOR_word
000030B8  0C04 0001               3603      CMPI.B  #1, D4
000030BC  6700 0034               3604      BEQ EOR_long
000030C0  6000 005E               3605      BRA CMP_EOR_invalid
000030C4                          3606  
000030C4                          3607  EOR_word
000030C4  1AFC 0044               3608      MOVE.B  #D_,    (A5)+
000030C8  1007                    3609      MOVE.B  D7, D0  
000030CA  6100 0D2E               3610      BSR put_number  
000030CE  1AFC 002C               3611      MOVE.B  #COMMA, (A5)+
000030D2  1AFC 0020               3612      MOVE.B  #SPACE, (A5)+       
000030D6  1E01                    3613      MOVE.B  D1, D7    
000030D8  1AFC 0024               3614      MOVE.B  #DOLLAR, (A5)+
000030DC  3C5A                    3615      MOVEA.W (A2)+, A6   
000030DE  323C 0004               3616      MOVE.W  #word, D1   
000030E2  48E7 0080               3617      MOVEM.L A0, -(A7) 
000030E6  6100 E18C               3618      BSR hex_to_string 
000030EA  4CDF 0100               3619      MOVEM.L (A7)+, A0   
000030EE  6000 0038               3620      BRA CMP_done      
000030F2                          3621      
000030F2                          3622  EOR_long
000030F2  1AFC 0044               3623      MOVE.B  #D_, (A5)+  
000030F6  1007                    3624      MOVE.B  D7, D0  
000030F8  6100 0D00               3625      BSR put_number  
000030FC  1AFC 002C               3626      MOVE.B  #COMMA, (A5)+   
00003100  1AFC 0020               3627      MOVE.B  #SPACE, (A5)+    
00003104  1E01                    3628      MOVE.B  D1, D7  
00003106  1AFC 0024               3629      MOVE.B  #DOLLAR, (A5)+  
0000310A  2C5A                    3630      MOVEA.L (A2)+, A6   
0000310C  323C 0008               3631      MOVE.W  #long, D1   
00003110  48E7 0080               3632      MOVEM.L A0, -(A7)   
00003114  6100 E15E               3633      BSR hex_to_string     
00003118  4CDF 0100               3634      MOVEM.L (A7)+, A0   
0000311C  6000 000A               3635      BRA CMP_done
00003120                          3636  
00003120                          3637  CMP_EOR_invalid
00003120  4CDF 2000               3638      MOVEM.L (A7)+, A5
00003124  6000 E088               3639      BRA invalid_code  
00003128                          3640      
00003128                          3641  CMP_done   
00003128  2C48                    3642      MOVEA.L A0, A6  
0000312A  4246                    3643      CLR D6  
0000312C                          3644   
0000312C                          3645  CMP_loop
0000312C  BBC8                    3646      CMPA.L  A0, A5  ;   
0000312E  6700 000C               3647      BEQ CMP_message_out 
00003132  5286                    3648      ADDI.L  #1, D6  ;   increment count  
00003134  2A08                    3649      MOVE.L  A0, D5  ;   
00003136  5285                    3650      ADDI.L  #1, D5  ;   
00003138  2045                    3651      MOVEA.L D5, A0  ;   increment address   
0000313A  60F0                    3652      BRA CMP_loop    ;    
0000313C                          3653  
0000313C                          3654  CMP_message_out
0000313C  4CDF 2000               3655      MOVEM.L (A7)+, A5   
00003140  6100 E21C               3656      BSR copy_string 
00003144  6000 E116               3657      BRA decode_end  
00003148                          3658  
00003148                          3659  
00003148                          3660  * C_start       ***********************    
00003148                          3661  MULS_W  
00003148  48E7 0004               3662   MOVEM.L A5, -(A7)     ;    save A5 in the stack (pointer to result message)  
0000314C  204E                    3663      MOVEA.L A6, A0      ;   starting address of temp      
0000314E  2A4E                    3664      MOVEA.L A6, A5      ;   move starting address of curent temp Message into A0
00003150                          3665      
00003150                          3666  
00003150  3005                    3667      MOVE.W  D5, D0  
00003152  EF48                    3668      LSL.W   #7, D0  
00003154  3C3C E000               3669      MOVE.W  #$E000, D6  
00003158  1E3C 000D               3670      MOVE.B  #13, D7 
0000315C  6100 0C6C               3671      BSR get_bit 
00003160  3400                    3672      MOVE.W  D0, D2           * copy the value of bits stored in from 8-6 into D2
00003162                          3673      
00003162  0C02 0007               3674      CMPI.B  #7, D2  
00003166  6700 0006               3675      BEQ keep_MULS_W
0000316A  6000 E042               3676      BRA invalid_code  
0000316E                          3677  
0000316E                          3678  keep_MULS_W 
0000316E  1AFC 004D               3679      MOVE.B  #M_, (A5)+  
00003172  1AFC 0055               3680      MOVE.B  #U_, (A5)+  
00003176  1AFC 004C               3681      MOVE.B  #L_, (A5)+  
0000317A  1AFC 0053               3682      MOVE.B  #S_, (A5)+  
0000317E  1AFC 002E               3683      MOVE.B  #PERIOD, (A5)+  
00003182  1AFC 0057               3684      MOVE.B  #W_, (A5)+
00003186  1AFC 0009               3685      MOVE.B  #TAB, (A5)+  
0000318A                          3686      
0000318A  3005                    3687      MOVE.W  D5, D0           
0000318C  E948                    3688      LSL.W   #4, D0  
0000318E  3C3C E000               3689      MOVE.W  #$E000, D6  
00003192  1E3C 000D               3690      MOVE.B  #13, D7
00003196  6100 0C32               3691      BSR get_bit
0000319A  3200                    3692      MOVE.W  D0, D1  *       copy the register into D1
0000319C                          3693              
0000319C  3005                    3694      MOVE.W  D5, D0  
0000319E  E148                    3695      LSL.W   #8, D0 
000031A0  E548                    3696      LSL.W   #2, D0   
000031A2  3C3C E000               3697      MOVE.W  #$E000, D6  
000031A6  1E3C 000D               3698      MOVE.B  #13, D7 
000031AA  6100 0C1E               3699      BSR get_bit
000031AE  3600                    3700      MOVE.W  D0, D3           * copy the EA MODE into D3
000031B0                          3701      
000031B0  3005                    3702      MOVE.W  D5, D0  
000031B2  E148                    3703      LSL.W   #8, D0
000031B4  EB48                    3704      LSL.W   #5, D0  
000031B6  3C3C E000               3705      MOVE.W  #$E000, D6  
000031BA  1E3C 000D               3706      MOVE.B  #13, D7 
000031BE  6100 0C0A               3707      BSR get_bit
000031C2  3800                    3708      MOVE.W  D0, D4           * copy the EA Register into D4 
000031C4                          3709    
000031C4                          3710  MULS_W_ea
000031C4                          3711      * check mode if it's valid 
000031C4                          3712      * addressing Mode is Dn
000031C4  0C03 0000               3713      CMPI.B  #0, D3  
000031C8  6700 0026               3714      BEQ MULS_W_Dn    
000031CC                          3715      * addressing Mode is (An)
000031CC  0C03 0002               3716      CMPI.B  #2, D3
000031D0  6700 003E               3717      BEQ MULS_W_indirect_An  
000031D4                          3718      * addressing Mode is (An)+
000031D4  0C03 0003               3719      CMPI.B  #3, D3  
000031D8  6700 005E               3720      BEQ MULS_W_An_plus
000031DC                          3721      * addressing Mode is -(An)
000031DC  0C03 0004               3722      CMPI.B  #4, D3  
000031E0  6700 0082               3723      BEQ MULS_W_Minus_An
000031E4                          3724      * addressing Mode is either (xxx).W or (xxx).L
000031E4  0C03 0007               3725      CMPI.B  #7, D3 
000031E8  6700 00A6               3726      BEQ MULS_W_source_word_long_data
000031EC                          3727      
000031EC  6000 014C               3728      BRA MULS_W_invalid 
000031F0                          3729  
000031F0                          3730  MULS_W_Dn
000031F0  1AFC 0044               3731      MOVE.B  #D_, (A5)+
000031F4  1004                    3732      MOVE.B  D4, D0
000031F6  6100 0C02               3733      BSR put_number
000031FA  1AFC 002C               3734      MOVE.B  #COMMA, (A5)+
000031FE  1AFC 0020               3735      MOVE.B  #SPACE, (A5)+
00003202  1AFC 0044               3736      MOVE.B  #D_, (A5)+
00003206  1001                    3737      MOVE.B  D1, D0  
00003208  6100 0BF0               3738      BSR put_number
0000320C  6000 0134               3739      BRA MULS_W_done    
00003210                          3740  
00003210                          3741  MULS_W_indirect_An
00003210  1AFC 0028               3742      MOVE.B  #Open_paren, (A5)+
00003214  1AFC 0041               3743      MOVE.B  #A_, (A5)+
00003218  1004                    3744      MOVE.B  D4, D0
0000321A  6100 0BDE               3745      BSR put_number
0000321E  1AFC 0029               3746      MOVE.B  #Close_paren, (A5)+
00003222  1AFC 002C               3747      MOVE.B  #COMMA, (A5)+
00003226  1AFC 0020               3748      MOVE.B  #SPACE, (A5)+
0000322A  1AFC 0044               3749      MOVE.B  #D_, (A5)+
0000322E  1001                    3750      MOVE.B  D1, D0  
00003230  6100 0BC8               3751      BSR put_number
00003234  6000 010C               3752      BRA MULS_W_done  
00003238                          3753    
00003238                          3754  MULS_W_An_plus
00003238  1AFC 0028               3755      MOVE.B  #Open_paren, (A5)+
0000323C  1AFC 0041               3756      MOVE.B  #A_, (A5)+
00003240  1004                    3757      MOVE.B  D4, D0
00003242  6100 0BB6               3758      BSR put_number
00003246  1AFC 0029               3759      MOVE.B  #Close_paren, (A5)+
0000324A  1AFC 002B               3760      MOVE.B  #PLUS, (A5)+
0000324E  1AFC 002C               3761      MOVE.B  #COMMA, (A5)+
00003252  1AFC 0020               3762      MOVE.B  #SPACE, (A5)+
00003256  1AFC 0044               3763      MOVE.B  #D_, (A5)+
0000325A  1001                    3764      MOVE.B  D1, D0  
0000325C  6100 0B9C               3765      BSR put_number
00003260  6000 00E0               3766      BRA MULS_W_done
00003264                          3767      
00003264                          3768  MULS_W_Minus_An
00003264  1AFC 002D               3769      MOVE.B  #MINUS, (A5)+
00003268  1AFC 0028               3770      MOVE.B  #Open_paren, (A5)+
0000326C  1AFC 0041               3771      MOVE.B  #A_, (A5)+
00003270  1004                    3772      MOVE.B  D4, D0
00003272  6100 0B86               3773      BSR put_number
00003276  1AFC 0029               3774      MOVE.B  #Close_paren, (A5)+
0000327A  1AFC 002C               3775      MOVE.B  #COMMA, (A5)+
0000327E  1AFC 0020               3776      MOVE.B  #SPACE, (A5)+
00003282  1AFC 0044               3777      MOVE.B  #D_, (A5)+
00003286  1001                    3778      MOVE.B  D1, D0  
00003288  6100 0B70               3779      BSR put_number
0000328C  6000 00B4               3780      BRA MULS_W_done
00003290                          3781      
00003290                          3782  MULS_W_source_word_long_data
00003290  0C04 0000               3783      CMPI.B  #0, D4
00003294  6700 0016               3784      BEQ MULS_W_word
00003298  0C04 0001               3785      CMPI.B  #1, D4
0000329C  6700 003C               3786      BEQ MULS_W_long
000032A0  0C04 0004               3787      CMPI.B  #4, D4  
000032A4  6700 0062               3788      BEQ MULS_W_source_data 
000032A8  6000 0090               3789      BRA MULS_W_invalid
000032AC                          3790      
000032AC                          3791  MULS_W_word
000032AC  1E01                    3792      MOVE.B  D1, D7    
000032AE  1AFC 0024               3793      MOVE.B  #DOLLAR, (A5)+
000032B2  3C5A                    3794      MOVEA.W (A2)+, A6   
000032B4  323C 0004               3795      MOVE.W  #word, D1   
000032B8  48E7 0080               3796      MOVEM.L A0, -(A7) 
000032BC  6100 DFB6               3797      BSR hex_to_string 
000032C0  1AFC 002C               3798      MOVE.B  #COMMA, (A5)+
000032C4  1AFC 0020               3799      MOVE.B  #SPACE, (A5)+    
000032C8  1AFC 0044               3800      MOVE.B  #D_,    (A5)+
000032CC  1007                    3801      MOVE.B  D7, D0  
000032CE  6100 0B2A               3802      BSR put_number  
000032D2  4CDF 0100               3803      MOVEM.L (A7)+, A0   
000032D6  6000 006A               3804      BRA MULS_W_done      
000032DA                          3805      
000032DA                          3806  MULS_W_long
000032DA  1E01                    3807      MOVE.B  D1, D7  
000032DC  1AFC 0024               3808      MOVE.B  #DOLLAR, (A5)+  
000032E0  2C5A                    3809      MOVEA.L (A2)+, A6   
000032E2  323C 0008               3810      MOVE.W  #long, D1   
000032E6  48E7 0080               3811      MOVEM.L A0, -(A7)   
000032EA  6100 DF88               3812      BSR hex_to_string     
000032EE  1AFC 002C               3813      MOVE.B  #COMMA, (A5)+   
000032F2  1AFC 0020               3814      MOVE.B  #SPACE, (A5)+
000032F6  1AFC 0044               3815      MOVE.B  #D_, (A5)+  
000032FA  1007                    3816      MOVE.B  D7, D0  
000032FC  6100 0AFC               3817      BSR put_number  
00003300  4CDF 0100               3818      MOVEM.L (A7)+, A0   
00003304  6000 003C               3819      BRA MULS_W_done
00003308                          3820  
00003308                          3821  MULS_W_source_data  
00003308  1E01                    3822      MOVE.B  D1, D7
0000330A  1AFC 0023               3823      MOVE.B  #SHARP, (A5)+   ;   
0000330E  1AFC 0024               3824      MOVE.B  #DOLLAR, (A5)+ ; 
00003312  3C5A                    3825      MOVEA.W (A2)+, A6      ;   
00003314  323C 0004               3826      MOVE.W  #word, D1   ;   
00003318  48E7 0480               3827      MOVEM.L D5/A0, -(A7)  
0000331C  6100 DF56               3828      BSR hex_to_string   ; 
00003320  4CDF 0120               3829      MOVEM.L (A7)+, D5/A0   ; 
00003324                          3830    
00003324  1AFC 002C               3831      MOVE.B  #COMMA, (A5)+   
00003328  1AFC 0020               3832      MOVE.B  #SPACE, (A5)+  
0000332C  1AFC 0044               3833      MOVE.B  #D_, (A5)+  
00003330  1007                    3834      MOVE.B  D7, D0  
00003332  6100 0AC6               3835      BSR put_number    
00003336  6000 000A               3836      BRA MULS_W_done
0000333A                          3837   
0000333A                          3838  MULS_W_invalid
0000333A  4CDF 2000               3839      MOVEM.L (A7)+, A5
0000333E  6000 DE6E               3840      BRA invalid_code  
00003342                          3841      
00003342                          3842  MULS_W_done   
00003342  2C48                    3843      MOVEA.L A0, A6  
00003344  4246                    3844      CLR D6  
00003346                          3845   
00003346                          3846  MULS_W_loop
00003346  BBC8                    3847      CMPA.L  A0, A5  ;   
00003348  6700 000C               3848      BEQ message_out 
0000334C  5286                    3849      ADDI.L  #1, D6  ;   increment count  
0000334E  2A08                    3850      MOVE.L  A0, D5  ;   
00003350  5285                    3851      ADDI.L  #1, D5  ;   
00003352  2045                    3852      MOVEA.L D5, A0  ;   increment address   
00003354  60F0                    3853      BRA MULS_W_loop    ;    
00003356                          3854  
00003356                          3855  message_out
00003356  4CDF 2000               3856      MOVEM.L (A7)+, A5   
0000335A  6100 E002               3857      BSR copy_string 
0000335E  6000 DEFC               3858      BRA decode_end  
00003362                          3859      
00003362                          3860  * D_start   ***********************
00003362                          3861  ADD_ADDA    
00003362  48E7 0004               3862      MOVEM.L A5, -(A7)     ;    save A5 in the stack (pointer to result message)  
00003366  204E                    3863      MOVEA.L A6, A0          ;   starting address of temp      
00003368  2A4E                    3864      MOVEA.L A6, A5      ;   move starting address of curent temp Message into A0
0000336A                          3865      
0000336A  3005                    3866      MOVE.W  D5, D0            * copy the original opcode into D0
0000336C  E948                    3867      LSL.W   #4, D0  
0000336E  3C3C E000               3868      MOVE.W  #$E000, D6  
00003372  1E3C 000D               3869      MOVE.B  #13, D7
00003376  6100 0A52               3870      BSR get_bit
0000337A  3200                    3871      MOVE.W  D0, D1  *       copy the register into D1
0000337C                          3872      
0000337C  3005                    3873      MOVE.W  D5, D0  
0000337E  EF48                    3874      LSL.W   #7, D0  
00003380  3C3C E000               3875      MOVE.W  #$E000, D6  
00003384  1E3C 000D               3876      MOVE.B  #13, D7 
00003388  6100 0A40               3877      BSR get_bit 
0000338C  3400                    3878      MOVE.W  D0, D2           * copy the opmod into D2
0000338E                          3879      
0000338E  3005                    3880      MOVE.W  D5, D0  
00003390  E148                    3881      LSL.W   #8, D0 
00003392  E548                    3882      LSL.W   #2, D0   
00003394  3C3C E000               3883      MOVE.W  #$E000, D6  
00003398  1E3C 000D               3884      MOVE.B  #13, D7 
0000339C  6100 0A2C               3885      BSR get_bit
000033A0  3600                    3886      MOVE.W  D0, D3           * copy the EA MODE into D3
000033A2                          3887      
000033A2  3005                    3888      MOVE.W  D5, D0  
000033A4  E148                    3889      LSL.W   #8, D0
000033A6  EB48                    3890      LSL.W   #5, D0  
000033A8  3C3C E000               3891      MOVE.W  #$E000, D6  
000033AC  1E3C 000D               3892      MOVE.B  #13, D7 
000033B0  6100 0A18               3893      BSR get_bit
000033B4  3800                    3894      MOVE.W  D0, D4           * copy the EA Register into D4 
000033B6                          3895     
000033B6                          3896      * CHECK THE OPMODE TO CHECK WHICH Operand is EA (either source or destination)
000033B6  1AFC 0041               3897      MOVE.B  #A_, (A5)+
000033BA  1AFC 0044               3898      MOVE.B  #D_, (A5)+  
000033BE  1AFC 0044               3899      MOVE.B  #D_, (A5)+
000033C2                          3900      
000033C2  0C02 0000               3901      CMPI.B  #0, D2  
000033C6  6700 003E               3902      BEQ add_byte_sourceEA
000033CA  0C02 0001               3903      CMPI.B  #1, D2
000033CE  6700 004E               3904      BEQ add_word_sourceEA
000033D2  0C02 0002               3905      CMPI.B  #2, D2
000033D6  6700 0056               3906      BEQ add_long_sourceEA
000033DA  0C02 0004               3907      CMPI.B  #4, D2  
000033DE  6700 005E               3908      BEQ add_byte_destEA
000033E2  0C02 0005               3909      CMPI.B  #5, D2  
000033E6  6700 006E               3910      BEQ add_word_destEA
000033EA  0C02 0006               3911      CMPI.B  #6, D2  
000033EE  6700 0076               3912      BEQ add_long_destEA
000033F2  0C02 0003               3913      CMPI.B  #3, D2  
000033F6  6700 007E               3914      BEQ adda_word
000033FA  0C02 0007               3915      CMPI.B  #7, D2  
000033FE  6700 008A               3916      BEQ adda_long   
00003402  6000 05FE               3917      BRA add_invalid  
00003406                          3918       
00003406                          3919     
00003406                          3920  add_byte_sourceEA
00003406  1AFC 002E               3921      MOVE.B  #PERIOD, (A5)+
0000340A  1AFC 0042               3922      MOVE.B  #B_, (A5)+
0000340E  1AFC 0009               3923      MOVE.B  #TAB, (A5)+
00003412  0C03 0001               3924      CMPI.B  #1, D3  
00003416  6700 05EA               3925      BEQ add_invalid
0000341A  6000 0082               3926      BRA add_source_ea
0000341E                          3927      
0000341E                          3928  add_word_sourceEA
0000341E  1AFC 002E               3929      MOVE.B  #PERIOD, (A5)+
00003422  1AFC 0057               3930      MOVE.B  #W_, (A5)+
00003426  1AFC 0009               3931      MOVE.B  #TAB, (A5)+
0000342A  6000 0072               3932      BRA add_source_ea
0000342E                          3933      
0000342E                          3934  add_long_sourceEA
0000342E  1AFC 002E               3935      MOVE.B  #PERIOD, (A5)+
00003432  1AFC 004C               3936      MOVE.B  #L_, (A5)+
00003436  1AFC 0009               3937      MOVE.B  #TAB, (A5)+
0000343A  6000 0062               3938      BRA add_source_ea
0000343E                          3939      
0000343E                          3940  add_byte_destEA
0000343E  1AFC 002E               3941      MOVE.B  #PERIOD, (A5)+
00003442  1AFC 0042               3942      MOVE.B  #B_, (A5)+
00003446  1AFC 0009               3943      MOVE.B  #TAB, (A5)+
0000344A  0C03 0001               3944      CMPI.B  #1, D3  
0000344E  6700 05B2               3945      BEQ add_invalid    
00003452  6000 007E               3946      BRA add_dest_ea
00003456                          3947      
00003456                          3948  add_word_destEA
00003456  1AFC 002E               3949      MOVE.B  #PERIOD, (A5)+
0000345A  1AFC 0057               3950      MOVE.B  #W_, (A5)+
0000345E  1AFC 0009               3951      MOVE.B  #TAB, (A5)+
00003462  6000 006E               3952      BRA add_dest_ea
00003466                          3953      
00003466                          3954  add_long_destEA  
00003466  1AFC 002E               3955      MOVE.B  #PERIOD, (A5)+  
0000346A  1AFC 004C               3956      MOVE.B  #L_, (A5)+
0000346E  1AFC 0009               3957      MOVE.B  #TAB, (A5)+
00003472  6000 005E               3958      BRA add_dest_ea
00003476                          3959  
00003476                          3960  adda_word    
00003476  1AFC 0041               3961      MOVE.B  #A_, (A5)+
0000347A  1AFC 002E               3962      MOVE.B  #PERIOD, (A5)+    
0000347E  1AFC 0057               3963      MOVE.B  #W_, (A5)+
00003482  1AFC 0009               3964      MOVE.B  #TAB, (A5)+
00003486  6000 006E               3965      BRA adda_source_ea   
0000348A                          3966  
0000348A                          3967  adda_long
0000348A  1AFC 0041               3968      MOVE.B  #A_, (A5)+ 
0000348E  1AFC 002E               3969      MOVE.B  #PERIOD, (A5)+   
00003492  1AFC 004C               3970      MOVE.B  #L_, (A5)+
00003496  1AFC 0009               3971      MOVE.B  #TAB, (A5)+
0000349A  6000 005A               3972      BRA adda_source_ea
0000349E                          3973   
0000349E                          3974  add_source_ea
0000349E                          3975      * check mode if it's valid 
0000349E                          3976      * addressing Mode is Dn
0000349E  0C03 0000               3977      CMPI.B  #0, D3  
000034A2  6700 0086               3978      BEQ add_Dn
000034A6                          3979      * addressing Mode is An    
000034A6  0C03 0001               3980      CMPI.B  #1, D3  
000034AA  6700 009E               3981      BEQ add_An       
000034AE                          3982      * addressing Mode is (An)
000034AE  0C03 0002               3983      CMPI.B  #2, D3
000034B2  6700 00B6               3984      BEQ add_indirect_An  
000034B6                          3985      * addressing Mode is (An)+
000034B6  0C03 0003               3986      CMPI.B  #3, D3  
000034BA  6700 00D6               3987      BEQ add_An_plus
000034BE                          3988      * addressing Mode is -(An)
000034BE  0C03 0004               3989      CMPI.B  #4, D3  
000034C2  6700 00FA               3990      BEQ add_Minus_An
000034C6                          3991      * addressing Mode is either (xxx).W or (xxx).L
000034C6  0C03 0007               3992      CMPI.B  #7, D3 
000034CA  6700 011E               3993      BEQ add_source_word_long_data
000034CE  6000 0532               3994      BRA add_invalid 
000034D2                          3995  
000034D2                          3996  add_dest_ea
000034D2                          3997      * check mode if it's valid        
000034D2                          3998      * addressing Mode is (An)
000034D2  0C03 0002               3999      CMPI.B  #2, D3
000034D6  6700 024C               4000      BEQ add_dest_indirect_An  
000034DA                          4001      * addressing Mode is (An)+
000034DA  0C03 0003               4002      CMPI.B  #3, D3  
000034DE  6700 026C               4003      BEQ add_dest_An_plus
000034E2                          4004      * addressing Mode is -(An)
000034E2  0C03 0004               4005      CMPI.B  #4, D3  
000034E6  6700 0290               4006      BEQ add_dest_Minus_An
000034EA                          4007      * addressing Mode is either (xxx).W or (xxx).L
000034EA  0C03 0007               4008      CMPI.B  #7, D3 
000034EE  6700 02B4               4009      BEQ add_dest_word_long    
000034F2  6000 050E               4010      BRA add_invalid
000034F6                          4011       
000034F6                          4012  adda_source_ea
000034F6                          4013      * check mode if it's valid 
000034F6                          4014      * addressing Mode is Dn
000034F6  0C03 0000               4015      CMPI.B  #0, D3  
000034FA  6700 0318               4016      BEQ adda_Dn
000034FE                          4017      * addressing Mode is An    
000034FE  0C03 0001               4018      CMPI.B  #1, D3  
00003502  6700 0330               4019      BEQ adda_An       
00003506                          4020      * addressing Mode is (An)
00003506  0C03 0002               4021      CMPI.B  #2, D3
0000350A  6700 0348               4022      BEQ adda_indirect_An  
0000350E                          4023      * addressing Mode is (An)+
0000350E  0C03 0003               4024      CMPI.B  #3, D3  
00003512  6700 0368               4025      BEQ adda_An_plus
00003516                          4026      * addressing Mode is -(An)
00003516  0C03 0004               4027      CMPI.B  #4, D3  
0000351A  6700 038C               4028      BEQ adda_Minus_An
0000351E                          4029      * addressing Mode is either (xxx).W or (xxx).L
0000351E  0C03 0007               4030      CMPI.B  #7, D3 
00003522  6700 03B0               4031      BEQ adda_source_word_long
00003526                          4032      
00003526  6000 04DA               4033      BRA add_invalid   
0000352A                          4034  
0000352A                          4035  
0000352A                          4036  
0000352A                          4037      
0000352A                          4038  add_Dn
0000352A  1AFC 0044               4039      MOVE.B  #D_, (A5)+
0000352E  1004                    4040      MOVE.B  D4, D0
00003530  6100 08C8               4041      BSR put_number
00003534  1AFC 002C               4042      MOVE.B  #COMMA, (A5)+
00003538  1AFC 0020               4043      MOVE.B  #SPACE, (A5)+
0000353C  1AFC 0044               4044      MOVE.B  #D_, (A5)+
00003540  1001                    4045      MOVE.B  D1, D0  
00003542  6100 08B6               4046      BSR put_number
00003546  6000 04C2               4047      BRA add_adda_done   
0000354A                          4048      
0000354A                          4049  add_An
0000354A  1AFC 0041               4050      MOVE.B  #A_, (A5)+
0000354E  1004                    4051      MOVE.B  D4, D0
00003550  6100 08A8               4052      BSR put_number
00003554  1AFC 002C               4053      MOVE.B  #COMMA, (A5)+
00003558  1AFC 0020               4054      MOVE.B  #SPACE, (A5)+
0000355C  1AFC 0044               4055      MOVE.B  #D_, (A5)+
00003560  1001                    4056      MOVE.B  D1, D0  
00003562  6100 0896               4057      BSR put_number
00003566  6000 04A2               4058      BRA add_adda_done  
0000356A                          4059  
0000356A                          4060  add_indirect_An
0000356A  1AFC 0028               4061      MOVE.B  #Open_paren, (A5)+
0000356E  1AFC 0041               4062      MOVE.B  #A_, (A5)+
00003572  1004                    4063      MOVE.B  D4, D0
00003574  6100 0884               4064      BSR put_number
00003578  1AFC 0029               4065      MOVE.B  #Close_paren, (A5)+
0000357C  1AFC 002C               4066      MOVE.B  #COMMA, (A5)+
00003580  1AFC 0020               4067      MOVE.B  #SPACE, (A5)+
00003584  1AFC 0044               4068      MOVE.B  #D_, (A5)+
00003588  1001                    4069      MOVE.B  D1, D0  
0000358A  6100 086E               4070      BSR put_number
0000358E  6000 047A               4071      BRA add_adda_done  
00003592                          4072    
00003592                          4073  add_An_plus
00003592  1AFC 0028               4074      MOVE.B  #Open_paren, (A5)+
00003596  1AFC 0041               4075      MOVE.B  #A_, (A5)+
0000359A  1004                    4076      MOVE.B  D4, D0
0000359C  6100 085C               4077      BSR put_number
000035A0  1AFC 0029               4078      MOVE.B  #Close_paren, (A5)+
000035A4  1AFC 002B               4079      MOVE.B  #PLUS, (A5)+
000035A8  1AFC 002C               4080      MOVE.B  #COMMA, (A5)+
000035AC  1AFC 0020               4081      MOVE.B  #SPACE, (A5)+
000035B0  1AFC 0044               4082      MOVE.B  #D_, (A5)+
000035B4  1001                    4083      MOVE.B  D1, D0  
000035B6  6100 0842               4084      BSR put_number
000035BA  6000 044E               4085      BRA add_adda_done
000035BE                          4086      
000035BE                          4087  add_Minus_An
000035BE  1AFC 002D               4088      MOVE.B  #MINUS, (A5)+
000035C2  1AFC 0028               4089      MOVE.B  #Open_paren, (A5)+
000035C6  1AFC 0041               4090      MOVE.B  #A_, (A5)+
000035CA  1004                    4091      MOVE.B  D4, D0
000035CC  6100 082C               4092      BSR put_number
000035D0  1AFC 0029               4093      MOVE.B  #Close_paren, (A5)+
000035D4  1AFC 002C               4094      MOVE.B  #COMMA, (A5)+
000035D8  1AFC 0020               4095      MOVE.B  #SPACE, (A5)+
000035DC  1AFC 0044               4096      MOVE.B  #D_, (A5)+
000035E0  1001                    4097      MOVE.B  D1, D0  
000035E2  6100 0816               4098      BSR put_number
000035E6  6000 0422               4099      BRA add_adda_done
000035EA                          4100      
000035EA                          4101  add_source_word_long_data
000035EA  0C04 0000               4102      CMPI.B  #0, D4
000035EE  6700 0016               4103      BEQ add_word
000035F2  0C04 0001               4104      CMPI.B  #1, D4
000035F6  6700 003C               4105      BEQ add_long
000035FA  0C04 0004               4106      CMPI.B  #4, D4  
000035FE  6700 0062               4107      BEQ add_source_data 
00003602  6000 03FE               4108      BRA add_invalid
00003606                          4109      
00003606                          4110  add_word
00003606  1E01                    4111      MOVE.B  D1, D7    
00003608  1AFC 0024               4112      MOVE.B  #DOLLAR, (A5)+
0000360C  3C5A                    4113      MOVEA.W (A2)+, A6   
0000360E  323C 0004               4114      MOVE.W  #word, D1   
00003612  48E7 0080               4115      MOVEM.L A0, -(A7) 
00003616  6100 DC5C               4116      BSR hex_to_string 
0000361A  1AFC 002C               4117      MOVE.B  #COMMA, (A5)+
0000361E  1AFC 0020               4118      MOVE.B  #SPACE, (A5)+    
00003622  1AFC 0044               4119      MOVE.B  #D_,    (A5)+
00003626  1007                    4120      MOVE.B  D7, D0  
00003628  6100 07D0               4121      BSR put_number  
0000362C  4CDF 0100               4122      MOVEM.L (A7)+, A0   
00003630  6000 03D8               4123      BRA add_adda_done      
00003634                          4124      
00003634                          4125  add_long
00003634                          4126  
00003634  1E01                    4127      MOVE.B  D1, D7  
00003636  1AFC 0024               4128      MOVE.B  #DOLLAR, (A5)+  
0000363A  2C5A                    4129      MOVEA.L (A2)+, A6   
0000363C  323C 0008               4130      MOVE.W  #long, D1   
00003640  48E7 0080               4131      MOVEM.L A0, -(A7)   
00003644  6100 DC2E               4132      BSR hex_to_string     
00003648  1AFC 002C               4133      MOVE.B  #COMMA, (A5)+   
0000364C  1AFC 0020               4134      MOVE.B  #SPACE, (A5)+
00003650  1AFC 0044               4135      MOVE.B  #D_, (A5)+  
00003654  1007                    4136      MOVE.B  D7, D0  
00003656  6100 07A2               4137      BSR put_number  
0000365A  4CDF 0100               4138      MOVEM.L (A7)+, A0   
0000365E  6000 03AA               4139      BRA add_adda_done
00003662                          4140       
00003662                          4141  add_source_data
00003662  0C02 0000               4142      CMPI.B  #0, D2  
00003666  6700 0016               4143      BEQ add_source_data_byte    
0000366A  0C02 0001               4144      CMPI.B  #1, D2  
0000366E  6700 0050               4145      BEQ add_source_data_word    
00003672  0C02 0002               4146      CMPI.B  #2, D2  
00003676  6700 007A               4147      BEQ add_source_data_long    
0000367A                          4148      
0000367A  6000 0386               4149      BRA add_invalid       
0000367E                          4150  
0000367E                          4151  add_source_data_byte
0000367E  1E01                    4152      MOVE.B  D1, D7   
00003680  1AFC 0023               4153      MOVE.B  #SHARP, (A5)+       ; read more opcode word size      
00003684  1AFC 0024               4154      MOVE.B  #DOLLAR, (A5)+      ; 
00003688  3C5A                    4155      MOVEA.W (A2)+, A6           ;   
0000368A                          4156      * check if first 8 bits are 0s  
0000368A  220E                    4157      MOVE.L  A6, D1      ;   
0000368C  E049                    4158      LSR.W   #8, D1      ;   shift right 8   
0000368E  0C01 0000               4159      CMPI.B  #$00, D1    ;   if $00 is starting bits 
00003692  6700 0006               4160      BEQ ADD_source_valid
00003696  6000 036A               4161      BRA ADD_invalid      
0000369A                          4162  
0000369A                          4163  ADD_source_valid
0000369A  323C 0002               4164      MOVE.W  #byte, D1           ;   
0000369E  48E7 0480               4165      MOVEM.L D5/A0, -(A7)        ;
000036A2  6100 DBD0               4166      BSR hex_to_string           ;   
000036A6  4CDF 0120               4167      MOVEM.L (A7)+, D5/A0        ;
000036AA                          4168      
000036AA  1AFC 002C               4169      MOVE.B  #COMMA, (A5)+   
000036AE  1AFC 0020               4170      MOVE.B  #SPACE, (A5)+  
000036B2  1AFC 0044               4171      MOVE.B  #D_, (A5)+  
000036B6  1007                    4172      MOVE.B  D7, D0  
000036B8  6100 0740               4173      BSR put_number     
000036BC  6000 034C               4174      BRA add_adda_done    
000036C0                          4175      
000036C0                          4176  add_source_data_word  
000036C0  1E01                    4177      MOVE.B  D1, D7
000036C2  1AFC 0023               4178      MOVE.B  #SHARP, (A5)+   ;   
000036C6  1AFC 0024               4179      MOVE.B  #DOLLAR, (A5)+ ; 
000036CA  3C5A                    4180      MOVEA.W (A2)+, A6      ;   
000036CC  323C 0004               4181      MOVE.W  #word, D1   ;   
000036D0  48E7 0480               4182      MOVEM.L D5/A0, -(A7)  
000036D4  6100 DB9E               4183      BSR hex_to_string   ; 
000036D8  4CDF 0120               4184      MOVEM.L (A7)+, D5/A0   ;
000036DC                          4185      
000036DC                          4186      
000036DC  1AFC 002C               4187      MOVE.B  #COMMA, (A5)+   
000036E0  1AFC 0020               4188      MOVE.B  #SPACE, (A5)+
000036E4  1AFC 0044               4189      MOVE.B  #D_, (A5)+  
000036E8  1007                    4190      MOVE.B  D7, D0  
000036EA  6100 070E               4191      BSR put_number 
000036EE  6000 031A               4192      BRA add_adda_done
000036F2                          4193   
000036F2                          4194  add_source_data_long     
000036F2  1E01                    4195      MOVE.B  D1, D7
000036F4  1AFC 0023               4196      MOVE.B  #SHARP, (A5)+   ;   
000036F8  1AFC 0024               4197      MOVE.B  #DOLLAR, (A5)+ ; 
000036FC  3C5A                    4198      MOVEA.W (A2)+, A6      ;   
000036FE  323C 0008               4199      MOVE.W  #long, D1   ;   
00003702  48E7 0480               4200      MOVEM.L D5/A0, -(A7)  
00003706  6100 DB6C               4201      BSR hex_to_string   ; 
0000370A  4CDF 0120               4202      MOVEM.L (A7)+, D5/A0   ;
0000370E  1AFC 002C               4203      MOVE.B  #COMMA, (A5)+   
00003712  1AFC 0020               4204      MOVE.B  #SPACE, (A5)+
00003716  1AFC 0044               4205      MOVE.B  #D_, (A5)+  
0000371A  1007                    4206      MOVE.B  D7, D0  
0000371C  6100 06DC               4207      BSR put_number 
00003720  6000 02E8               4208      BRA add_adda_done
00003724                          4209    
00003724                          4210        
00003724                          4211  add_dest_indirect_An
00003724  1AFC 0044               4212      MOVE.B  #D_, (A5)+
00003728  1001                    4213      MOVE.B  D1, D0  
0000372A  6100 06CE               4214      BSR put_number
0000372E  1AFC 002C               4215      MOVE.B  #COMMA, (A5)+
00003732  1AFC 0020               4216      MOVE.B  #SPACE, (A5)+
00003736  1AFC 0028               4217      MOVE.B  #Open_paren, (A5)+
0000373A  1AFC 0041               4218      MOVE.B  #A_, (A5)+
0000373E  1004                    4219      MOVE.B  D4, D0
00003740  6100 06B8               4220      BSR put_number
00003744  1AFC 0029               4221      MOVE.B  #Close_paren, (A5)+    
00003748  6000 02C0               4222      BRA add_adda_done  
0000374C                          4223    
0000374C                          4224  add_dest_An_plus
0000374C  1AFC 0044               4225      MOVE.B  #D_, (A5)+
00003750  1001                    4226      MOVE.B  D1, D0  
00003752  6100 06A6               4227      BSR put_number
00003756  1AFC 002C               4228      MOVE.B  #COMMA, (A5)+
0000375A  1AFC 0020               4229      MOVE.B  #SPACE, (A5)+    
0000375E  1AFC 0028               4230      MOVE.B  #Open_paren, (A5)+
00003762  1AFC 0041               4231      MOVE.B  #A_, (A5)+
00003766  1004                    4232      MOVE.B  D4, D0
00003768  6100 0690               4233      BSR put_number
0000376C  1AFC 0029               4234      MOVE.B  #Close_paren, (A5)+
00003770  1AFC 002B               4235      MOVE.B  #PLUS, (A5)+
00003774  6000 0294               4236      BRA add_adda_done
00003778                          4237      
00003778                          4238  add_dest_Minus_An
00003778  1AFC 0044               4239      MOVE.B  #D_, (A5)+
0000377C  1001                    4240      MOVE.B  D1, D0  
0000377E  6100 067A               4241      BSR put_number
00003782  1AFC 002C               4242      MOVE.B  #COMMA, (A5)+
00003786  1AFC 0020               4243      MOVE.B  #SPACE, (A5)+    
0000378A  1AFC 002D               4244      MOVE.B  #MINUS, (A5)+
0000378E  1AFC 0028               4245      MOVE.B  #Open_paren, (A5)+
00003792  1AFC 0041               4246      MOVE.B  #A_, (A5)+
00003796  1004                    4247      MOVE.B  D4, D0
00003798  6100 0660               4248      BSR put_number
0000379C  1AFC 0029               4249      MOVE.B  #Close_paren, (A5)+
000037A0  6000 0268               4250      BRA add_adda_done
000037A4                          4251  
000037A4                          4252  add_dest_word_long
000037A4  0C04 0000               4253      CMPI.B  #0, D4
000037A8  6700 000E               4254      BEQ add_dest_word
000037AC  0C04 0001               4255      CMPI.B  #1, D4
000037B0  6700 0034               4256      BEQ add_dest_long
000037B4  6000 024C               4257      BRA add_invalid
000037B8                          4258  
000037B8                          4259  add_dest_word
000037B8  1AFC 0044               4260      MOVE.B  #D_,    (A5)+
000037BC  1001                    4261      MOVE.B  D1, D0  
000037BE  6100 063A               4262      BSR put_number  
000037C2  1AFC 002C               4263      MOVE.B  #COMMA, (A5)+
000037C6  1AFC 0020               4264      MOVE.B  #SPACE, (A5)+       
000037CA  1E01                    4265      MOVE.B  D1, D7    
000037CC  1AFC 0024               4266      MOVE.B  #DOLLAR, (A5)+
000037D0  3C5A                    4267      MOVEA.W (A2)+, A6   
000037D2  323C 0004               4268      MOVE.W  #word, D1   
000037D6  48E7 0080               4269      MOVEM.L A0, -(A7) 
000037DA  6100 DA98               4270      BSR hex_to_string 
000037DE  4CDF 0100               4271      MOVEM.L (A7)+, A0   
000037E2  6000 0226               4272      BRA add_adda_done      
000037E6                          4273      
000037E6                          4274  add_dest_long
000037E6  1AFC 0044               4275      MOVE.B  #D_, (A5)+  
000037EA  1001                    4276      MOVE.B  D1, D0  
000037EC  6100 060C               4277      BSR put_number  
000037F0  1AFC 002C               4278      MOVE.B  #COMMA, (A5)+   
000037F4  1AFC 0020               4279      MOVE.B  #SPACE, (A5)+    
000037F8  1E01                    4280      MOVE.B  D1, D7  
000037FA  1AFC 0024               4281      MOVE.B  #DOLLAR, (A5)+  
000037FE  2C5A                    4282      MOVEA.L (A2)+, A6   
00003800  323C 0008               4283      MOVE.W  #long, D1   
00003804  48E7 0080               4284      MOVEM.L A0, -(A7)   
00003808  6100 DA6A               4285      BSR hex_to_string     
0000380C  4CDF 0100               4286      MOVEM.L (A7)+, A0   
00003810  6000 01F8               4287      BRA add_adda_done
00003814                          4288        
00003814                          4289  adda_Dn
00003814  1AFC 0044               4290      MOVE.B  #D_, (A5)+
00003818  1004                    4291      MOVE.B  D4, D0
0000381A  6100 05DE               4292      BSR put_number
0000381E  1AFC 002C               4293      MOVE.B  #COMMA, (A5)+
00003822  1AFC 0020               4294      MOVE.B  #SPACE, (A5)+
00003826  1AFC 0041               4295      MOVE.B  #A_, (A5)+
0000382A  1001                    4296      MOVE.B  D1, D0  
0000382C  6100 05CC               4297      BSR put_number
00003830  6000 01D8               4298      BRA add_adda_done   
00003834                          4299      
00003834                          4300  adda_An
00003834  1AFC 0041               4301      MOVE.B  #A_, (A5)+
00003838  1004                    4302      MOVE.B  D4, D0
0000383A  6100 05BE               4303      BSR put_number
0000383E  1AFC 002C               4304      MOVE.B  #COMMA, (A5)+
00003842  1AFC 0020               4305      MOVE.B  #SPACE, (A5)+
00003846  1AFC 0041               4306      MOVE.B  #A_, (A5)+
0000384A  1001                    4307      MOVE.B  D1, D0  
0000384C  6100 05AC               4308      BSR put_number
00003850  6000 01B8               4309      BRA add_adda_done  
00003854                          4310  
00003854                          4311  adda_indirect_An
00003854  1AFC 0028               4312      MOVE.B  #Open_paren, (A5)+
00003858  1AFC 0041               4313      MOVE.B  #A_, (A5)+
0000385C  1004                    4314      MOVE.B  D4, D0
0000385E  6100 059A               4315      BSR put_number
00003862  1AFC 0029               4316      MOVE.B  #Close_paren, (A5)+
00003866  1AFC 002C               4317      MOVE.B  #COMMA, (A5)+
0000386A  1AFC 0020               4318      MOVE.B  #SPACE, (A5)+
0000386E  1AFC 0041               4319      MOVE.B  #A_, (A5)+
00003872  1001                    4320      MOVE.B  D1, D0  
00003874  6100 0584               4321      BSR put_number
00003878  6000 0190               4322      BRA add_adda_done  
0000387C                          4323    
0000387C                          4324  adda_An_plus
0000387C  1AFC 0028               4325      MOVE.B  #Open_paren, (A5)+
00003880  1AFC 0041               4326      MOVE.B  #A_, (A5)+
00003884  1004                    4327      MOVE.B  D4, D0
00003886  6100 0572               4328      BSR put_number
0000388A  1AFC 0029               4329      MOVE.B  #Close_paren, (A5)+
0000388E  1AFC 002B               4330      MOVE.B  #PLUS, (A5)+
00003892  1AFC 002C               4331      MOVE.B  #COMMA, (A5)+
00003896  1AFC 0020               4332      MOVE.B  #SPACE, (A5)+
0000389A  1AFC 0041               4333      MOVE.B  #A_, (A5)+
0000389E  1001                    4334      MOVE.B  D1, D0  
000038A0  6100 0558               4335      BSR put_number
000038A4  6000 0164               4336      BRA add_adda_done
000038A8                          4337      
000038A8                          4338  adda_Minus_An
000038A8  1AFC 002D               4339      MOVE.B  #MINUS, (A5)+
000038AC  1AFC 0028               4340      MOVE.B  #Open_paren, (A5)+
000038B0  1AFC 0041               4341      MOVE.B  #A_, (A5)+
000038B4  1004                    4342      MOVE.B  D4, D0
000038B6  6100 0542               4343      BSR put_number
000038BA  1AFC 0029               4344      MOVE.B  #Close_paren, (A5)+
000038BE  1AFC 002C               4345      MOVE.B  #COMMA, (A5)+
000038C2  1AFC 0020               4346      MOVE.B  #SPACE, (A5)+
000038C6  1AFC 0041               4347      MOVE.B  #A_, (A5)+
000038CA  1001                    4348      MOVE.B  D1, D0  
000038CC  6100 052C               4349      BSR put_number
000038D0  6000 0138               4350      BRA add_adda_done
000038D4                          4351      
000038D4                          4352  adda_source_word_long
000038D4  0C04 0000               4353      CMPI.B  #0, D4
000038D8  6700 0016               4354      BEQ adda_word_ea
000038DC  0C04 0001               4355      CMPI.B  #1, D4
000038E0  6700 003C               4356      BEQ adda_long_ea
000038E4  0C04 0004               4357      CMPI.B  #4, D4  
000038E8  6700 0062               4358      BEQ adda_source_data 
000038EC  6000 0114               4359      BRA add_invalid
000038F0                          4360      
000038F0                          4361  adda_word_ea
000038F0  1E01                    4362      MOVE.B  D1, D7    
000038F2  1AFC 0024               4363      MOVE.B  #DOLLAR, (A5)+
000038F6  3C5A                    4364      MOVEA.W (A2)+, A6   
000038F8  323C 0004               4365      MOVE.W  #word, D1   
000038FC  48E7 0080               4366      MOVEM.L A0, -(A7) 
00003900  6100 D972               4367      BSR hex_to_string 
00003904  1AFC 002C               4368      MOVE.B  #COMMA, (A5)+
00003908  1AFC 0020               4369      MOVE.B  #SPACE, (A5)+    
0000390C  1AFC 0041               4370      MOVE.B  #A_,    (A5)+
00003910  1007                    4371      MOVE.B  D7, D0  
00003912  6100 04E6               4372      BSR put_number  
00003916  4CDF 0100               4373      MOVEM.L (A7)+, A0   
0000391A                          4374          
0000391A  6000 00EE               4375      BRA add_adda_done      
0000391E                          4376      
0000391E                          4377      
0000391E                          4378  adda_long_ea
0000391E  1E01                    4379      MOVE.B  D1, D7  
00003920  1AFC 0024               4380      MOVE.B  #DOLLAR, (A5)+  
00003924  2C5A                    4381      MOVEA.L (A2)+, A6   
00003926  323C 0008               4382      MOVE.W  #long, D1   
0000392A  48E7 0080               4383      MOVEM.L A0, -(A7)   
0000392E  6100 D944               4384      BSR hex_to_string     
00003932  1AFC 002C               4385      MOVE.B  #COMMA, (A5)+   
00003936  1AFC 0020               4386      MOVE.B  #SPACE, (A5)+
0000393A  1AFC 0041               4387      MOVE.B  #A_, (A5)+  
0000393E  1007                    4388      MOVE.B  D7, D0  
00003940  6100 04B8               4389      BSR put_number  
00003944  4CDF 0100               4390      MOVEM.L (A7)+, A0   
00003948  6000 00C0               4391      BRA add_adda_done
0000394C                          4392      
0000394C                          4393  adda_source_data  
0000394C  0C02 0003               4394      CMPI.B  #3, D2  
00003950  6700 0050               4395      BEQ adda_source_data_word    
00003954  0C02 0007               4396      CMPI.B  #7, D2  
00003958  6700 0078               4397      BEQ adda_source_data_long    
0000395C                          4398      
0000395C  6000 00A4               4399      BRA add_invalid       
00003960                          4400  
00003960                          4401  adda_source_data_byte
00003960  1E01                    4402      MOVE.B  D1, D7  
00003962  1AFC 0023               4403      MOVE.B  #SHARP, (A5)+       ; read more opcode word size      
00003966  1AFC 0024               4404      MOVE.B  #DOLLAR, (A5)+      ; 
0000396A  3C5A                    4405      MOVEA.W (A2)+, A6           ;   
0000396C                          4406      * check if first 8 bits are 0s  
0000396C  220E                    4407      MOVE.L  A6, D1      ;   
0000396E  E049                    4408      LSR.W   #8, D1      ;   shift right 8   
00003970  0C01 0000               4409      CMPI.B  #$00, D1    ;   if $00 is starting bits 
00003974  6700 0006               4410      BEQ ADDA_source_valid
00003978  6000 0088               4411      BRA ADD_invalid      
0000397C                          4412  
0000397C                          4413  ADDA_source_valid
0000397C  323C 0002               4414      MOVE.W  #byte, D1           ;   
00003980  48E7 0480               4415      MOVEM.L D5/A0, -(A7)        ;
00003984  6100 D8EE               4416      BSR hex_to_string           ;   
00003988  4CDF 0120               4417      MOVEM.L (A7)+, D5/A0        ;
0000398C                          4418   
0000398C  1AFC 002C               4419      MOVE.B  #COMMA, (A5)+   
00003990  1AFC 0020               4420      MOVE.B  #SPACE, (A5)+  
00003994  1AFC 0041               4421      MOVE.B  #A_, (A5)+  
00003998  1007                    4422      MOVE.B  D7, D0  
0000399A  6100 045E               4423      BSR put_number     
0000399E  6000 006A               4424      BRA add_adda_done      
000039A2                          4425  
000039A2                          4426  addA_source_data_word  
000039A2  1AFC 0023               4427      MOVE.B  #SHARP, (A5)+   ;   
000039A6  1AFC 0024               4428      MOVE.B  #DOLLAR, (A5)+ ; 
000039AA  3C5A                    4429      MOVEA.W (A2)+, A6      ;   
000039AC  323C 0004               4430      MOVE.W  #word, D1   ;   
000039B0  48E7 0480               4431      MOVEM.L D5/A0, -(A7)  
000039B4  6100 D8BE               4432      BSR hex_to_string   ; 
000039B8  4CDF 0120               4433      MOVEM.L (A7)+, D5/A0   ;
000039BC                          4434      
000039BC  1AFC 002C               4435      MOVE.B  #COMMA, (A5)+   
000039C0  1AFC 0020               4436      MOVE.B  #SPACE, (A5)+
000039C4  1AFC 0041               4437      MOVE.B  #A_, (A5)+  
000039C8  1007                    4438      MOVE.B  D7, D0  
000039CA  6100 042E               4439      BSR put_number 
000039CE  6000 003A               4440      BRA add_adda_done
000039D2                          4441   
000039D2                          4442  addA_source_data_long     
000039D2  1AFC 0023               4443      MOVE.B  #SHARP, (A5)+   ;   
000039D6  1AFC 0024               4444      MOVE.B  #DOLLAR, (A5)+ ; 
000039DA  3C5A                    4445      MOVEA.W (A2)+, A6      ;   
000039DC  323C 0008               4446      MOVE.W  #long, D1   ;   
000039E0  48E7 0480               4447      MOVEM.L D5/A0, -(A7)  
000039E4  6100 D88E               4448      BSR hex_to_string   ; 
000039E8  4CDF 0120               4449      MOVEM.L (A7)+, D5/A0   ;
000039EC  1AFC 002C               4450      MOVE.B  #COMMA, (A5)+   
000039F0  1AFC 0020               4451      MOVE.B  #SPACE, (A5)+
000039F4  1AFC 0041               4452      MOVE.B  #A_, (A5)+  
000039F8  1007                    4453      MOVE.B  D7, D0  
000039FA  6100 03FE               4454      BSR put_number 
000039FE  6000 000A               4455      BRA add_adda_done
00003A02                          4456    
00003A02                          4457      
00003A02                          4458      
00003A02                          4459  add_invalid
00003A02  4CDF 2000               4460      MOVEM.L (A7)+, A5
00003A06  6000 D7A6               4461      BRA invalid_code  
00003A0A                          4462      
00003A0A                          4463  add_adda_done   
00003A0A  2C48                    4464      MOVEA.L A0, A6  
00003A0C  4246                    4465      CLR D6  
00003A0E                          4466   
00003A0E                          4467  add_adda_loop
00003A0E  BBC8                    4468      CMPA.L  A0, A5  ;   
00003A10  6700 000C               4469      BEQ add_adda_message_out 
00003A14  5286                    4470      ADDI.L  #1, D6  ;   increment count  
00003A16  2A08                    4471      MOVE.L  A0, D5  ;   
00003A18  5285                    4472      ADDI.L  #1, D5  ;   
00003A1A  2045                    4473      MOVEA.L D5, A0  ;   increment address   
00003A1C  60F0                    4474      BRA add_adda_loop    ;    
00003A1E                          4475  
00003A1E                          4476  add_adda_message_out
00003A1E  4CDF 2000               4477      MOVEM.L (A7)+, A5   
00003A22  6100 D93A               4478      BSR copy_string 
00003A26  6000 D834               4479      BRA decode_end  
00003A2A                          4480      
00003A2A                          4481  *   E_start     ******************************
00003A2A                          4482  
00003A2A                          4483  ASLR_LSLR_ROLR
00003A2A  48E7 0004               4484      MOVEM.L A5, -(A7)     ;    save A5 in the stack (pointer to result message)  
00003A2E  204E                    4485      MOVEA.L A6, A0      ;   starting address of temp      
00003A30  2A4E                    4486      MOVEA.L A6, A5      ;   move starting address of curent temp Message into A0
00003A32                          4487      
00003A32                          4488      * check the shifting type whether it's memory shifting or not with size bits
00003A32                          4489     
00003A32  3005                    4490      MOVE.W  D5, D0            * copy the original opcode into D0
00003A34  E948                    4491      LSL.W   #4, D0            * Shift 4 bits to the left, so we can read next three bits of count/register num
00003A36  3C3C E000               4492      MOVE.W  #$E000, D6       * copy data to be used for bit masking into D2    
00003A3A  1E3C 000D               4493      MOVE.B  #13, D7          * copy parameter that indicates a number of bits to shift into D3   
00003A3E  6100 038A               4494      BSR get_bit              
00003A42  3200                    4495      MOVE.W  D0,D1              * now we have either count or data register three bits in D1   
00003A44                          4496      
00003A44  3005                    4497      MOVE.W  D5, D0  
00003A46  EF48                    4498      LSL.W   #7, D0  
00003A48  3C3C 8000               4499      MOVE.W  #$8000, D6    
00003A4C  1E3C 000F               4500      MOVE.B  #15, D7  
00003A50  6100 0378               4501      BSR get_bit 
00003A54  3400                    4502      MOVE.W  D0, D2   * copy the value for direction into D2    
00003A56                          4503  
00003A56  3005                    4504      MOVE.W  D5, D0  
00003A58  E148                    4505      LSL.W   #8, D0  
00003A5A  3C3C C000               4506      MOVE.W  #$C000, D6  
00003A5E  1E3C 000E               4507      MOVE.B  #14, D7 
00003A62  6100 0366               4508      BSR get_bit 
00003A66  3600                    4509      MOVE.W  D0, D3         * copy the value for size into D3   
00003A68                          4510  
00003A68  3005                    4511      MOVE.W  D5,  D0 
00003A6A  E148                    4512      LSL.W   #8, D0 
00003A6C  E548                    4513      LSL.W   #2, D0 
00003A6E  3C3C 8000               4514      MOVE.W  #$8000, D6  
00003A72  3E3C 000F               4515      MOVE.W  #15, D7 
00003A76  6100 0352               4516      BSR get_bit 
00003A7A  3800                    4517      MOVE.W  D0,  D4    * copy the value for i/r into D4    
00003A7C                          4518      
00003A7C  3005                    4519      MOVE.W  D5, D0  
00003A7E  E148                    4520      LSL.W   #8, D0
00003A80  E748                    4521      LSL.W   #3, D0  
00003A82  3C3C C000               4522      MOVE.W  #$C000, D6  
00003A86  3E3C 000E               4523      MOVE.W  #14, D7 
00003A8A  6100 033E               4524      BSR get_bit 
00003A8E  3C00                    4525      MOVE.W  D0, D6 * copy the value for the type into D6
00003A90                          4526             
00003A90  3005                    4527      MOVE.W  D5, D0
00003A92  E148                    4528      LSL.W   #8, D0
00003A94  EB48                    4529      LSL.W   #5, D0   * keep the register value into D0    
00003A96  E048                    4530      LSR.W   #8, D0
00003A98  EA48                    4531      LSR.W   #5, D0   
00003A9A                          4532  
00003A9A  0C03 0003               4533      CMPI.B  #3, D3    * check if it's memory shifting or not
00003A9E  6700 0154               4534      BEQ memory_shift       
00003AA2  0C06 0000               4535      CMPI.B  #0, D6    * AS register shift
00003AA6  6700 0016               4536      BEQ as_shift  
00003AAA  0C06 0001               4537      CMPI.B  #1, D6    * LS register shift
00003AAE  6700 0104               4538      BEQ ls_shift    
00003AB2  0C06 0003               4539      CMPI.B  #3, D6    * RO rigister shift
00003AB6  6700 0118               4540      BEQ ro_shift
00003ABA  6000 D6F2               4541      BRA invalid_code         
00003ABE                          4542       
00003ABE                          4543  as_shift
00003ABE  1AFC 0041               4544      MOVE.B  #A_, (A5)+  
00003AC2  1AFC 0053               4545      MOVE.B  #S_, (A5)+     
00003AC6  0C02 0000               4546      CMPI.B  #0, D2    
00003ACA  6700 000E               4547      BEQ as_ls_ro_right 
00003ACE  0C02 0001               4548      CMPI.B  #1, D2    
00003AD2  6700 0012               4549      BEQ as_ls_ro_left
00003AD6  6000 0114               4550      BRA as_ls_ro_invalid    
00003ADA                          4551      
00003ADA                          4552  as_ls_ro_right
00003ADA  1AFC 0052               4553      MOVE.B  #R_, (A5)+  
00003ADE  1AFC 002E               4554      MOVE.B  #PERIOD, (A5)+   
00003AE2  6000 000E               4555      BRA as_ls_ro_size
00003AE6                          4556      
00003AE6                          4557  as_ls_ro_left
00003AE6  1AFC 004C               4558      MOVE.B  #L_, (A5)+      
00003AEA  1AFC 002E               4559      MOVE.B  #PERIOD, (A5)+   
00003AEE  6000 0002               4560      BRA as_ls_ro_size
00003AF2                          4561      
00003AF2                          4562      
00003AF2                          4563  as_ls_ro_size
00003AF2  0C03 0000               4564      CMPI.B  #$00, D3    
00003AF6  6700 0016               4565      BEQ byte_shift  
00003AFA  0C03 0001               4566      CMPI.B  #1, D3    
00003AFE  6700 001A               4567      BEQ word_shift  
00003B02  0C03 0002               4568      CMPI.B  #2, D3    
00003B06  6700 001E               4569      BEQ long_shift  
00003B0A                          4570  
00003B0A  6000 00E0               4571      BRA as_ls_ro_invalid         
00003B0E                          4572  
00003B0E                          4573  
00003B0E                          4574      
00003B0E                          4575  byte_shift
00003B0E  1AFC 0042               4576      MOVE.B  #B_, (A5)+  
00003B12  1AFC 0009               4577      MOVE.B  #TAB, (A5)+ 
00003B16  6000 001A               4578      BRA check_ir_bit   
00003B1A                          4579   
00003B1A                          4580  word_shift
00003B1A  1AFC 0057               4581      MOVE.B  #W_, (A5)+  
00003B1E  1AFC 0009               4582      MOVE.B  #TAB, (A5)+ 
00003B22  6000 000E               4583      BRA check_ir_bit  
00003B26                          4584      
00003B26                          4585  long_shift
00003B26  1AFC 004C               4586      MOVE.B  #L_, (A5)+  
00003B2A  1AFC 0009               4587      MOVE.B  #TAB, (A5)+ 
00003B2E  6000 0002               4588      BRA check_ir_bit    
00003B32                          4589    
00003B32                          4590  check_ir_bit    
00003B32  0C04 0000               4591      CMPI.B  #0, D4    
00003B36  6700 000E               4592      BEQ as_ls_ro_count  
00003B3A  0C04 0001               4593      CMPI.B  #1, D4    
00003B3E  6700 0052               4594      BEQ as_ls_ro_register   
00003B42                          4595  
00003B42  6000 00A8               4596      BRA as_ls_ro_invalid
00003B46                          4597              
00003B46                          4598      
00003B46                          4599  as_ls_ro_count     
00003B46  1AFC 0023               4600      MOVE.B  #SHARP, (A5)+
00003B4A  1AFC 0024               4601      MOVE.B  #DOLLAR, (A5)+ 
00003B4E  6100 02F2               4602      BSR put_zero        
00003B52  1800                    4603      MOVE.B  D0, D4  
00003B54  3001                    4604      MOVE.W  D1, D0 
00003B56  0C40 0000               4605      CMPI.W  #0, D0  
00003B5A  6700 001C               4606      BEQ as_ls_ro_eight  
00003B5E                          4607         
00003B5E  6100 029A               4608      BSR put_number
00003B62  1004                    4609      MOVE.B  D4, D0   
00003B64  1AFC 002C               4610      MOVE.B  #COMMA, (A5)+   
00003B68  1AFC 0020               4611      MOVE.B  #SPACE, (A5)+   
00003B6C  1AFC 0044               4612      MOVE.B  #D_, (A5)+
00003B70  6100 0288               4613      BSR put_number
00003B74  6000 0234               4614      BRA AS_LS_RO_done
00003B78                          4615  
00003B78                          4616  as_ls_ro_eight
00003B78  6100 0308               4617      BSR PUT_EIGHT
00003B7C  1004                    4618      MOVE.B  D4, D0   
00003B7E  1AFC 002C               4619      MOVE.B  #COMMA, (A5)+   
00003B82  1AFC 0020               4620      MOVE.B  #SPACE, (A5)+   
00003B86  1AFC 0044               4621      MOVE.B  #D_, (A5)+
00003B8A  6100 026E               4622      BSR put_number
00003B8E  6000 021A               4623      BRA AS_LS_RO_done     
00003B92                          4624  
00003B92                          4625  as_ls_ro_register
00003B92  1AFC 0044               4626      MOVE.B  #D_, (A5)+  
00003B96  1800                    4627      MOVE.B  D0, D4  
00003B98  1001                    4628      MOVE.B  D1, D0 
00003B9A  6100 025E               4629      BSR put_number
00003B9E  1004                    4630      MOVE.B  D4, D0          
00003BA0  1AFC 002C               4631      MOVE.B  #COMMA, (A5)+   
00003BA4  1AFC 0020               4632      MOVE.B  #SPACE, (A5)+   
00003BA8  1AFC 0044               4633      MOVE.B  #D_, (A5)+
00003BAC  6100 024C               4634      BSR put_number
00003BB0  6000 01F8               4635      BRA AS_LS_RO_done
00003BB4                          4636      
00003BB4                          4637  ls_shift    
00003BB4  1AFC 004C               4638      MOVE.B  #L_, (A5)+  
00003BB8  1AFC 0053               4639      MOVE.B  #S_, (A5)+  
00003BBC                          4640      
00003BBC  0C02 0000               4641      CMPI.B  #0, D2    
00003BC0  6700 FF18               4642      BEQ as_ls_ro_right 
00003BC4  0C02 0001               4643      CMPI.B  #1, D2    
00003BC8  6700 FF1C               4644      BEQ as_ls_ro_left
00003BCC                          4645      
00003BCC  6000 001E               4646      BRA as_ls_ro_invalid 
00003BD0                          4647      
00003BD0                          4648  ro_shift
00003BD0  1AFC 0052               4649      MOVE.B  #R_, (A5)+  
00003BD4  1AFC 004F               4650      MOVE.B  #O_, (A5)+  
00003BD8                          4651      
00003BD8  0C02 0000               4652      CMPI.B  #0, D2    
00003BDC  6700 FEFC               4653      BEQ as_ls_ro_right 
00003BE0  0C02 0001               4654      CMPI.B  #1, D2    
00003BE4  6700 FF00               4655      BEQ as_ls_ro_left
00003BE8                          4656  
00003BE8  6000 0002               4657      BRA as_ls_ro_invalid 
00003BEC                          4658          
00003BEC                          4659  as_ls_ro_invalid
00003BEC  4CDF 2000               4660      MOVEM.L (A7)+, A5
00003BF0  6000 D5BC               4661      BRA invalid_code     
00003BF4                          4662      
00003BF4                          4663  memory_shift
00003BF4  0C02 0000               4664      CMPI.B  #0, D2    
00003BF8  6700 000C               4665      BEQ right_shift 
00003BFC                          4666      
00003BFC  0C02 0001               4667      CMPI.B  #1, D2    
00003C00  6700 0074               4668      BEQ left_shift  
00003C04  60E6                    4669      BRA as_ls_ro_invalid         
00003C06                          4670  
00003C06                          4671  right_shift
00003C06                          4672      * check the type among ASR.W, LSR.W, ROR.W
00003C06  0C41 0000               4673      CMPI.w  #0, D1
00003C0A  6700 0016               4674      BEQ asr_w_memory
00003C0E                          4675      
00003C0E  0C41 0001               4676      CMPI.w  #1, D1
00003C12  6700 002A               4677      BEQ lsr_w_memory
00003C16                          4678      
00003C16  0C41 0003               4679      CMPI.w  #3, D1
00003C1A  6700 003E               4680      BEQ ror_w_memory
00003C1E                          4681  
00003C1E  6000 D58E               4682      BRA invalid_code         
00003C22                          4683      
00003C22                          4684  asr_w_memory       
00003C22  1AFC 0041               4685      MOVE.B #A_, (A5)+   
00003C26  1AFC 0053               4686       MOVE.B #S_, (A5)+   
00003C2A  1AFC 0052               4687      MOVE.B #R_, (A5)+   
00003C2E  1AFC 002E               4688      MOVE.B #PERIOD, (A5)+    
00003C32  1AFC 0057               4689      MOVE.B #W_, (A5)+  
00003C36  1AFC 0009               4690      MOVE.B #TAB, (A5)+          
00003C3A  6000 00AA               4691      BRA memory_type
00003C3E                          4692  
00003C3E                          4693  lsr_w_memory
00003C3E  1AFC 004C               4694      MOVE.B #L_, (A5)+       
00003C42  1AFC 0053               4695      MOVE.B #S_, (A5)+   
00003C46  1AFC 0052               4696      MOVE.B #R_, (A5)+   
00003C4A  1AFC 002E               4697      MOVE.B #PERIOD, (A5)+    
00003C4E  1AFC 0057               4698      MOVE.B #W_, (A5)+ 
00003C52  1AFC 0009               4699      MOVE.B #TAB, (A5)+               
00003C56  6000 008E               4700      BRA memory_type
00003C5A                          4701    
00003C5A                          4702  ror_w_memory
00003C5A  1AFC 0052               4703      MOVE.B #R_, (A5)+       
00003C5E  1AFC 004F               4704      MOVE.B #O_, (A5)+       
00003C62  1AFC 0052               4705      MOVE.B #R_, (A5)+   
00003C66  1AFC 002E               4706      MOVE.B #PERIOD, (A5)+    
00003C6A  1AFC 0057               4707      MOVE.B #W_, (A5)+ 
00003C6E  1AFC 0009               4708      MOVE.B #TAB, (A5)+                
00003C72  6000 0072               4709      BRA memory_type
00003C76                          4710  
00003C76                          4711           
00003C76                          4712  left_shift
00003C76                          4713      * check the type among ASL.W, LSL.W, ROL.W
00003C76                          4714      
00003C76  0C41 0000               4715      CMPI.w  #0, D1      * hex 0000       
00003C7A  6700 0016               4716      BEQ asl_w_memory
00003C7E                          4717      
00003C7E  0C41 0001               4718      CMPI.w  #1, D1  * hex 0001
00003C82  6700 002A               4719      BEQ lsl_w_memory
00003C86                          4720      
00003C86  0C41 0003               4721      CMPI.w  #3, D1
00003C8A  6700 003E               4722      BEQ rol_w_memory
00003C8E                          4723  
00003C8E  6000 D51E               4724      BRA invalid_code         
00003C92                          4725  
00003C92                          4726  asl_w_memory       
00003C92  1AFC 0041               4727      MOVE.B #A_, (A5)+   
00003C96  1AFC 0053               4728      MOVE.B #S_, (A5)+   
00003C9A  1AFC 004C               4729      MOVE.B #L_, (A5)+       
00003C9E  1AFC 002E               4730      MOVE.B #PERIOD, (A5)+    
00003CA2  1AFC 0057               4731      MOVE.B #W_, (A5)+  
00003CA6  1AFC 0009               4732      MOVE.B #TAB, (A5)+  
00003CAA  6000 003A               4733      BRA memory_type
00003CAE                          4734  
00003CAE                          4735  lsl_w_memory
00003CAE  1AFC 004C               4736      MOVE.B #L_, (A5)+       
00003CB2  1AFC 0053               4737      MOVE.B #S_, (A5)+   
00003CB6  1AFC 004C               4738      MOVE.B #L_, (A5)+    
00003CBA  1AFC 002E               4739      MOVE.B #PERIOD, (A5)+    
00003CBE  1AFC 0057               4740      MOVE.B #W_, (A5)+
00003CC2  1AFC 0009               4741      MOVE.B #TAB, (A5)+           
00003CC6  6000 001E               4742      BRA memory_type
00003CCA                          4743          
00003CCA                          4744  rol_w_memory
00003CCA  1AFC 0052               4745      MOVE.B #R_, (A5)+       
00003CCE  1AFC 004F               4746      MOVE.B #O_, (A5)+       
00003CD2  1AFC 004C               4747      MOVE.B #L_, (A5)+       
00003CD6  1AFC 002E               4748      MOVE.B #PERIOD, (A5)+    
00003CDA  1AFC 0057               4749      MOVE.B #W_, (A5)+ 
00003CDE  1AFC 0009               4750      MOVE.B #TAB, (A5)+          
00003CE2  6000 0002               4751      BRA memory_type
00003CE6                          4752         
00003CE6                          4753  
00003CE6                          4754  memory_type
00003CE6                          4755          *CHECK I/R BIT AND TYPE BITS TO VALIDATE THE TYPE OF EA
00003CE6                          4756      
00003CE6  0C04 0000               4757      CMPI.B  #0, D4
00003CEA  6700 000E               4758          BEQ check_nextTwo  * next two digits are one of 10, 11
00003CEE  0C04 0001               4759      CMPI.B  #1, D4    
00003CF2  6700 001A               4760          BEQ  check_nextTwo2 * next two digits should be one of 11, 00
00003CF6                          4761  
00003CF6  6000 FEF4               4762      BRA as_ls_ro_invalid         
00003CFA                          4763  
00003CFA                          4764  check_nextTwo
00003CFA  0C06 0002               4765      CMPI.B  #2, D6    
00003CFE  6700 0022               4766          BEQ indirect
00003D02  0C06 0003               4767      CMPI.B  #3, D6    
00003D06  6700 002E               4768          BEQ indirect_postIncrement
00003D0A  6000 FEE0               4769      BRA as_ls_ro_invalid         
00003D0E                          4770  
00003D0E                          4771  check_nextTwo2
00003D0E  0C06 0000               4772      CMPI.B  #0, D6    
00003D12  6700 003A               4773          BEQ indirect_preDecrement
00003D16  0C06 0003               4774      CMPI.B  #3, D6    
00003D1A  6700 004A               4775          BEQ absolute
00003D1E  6000 FECC               4776      BRA as_ls_ro_invalid
00003D22                          4777  
00003D22                          4778  indirect
00003D22  1AFC 0028               4779      MOVE.B  #Open_paren, (A5)+  
00003D26  1AFC 0041               4780      MOVE.B  #A_, (A5)+ 
00003D2A  6100 00CE               4781      BSR put_number  
00003D2E  1AFC 0029               4782      MOVE.B  #Close_paren, (A5)+ 
00003D32  6000 0076               4783      BRA AS_LS_RO_done
00003D36                          4784       
00003D36                          4785  indirect_postIncrement  
00003D36  1AFC 0028               4786          MOVE.B  #Open_paren, (A5)+     
00003D3A  1AFC 0041               4787          MOVE.B  #A_, (A5)+   
00003D3E  6100 00BA               4788          BSR put_number  
00003D42  1AFC 0029               4789          MOVE.B  #Close_paren, (A5)+ 
00003D46  1AFC 002B               4790          MOVE.B  #PLUS,  (A5)+   
00003D4A  6000 005E               4791      BRA AS_LS_RO_done
00003D4E                          4792  
00003D4E                          4793  indirect_preDecrement
00003D4E  1AFC 002D               4794      MOVE.B  #MINUS, (A5)+
00003D52  1AFC 0028               4795      MOVE.B  #Open_paren, (A5)+     
00003D56  1AFC 0041               4796      MOVE.B  #A_, (A5)+  
00003D5A  6100 009E               4797      BSR put_number  
00003D5E  1AFC 0029               4798      MOVE.B  #Close_paren, (A5)+ 
00003D62  6000 0046               4799      BRA AS_LS_RO_done
00003D66                          4800  
00003D66                          4801      
00003D66                          4802      
00003D66                          4803  absolute
00003D66  1AFC 0024               4804      MOVE.B  #DOLLAR, (A5)+      
00003D6A  0C40 0000               4805      CMPI.W #$0000, D0      
00003D6E  6700 000E               4806      BEQ AS_LS_RO_word_ea    
00003D72  0C40 0001               4807      CMPI.W  #$0001, D0    
00003D76  6700 001C               4808      BEQ AS_LS_RO_long_ea    
00003D7A  6000 FE70               4809      BRA as_ls_ro_invalid  
00003D7E                          4810      
00003D7E                          4811  AS_LS_RO_word_ea
00003D7E  3C5A                    4812      MOVEA.W (A2)+, A6   
00003D80  323C 0004               4813      MOVE.W  #word, D1   
00003D84  48E7 0080               4814      MOVEM.L A0, -(A7)   
00003D88  6100 D4EA               4815      BSR hex_to_string   
00003D8C  4CDF 0100               4816      MOVEM.L (A7)+, A0   
00003D90  6000 0018               4817      BRA AS_LS_RO_done      
00003D94                          4818      
00003D94                          4819  AS_LS_RO_long_ea
00003D94  2C5A                    4820      MOVEA.L (A2)+, A6   
00003D96  323C 0008               4821      MOVE.W  #long, D1   
00003D9A  48E7 0080               4822      MOVEM.L A0, -(A7)   
00003D9E  6100 D4D4               4823      BSR hex_to_string   
00003DA2  4CDF 0100               4824      MOVEM.L (A7)+, A0   
00003DA6  6000 0002               4825      BRA AS_LS_RO_done     
00003DAA                          4826  
00003DAA                          4827  AS_LS_RO_done   
00003DAA  2C48                    4828          MOVEA.L A0, A6  
00003DAC  4246                    4829          CLR D6  
00003DAE                          4830   
00003DAE                          4831  AS_LS_RO_loop
00003DAE  BBC8                    4832      CMPA.L  A0, A5  ;   
00003DB0  6700 000C               4833      BEQ AS_LS_RO_message_out 
00003DB4  5286                    4834      ADDI.L  #1, D6  ;   increment count  
00003DB6  2A08                    4835      MOVE.L  A0, D5  ;   
00003DB8  5285                    4836      ADDI.L  #1, D5  ;   
00003DBA  2045                    4837      MOVEA.L D5, A0  ;   increment address   
00003DBC  60F0                    4838      BRA AS_LS_RO_loop    ;    
00003DBE                          4839  
00003DBE                          4840  
00003DBE                          4841  AS_LS_RO_message_out
00003DBE  4CDF 2000               4842      MOVEM.L (A7)+, A5   
00003DC2  6100 D59A               4843      BSR copy_string 
00003DC6  6000 D494               4844      BRA decode_end  
00003DCA                          4845   
00003DCA                          4846  
00003DCA                          4847  * D0 contains opcode, D6 contains mask, D7 contains shift value 
00003DCA                          4848  * return D0 after masking and shifting 
00003DCA                          4849  get_bit
00003DCA                          4850      * bitmasking
00003DCA  C046                    4851      AND.W   D6, D0  ;   
00003DCC  EE68                    4852      LSR.W   D7, D0  ;
00003DCE  4E75                    4853      RTS 
00003DD0                          4854  
00003DD0                          4855  * add .B, .W, .L in the A6  (temp result) 
00003DD0                          4856  add_dot_B
00003DD0  1AF8 002E               4857      MOVE.B  PERIOD, (A5)+   
00003DD4  1AF8 0042               4858      MOVE.B  B_, (A5)+   
00003DD8  1AF8 0009               4859      MOVE.B  TAB, (A5)+  ;   
00003DDC                          4860  
00003DDC  4E75                    4861      RTS     ;   
00003DDE                          4862      
00003DDE                          4863  add_dot_W   
00003DDE  1AF8 002E               4864      MOVE.B  PERIOD, (A5)+   
00003DE2  1AF8 0057               4865      MOVE.B  W_, (A5)+   
00003DE6  1AF8 0009               4866      MOVE.B  TAB, (A5)+  ;
00003DEA  4E75                    4867      RTS     ;   
00003DEC                          4868      
00003DEC                          4869  add_dot_L   
00003DEC  1AF8 002E               4870      MOVE.B  PERIOD, (A5)+   ;   
00003DF0  1AF8 004C               4871      MOVE.B  L_, (A5)+   ;   
00003DF4  1AF8 0009               4872      MOVE.B  TAB, (A5)+  ;
00003DF8  4E75                    4873      RTS     ;   
00003DFA                          4874  
00003DFA                          4875  * D0 has digit  
00003DFA                          4876  *   put digit in the A5 with Ascii  
00003DFA                          4877  put_number  
00003DFA  0C00 0000               4878      CMPI.B  #0, D0  
00003DFE  6700 0042               4879      BEQ put_zero    
00003E02                          4880  
00003E02  0C00 0001               4881      CMPI.B  #1, D0  
00003E06  6700 0042               4882      BEQ put_one 
00003E0A                          4883  
00003E0A  0C00 0002               4884    CMPI.B    #2, D0  ;   
00003E0E  6700 0042               4885    BEQ   put_two 
00003E12                          4886    
00003E12  0C00 0003               4887    CMPI.B    #3, D0  ;   
00003E16  6700 0042               4888    BEQ   put_three   ;   
00003E1A                          4889    
00003E1A  0C00 0004               4890    CMPI.B    #4, D0  ;   
00003E1E  6700 0042               4891    BEQ   put_four    ;   
00003E22                          4892    
00003E22  0C00 0005               4893    CMPI.B    #5, D0  ;   
00003E26  6700 0042               4894    BEQ   put_five    ;   
00003E2A                          4895    
00003E2A  0C00 0006               4896    CMPI.B    #6, D0  ;   
00003E2E  6700 0042               4897    BEQ   put_six     ;   
00003E32                          4898    
00003E32  0C00 0007               4899    CMPI.B    #7, D0  ;   
00003E36  6700 0042               4900    BEQ   put_seven   ;  
00003E3A                          4901  
00003E3A  0C40 0008               4902    CMPI.W    #8, D0  
00003E3E  6700 0042               4903    BEQ   PUT_EIGHT    
00003E42                          4904    
00003E42                          4905  put_zero
00003E42  1AFC 0030               4906      MOVE.B  #ZERO_, (A5)+    
00003E46  6000 0042               4907          BRA put_number_done ;    
00003E4A                          4908  put_one
00003E4A  1AFC 0031               4909      MOVE.B  #ONE_, (A5)+ 
00003E4E  6000 003A               4910      BRA put_number_done ;   
00003E52                          4911  put_two
00003E52  1AFC 0032               4912      MOVE.B  #TWO_, (A5)+ 
00003E56  6000 0032               4913       BRA put_number_done ;   
00003E5A                          4914  put_three
00003E5A  1AFC 0033               4915      MOVE.B  #THREE_, (A5)+
00003E5E  6000 002A               4916      BRA put_number_done ;   
00003E62                          4917  put_four
00003E62  1AFC 0034               4918      MOVE.B  #FOUR_, (A5)+
00003E66  6000 0022               4919      BRA put_number_done ;   
00003E6A                          4920  put_five
00003E6A  1AFC 0035               4921      MOVE.B  #FIVE_, (A5)+
00003E6E  6000 001A               4922      BRA put_number_done ;   
00003E72                          4923  put_six
00003E72  1AFC 0036               4924      MOVE.B  #SIX_, (A5)+
00003E76  6000 0012               4925      BRA put_number_done ;   
00003E7A                          4926  put_seven
00003E7A  1AFC 0037               4927      MOVE.B  #SEVEN_, (A5)+   
00003E7E  6000 000A               4928      BRA put_number_done ;  
00003E82                          4929  PUT_EIGHT   
00003E82  1AFC 0038               4930      MOVE.B  #EIGHT_, (A5)+  
00003E86  6000 0002               4931      BRA put_number_done 
00003E8A                          4932  put_number_done 
00003E8A  4E75                    4933      RTS 
00003E8C                          4934  
00003E8C                          4935  
00003E8C                          4936  * Decode functions end*********************************************************************************    
00003E8C                          4937  * INSTRUCTION_NAME   
00003E8C= 52 54 53                4938  RTS_    DC.B    'RTS'   ;    
00003E8F= 4E 4F 50                4939  NOP_     DC.B    'NOP'   ;  
00003E92                          4940  
00003E92                          4941  * CONSTANTS 
00003E92                          4942  
00003E92= 54 6F 20 63 6F 6E ...   4943  CONTINUE_MSG    DC.B    'To continue, press ENTER: ', 0
00003EAD= 46 69 6E 69 73 68 ...   4944  FINAL_MSG       DC.B    'Finished decoding. Press any key to EXIT', 0  
00003ED6= 44 41 54 41 20 20 ...   4945  INVALID_MSG     DC.B    'DATA   $WXYZ'                        ;INVALID MESSAGE       
00003EE2                          4946  
00003EE2                          4947  
00003EE2= 45 6E 74 65 72 20 ...   4948  PROMPT_1        DC.B    'Enter starting address. RANGE= [$7000, $9FFF]', 0 
00003F10= 45 6E 74 65 72 20 ...   4949  PROMPT_2        DC.B    'Enter ending address. RANGE = [$7000, $9FFF]', 0
00003F3D= 24 00                   4950  PROMPT_3        DC.B    '$', 0
00003F3F= 50 72 65 73 73 20 ...   4951  PROMPT_4        DC.B    'Press ENTER to continue...', 0
00003F5A                          4952  
00003F5A= 30 31 32 33 34 35 ...   4953  LIST_HEX        DC.B    '0123456789ABCDEF'
00003F6A                          4954  
00003F6A                          4955  START_HEX       DS.L    $1      ; starting pointer  
00003F6E                          4956  END_HEX         DS.L    $1      ; ending pointer    
00003F72                          4957  INPUT           DS.B    $8      ; input string  
00003F7A                          4958  INPUT_LENGTH    DS.W    $1      ; size of the input string  
00003F7C                          4959  
00003F7C=                         4960  RESULT_MSG  DC.B    ''  ; 
00003F7C                          4961  
00003F7C                          4962  
00003F7C                          4963      END    START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ABSOLUTE            3D66
ADDA_AN             3834
ADDA_AN_PLUS        387C
ADDA_DN             3814
ADDA_INDIRECT_AN    3854
ADDA_LONG           348A
ADDA_LONG_EA        391E
ADDA_MINUS_AN       38A8
ADDA_SOURCE_DATA    394C
ADDA_SOURCE_DATA_BYTE  3960
ADDA_SOURCE_DATA_LONG  39D2
ADDA_SOURCE_DATA_WORD  39A2
ADDA_SOURCE_EA      34F6
ADDA_SOURCE_VALID   397C
ADDA_SOURCE_WORD_LONG  38D4
ADDA_WORD           3476
ADDA_WORD_EA        38F0
ADD_ADDA            3362
ADD_ADDA_DONE       3A0A
ADD_ADDA_LOOP       3A0E
ADD_ADDA_MESSAGE_OUT  3A1E
ADD_AN              354A
ADD_AN_PLUS         3592
ADD_AN_REG          2268
ADD_AN_REG_MTR      2794
ADD_AN_REG_PREDEC   22F6
ADD_B               13D6
ADD_BYTE_DESTEA     343E
ADD_BYTE_SOURCEEA   3406
ADD_DEST_AN_PLUS    374C
ADD_DEST_EA         34D2
ADD_DEST_INDIRECT_AN  3724
ADD_DEST_LONG       37E6
ADD_DEST_MINUS_AN   3778
ADD_DEST_WORD       37B8
ADD_DEST_WORD_LONG  37A4
ADD_DN              352A
ADD_DN_REG_RTM      2330
ADD_DOT_B           3DD0
ADD_DOT_L           3DEC
ADD_DOT_W           3DDE
ADD_INDIRECT_AN     356A
ADD_INVALID         3A02
ADD_L               1422
ADD_LONG            3634
ADD_LONG_DESTEA     3466
ADD_LONG_SOURCEEA   342E
ADD_MINUS_AN        35BE
ADD_REG             222E
ADD_SOURCE_DATA     3662
ADD_SOURCE_DATA_BYTE  367E
ADD_SOURCE_DATA_LONG  36F2
ADD_SOURCE_DATA_WORD  36C0
ADD_SOURCE_EA       349E
ADD_SOURCE_VALID    369A
ADD_SOURCE_WORD_LONG_DATA  35EA
ADD_W               13FC
ADD_WORD            3606
ADD_WORD_DESTEA     3456
ADD_WORD_SOURCEEA   341E
AN_LOOP             224E
AN_LOOP_MTR         277A
ASLR_LSLR_ROLR      3A2A
ASL_W_MEMORY        3C92
ASR_W_MEMORY        3C22
AS_LS_RO_COUNT      3B46
AS_LS_RO_DONE       3DAA
AS_LS_RO_EIGHT      3B78
AS_LS_RO_INVALID    3BEC
AS_LS_RO_LEFT       3AE6
AS_LS_RO_LONG_EA    3D94
AS_LS_RO_LOOP       3DAE
AS_LS_RO_MESSAGE_OUT  3DBE
AS_LS_RO_REGISTER   3B92
AS_LS_RO_RIGHT      3ADA
AS_LS_RO_SIZE       3AF2
AS_LS_RO_WORD_EA    3D7E
AS_SHIFT            3ABE
A_                  41
BCC_FUNCTION        2A38
BCLR_DN_EA          165E
BCLR_DN_VALID       1698
BCLR_IMMEDIATE_EA_FUNCTION  1556
BCLR_IMMEDIATE_EA_VALID  1590
BCLR_IM_VAL         15AE
BCS_FUNCTION        2A60
BGE_FUNCTION        2AB4
BLT_FUNCTION        2ADE
BRA_CHECK           29F2
BRA_END             2A1E
BRA_FUNCTION        29CC
BRA_LONG            2A14
BRA_WORD            2A0A
BVC_FUNCTION        2A8A
BYTE                2
BYTE_SHIFT          3B0E
B_                  42
B_START             124C
CHECK_DIVS          257C
CHECK_ENDING_BOUND  10CC
CHECK_IR_BIT        3B32
CHECK_MODE          1448
CHECK_MULS          24CC
CHECK_NEXTTWO       3CFA
CHECK_NEXTTWO2      3D0E
CHECK_STARTING_BOUND  10AA
CLEAR               0
CLEARSCREEN         1352
CLOSE_PAREN         29
CMPI_FUNCTION       1614
CMP_AN              2E0A
CMP_AN_PLUS         2E52
CMP_B_              2D0E
CMP_DATA            2F22
CMP_DATA_BYTE       2F3E
CMP_DATA_LONG       2FB2
CMP_DATA_WORD       2F80
CMP_DN              2DEA
CMP_DONE            3128
CMP_EA              2DB6
CMP_EOR_INVALID     3120
CMP_INDIRECT_AN     2E2A
CMP_LONG            2EF4
CMP_LOOP            312C
CMP_L_              2D46
CMP_MESSAGE_OUT     313C
CMP_MINUS_AN        2E7E
CMP_VALID           2F5A
CMP_WORD            2EC6
CMP_WORD_LONG_DATA  2EAA
CMP_W_              2D2A
COLON               3A
COMMA               2C
CONTINUE_DECODING   1104
CONTINUE_MSG        3E92
COPYLOOP            1362
COPYLOOPDONE        136E
COPY_STRING         135E
CR                  D
C_                  43
C_START             1250
DASH                2D
DECODE              110A
DECODE_END          125C
DECODE_LOOP         10EC
DECODE_START        1112
DEST_MOVEA_L_ADDR_REG  1A78
DEST_MOVEA_W_ADDR_REG  1E26
DEST_MOVE_B_ADDR_REG_MINUS  1888
DEST_MOVE_B_ADDR_REG_PAREN  185C
DEST_MOVE_B_ADDR_REG_PLUS  1870
DEST_MOVE_B_DATA_REG  1850
DEST_MOVE_B_EA      18A0
DEST_MOVE_B_SRC_LONG  18D2
DEST_MOVE_B_SRC_WORD  18B8
DEST_MOVE_L_ADDR_REG_MINUS  1C36
DEST_MOVE_L_ADDR_REG_PAREN  1C0A
DEST_MOVE_L_ADDR_REG_PLUS  1C1E
DEST_MOVE_L_DATA_REG  1BFE
DEST_MOVE_L_EA      1C4E
DEST_MOVE_L_SRC_LONG  1C80
DEST_MOVE_L_SRC_WORD  1C66
DEST_MOVE_W_ADDR_REG_MINUS  1FE4
DEST_MOVE_W_ADDR_REG_PAREN  1FB8
DEST_MOVE_W_ADDR_REG_PLUS  1FCC
DEST_MOVE_W_DATA_REG  1FAC
DEST_MOVE_W_EA      1FFC
DEST_MOVE_W_SRC_LONG  202E
DEST_MOVE_W_SRC_WORD  2014
DISPLAY_SIZE        14
DIVS_L              255C
DIVS_W              2BA0
DOLLAR              24
D_                  44
D_START             1254
EIGHT_              38
EIGHT_START         1244
ENDINGISGREATERTHANSTART  1032
ENDPROMPT           101C
END_HEX             3F6E
EOR_AN_PLUS         3058
EOR_B_              2D62
EOR_CMP             2C86
EOR_DN              3010
EOR_EA              2FE4
EOR_INDIRECT_AN     3030
EOR_LONG            30F2
EOR_L_              2D9A
EOR_MINUS_AN        3084
EOR_WORD            30C4
EOR_WORD_LONG       30B0
EOR_W_              2D7E
E_                  45
E_START             1258
FINAL_MSG           3EAD
FINISHINGINPUT      1344
FINISHPROGRAM       130E
FINISH_PAGE         12F4
FIVE_               35
FIVE_START          120C
FOUR_               34
FOUR_START          11E8
F_                  46
GETEA               20AE
GET_BIT             3DCA
GET_FIRSTFOURBITS   12DA
GET_LSB             2284
GET_SECONDFOURBITS  12E4
GET_SUBQ_DATA       2930
GET_SUBQ_EA         296A
G_                  47
HEX_FOUND           10A0
HEX_LOOP            108A
HEX_TO_STRING       1274
HTSDONE             12D8
HTSLOOP             12B6
H_                  48
INCREMENT           1
INDIRECT            3D22
INDIRECT_POSTINCREMENT  3D36
INDIRECT_PREDECREMENT  3D4E
INIT                0
INITBYTE            12AC
INITLONG            1298
INITWORD            12A2
INPUT               3F72
INPUT_LENGTH        3F7A
INVALID_CODE        11AE
INVALID_MSG         3ED6
IS_BYTE             208A
IS_LONG             20A2
IS_WORD             2096
I_                  49
JSR_FUNCTION        27B0
J_                  4A
KEEP_DIVS_W         2BAE
KEEP_MULS_W         316E
K_                  4B
LEA_ADDR_PAREN      284C
LEA_ADD_AN          28A8
LEA_EA              2816
LEA_FUNCTION        27FE
LEA_LONG_EA         2892
LEA_WORD_EA         287C
LEA_WORD_LONG_EA    2860
LEFT_SHIFT          3C76
LF                  A
LIST_HEX            3F5A
LIST_HEX_SIZE       10
LONG                8
LONG_EA             1520
LONG_SHIFT          3B26
LSL_W_MEMORY        3CAE
LSR_W_MEMORY        3C3E
LS_SHIFT            3BB4
L_                  4C
MAIN                10D4
MEMORY_SHIFT        3BF4
MEMORY_TYPE         3CE6
MESSAGE_OUT         3356
MINUS               2D
MOVEA_L             192E
MOVEA_L_ADDR_REG    19A0
MOVEA_L_ADDR_REG_MINUS  19D8
MOVEA_L_ADDR_REG_PAREN  19AC
MOVEA_L_ADDR_REG_PLUS  19C0
MOVEA_L_DATA_REG    1994
MOVEA_L_DEST        1A62
MOVEA_L_DONE        1A80
MOVEA_L_EA_IM       19F0
MOVEA_L_SRC_IMM     1A44
MOVEA_L_SRC_LONG    1A2A
MOVEA_L_SRC_WORD    1A10
MOVEA_W             1CDC
MOVEA_W_ADDR_REG    1D4E
MOVEA_W_ADDR_REG_MINUS  1D86
MOVEA_W_ADDR_REG_PAREN  1D5A
MOVEA_W_ADDR_REG_PLUS  1D6E
MOVEA_W_DATA_REG    1D42
MOVEA_W_DEST        1E10
MOVEA_W_DONE        1E2E
MOVEA_W_EA_IM       1D9E
MOVEA_W_SRC_IMM     1DF2
MOVEA_W_SRC_LONG    1DD8
MOVEA_W_SRC_WORD    1DBE
MOVEM_INVALID       21D2
MOVEM_L_MTR         2648
MOVEM_L_RTM         21E6
MOVEM_MTR           2654
MOVEM_PREDEC        22DA
MOVEM_RTM           21F2
MOVEM_W_L_MTR       260C
MOVEM_W_L_RTOM      2194
MOVEM_W_MTR         263C
MOVEM_W_RTM         21DA
MOVE_B              16B2
MOVE_B_ADDR_REG     1738
MOVE_B_ADDR_REG_MINUS  1770
MOVE_B_ADDR_REG_PAREN  1744
MOVE_B_ADDR_REG_PLUS  1758
MOVE_B_DATA_REG     172C
MOVE_B_DEST         17FA
MOVE_B_DONE         18EC
MOVE_B_EA_IM        1788
MOVE_B_SRC          16D6
MOVE_B_SRC_IMM      17DC
MOVE_B_SRC_LONG     17C2
MOVE_B_SRC_WORD     17A8
MOVE_L              1A84
MOVE_L_ADDR_REG     1AE6
MOVE_L_ADDR_REG_MINUS  1B1E
MOVE_L_ADDR_REG_PAREN  1AF2
MOVE_L_ADDR_REG_PLUS  1B06
MOVE_L_DATA_REG     1ADA
MOVE_L_DEST         1BA8
MOVE_L_DONE         1C9A
MOVE_L_EA_IM        1B36
MOVE_L_SRC_IMM      1B8A
MOVE_L_SRC_LONG     1B70
MOVE_L_SRC_WORD     1B56
MOVE_MOVEA_L        18F0
MOVE_MOVEA_W        1C9E
MOVE_W              1E32
MOVE_W_ADDR_REG     1E94
MOVE_W_ADDR_REG_MINUS  1ECC
MOVE_W_ADDR_REG_PAREN  1EA0
MOVE_W_ADDR_REG_PLUS  1EB4
MOVE_W_DATA_REG     1E88
MOVE_W_DEST         1F56
MOVE_W_DONE         2048
MOVE_W_EA_IM        1EE4
MOVE_W_SRC_IMM      1F38
MOVE_W_SRC_LONG     1F1E
MOVE_W_SRC_WORD     1F04
MTR_ADDR_PAREN      269C
MTR_ADDR_PAREN_PLUS  26BC
MTR_ADD_REG         275A
MTR_AN_LOOP         2776
MTR_DN_LOOP         2740
MTR_EA              26E0
MTR_LONG_EA         271E
MTR_MOVEM_EA        265E
MTR_WORD_EA         26FC
MULS_ADDR_PAREN     23F6
MULS_ADDR_PAREN_MINUS  242E
MULS_ADDR_PAREN_PLUS  2410
MULS_DATA_EA        24A8
MULS_DATA_REG       23E4
MULS_DIVS_L_MOVEM_W_L_MTOR  234C
MULS_EA             244C
MULS_L              2376
MULS_LONG_EA        248C
MULS_L_EA           2396
MULS_W              3148
MULS_WORD_EA        2470
MULS_W_AN_PLUS      3238
MULS_W_DN           31F0
MULS_W_DONE         3342
MULS_W_EA           31C4
MULS_W_INDIRECT_AN  3210
MULS_W_INVALID      333A
MULS_W_LONG         32DA
MULS_W_LOOP         3346
MULS_W_MINUS_AN     3264
MULS_W_SOURCE_DATA  3308
MULS_W_SOURCE_WORD_LONG_DATA  3290
MULS_W_WORD         32AC
M_                  4D
NEG_ADDR_PAREN      2108
NEG_ADDR_PAREN_MINUS  2134
NEG_ADDR_PAREN_PLUS  211C
NEG_DATA_REG        20FC
NEG_EA              214C
NEG_FUNCTION        204C
NEG_LONG_EA         217E
NEG_WORD_EA         2168
NINE_               39
NINE_START          1248
NOP_                3E8F
NOP_FUNCTION        1380
NULL                0
N_                  4E
ONE_                31
ONE_REG_DIVS        25BE
ONE_REG_MULS        250E
ONE_START           11DC
OPEN_PAREN          28
OR                  2B2A
ORI_ADDR_PAREN      14AA
ORI_ADDR_PAREN_MINUS  14D6
ORI_ADDR_PAREN_PLUS  14BE
ORI_DATA_REG        149E
ORI_DONE            1536
ORI_EA              14EE
ORI_FUNCTION        1390
ORI_LOOP            153A
ORI_MESSAGE_OUT     154A
OR_DIVS_W           2B08
O_                  4F
PERIOD              2E
PLUS                2B
PRINTCONTINUEMESSAGE  131A
PRINTFINALMESSAGE   1336
PRINT_PAGE          1300
PROMPT_1            3EE2
PROMPT_2            3F10
PROMPT_3            3F3D
PROMPT_4            3F3F
PROMPT_END          10B2
PROMPT_START        1044
PUT_EIGHT           3E82
PUT_FIVE            3E6A
PUT_FOUR            3E62
PUT_NUMBER          3DFA
PUT_NUMBER_DONE     3E8A
PUT_ONE             3E4A
PUT_SEVEN           3E7A
PUT_SIX             3E72
PUT_THREE           3E5A
PUT_TWO             3E52
PUT_ZERO            3E42
P_                  50
Q_                  51
RANGE_END           9FFF
RANGE_REG_DIVS      25D8
RANGE_REG_MULS      2528
RANGE_START         7000
RESULT_MSG          3F7C
RIGHT_SHIFT         3C06
RLM_AN_LOOP         224A
RLM_DN_LOOP         2214
ROL_W_MEMORY        3CCA
ROR_W_MEMORY        3C5A
RO_SHIFT            3BD0
RTM_DN_LOOP         2316
RTM_DN_PREDEC       2312
RTM_PREDEC_LOOP     22DE
RTOM_EA             2294
RTS_                3E8C
RTS_FUNCTION        1370
R_                  52
SEVEN_              37
SHARP               23
SIX_                36
SIX_START           1210
SLASH               2F
SPACE               20
STACK               7000
START               1000
STARTINGISGREATER   1016
STARTPROMPT         1000
START_HEX           3F6A
STR_LOOP            107A
STR_LOOP_END        10A8
STR_TO_HEX          1072
SUBQ_ADD_AN         29C0
SUBQ_EIGHT          295A
SUBQ_FUNCTION       28CA
SUBQ_IS_BYTE        290C
SUBQ_IS_LONG        2924
SUBQ_IS_WORD        2918
SUB_FUNCTION        2BFE
S_                  53
TAB                 9
TAKECONTINUEINPUT   1328
TAKE_INPUT          105E
THREE_              33
THREE_START         11E4
TWO_                32
TWO_START           11E0
T_                  54
U_                  55
VALID               13E8
V_                  56
WORD                4
WORD_EA             150A
WORD_SHIFT          3B1A
W_                  57
X_                  58
Y_                  59
ZERO_               30
ZERO_START          11C0
Z_                  5A
